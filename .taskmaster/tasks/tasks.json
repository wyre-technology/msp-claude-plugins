{
  "master": {
    "tasks": [
      {
        "id": 42,
        "title": "Create GitHub Organization and Repository Structure",
        "description": "Set up the 'wyre-mcp' GitHub organization and establish the repository structure for the MCP Gateway and vendor-specific MCP servers.",
        "details": "1. Create the 'wyre-mcp' GitHub organization\n2. Configure organization settings (member permissions, required reviews)\n3. Create organization-level issue/PR templates\n4. Set up GitHub Container Registry (ghcr.io/wyre-mcp)\n5. Create organization secrets for CI/CD (AWS credentials, registry tokens)\n6. Create initial repositories:\n   - mcp-gateway (fork of agentic-community/mcp-gateway-registry)\n   - autotask-mcp (migrate from asachs01/autotask-mcp)\n   - datto-rmm-mcp (new)\n   - itglue-mcp (new)\n   - Additional vendor repos as needed\n7. Establish standard repository structure with README, LICENSE, CI/CD workflows",
        "testStrategy": "Verify organization creation and proper permissions. Confirm repository structure follows the defined pattern. Test CI/CD workflows with sample commits. Ensure GitHub Container Registry is properly configured for Docker image storage.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create and configure 'wyre-mcp' GitHub organization",
            "description": "Set up the GitHub organization with proper permissions and settings for team collaboration.",
            "dependencies": [],
            "details": "Create the 'wyre-mcp' GitHub organization. Configure organization settings including member permissions, required reviews, and team structure. Set up organization-level issue and PR templates for standardized contributions. Document organization access procedures for new team members.",
            "status": "pending",
            "testStrategy": "Verify organization creation with correct name. Confirm member permission settings match requirements. Test PR template functionality with sample PR. Ensure organization settings align with security best practices."
          },
          {
            "id": 2,
            "title": "Set up GitHub Container Registry and organization secrets",
            "description": "Configure GitHub Container Registry and establish organization-level secrets for CI/CD workflows.",
            "dependencies": [
              1
            ],
            "details": "Set up GitHub Container Registry (ghcr.io/wyre-mcp) for Docker image storage. Create and configure organization secrets for CI/CD pipelines including AWS credentials, registry tokens, and any other required authentication credentials. Document secret management procedures and access controls.",
            "status": "pending",
            "testStrategy": "Verify Container Registry is properly configured by pushing and pulling a test image. Confirm secrets are accessible to workflows but properly secured. Test secret rotation procedures."
          },
          {
            "id": 3,
            "title": "Create MCP Gateway repository",
            "description": "Fork the agentic-community/mcp-gateway-registry repository and set up as mcp-gateway.",
            "dependencies": [
              1,
              2
            ],
            "details": "Fork the agentic-community/mcp-gateway-registry repository into the wyre-mcp organization as mcp-gateway. Update repository configuration, README, and documentation to reflect the organization's standards. Set up branch protection rules, required reviewers, and CI/CD workflows. Configure repository-specific settings and access controls.",
            "status": "pending",
            "testStrategy": "Verify fork is complete with all original code. Test CI/CD workflows with sample commits. Ensure branch protection rules prevent direct pushes to main branch. Confirm documentation accurately reflects the project."
          },
          {
            "id": 4,
            "title": "Create vendor-specific MCP repositories",
            "description": "Set up repositories for Autotask, Datto RMM, and IT Glue MCP implementations.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create the following repositories with standardized structure: autotask-mcp (migrate from asachs01/autotask-mcp), datto-rmm-mcp (new), and itglue-mcp (new). Each repository should include standard README, LICENSE, .github workflows directory, and consistent project structure. Set up branch protection and code owners.",
            "status": "pending",
            "testStrategy": "Verify all repositories are created with consistent structure. Confirm migration of autotask-mcp preserves commit history. Test repository templates and workflows with sample commits. Ensure all repositories have proper license files."
          },
          {
            "id": 5,
            "title": "Establish standard CI/CD workflows across repositories",
            "description": "Create and implement standardized CI/CD workflows for all repositories in the organization.",
            "dependencies": [
              3,
              4
            ],
            "details": "Develop standardized GitHub Actions workflows for building, testing, and deploying MCP servers. Include workflows for Docker image building and publishing to GitHub Container Registry, automated testing, linting, and security scanning. Implement consistent versioning strategy across repositories. Document CI/CD processes in organization-level documentation.",
            "status": "pending",
            "testStrategy": "Test workflows on each repository with sample code changes. Verify Docker images build and publish correctly. Confirm test and linting processes run as expected. Validate security scanning identifies potential vulnerabilities."
          }
        ]
      },
      {
        "id": 43,
        "title": "Fork and Customize MCP Gateway",
        "description": "Fork the MCP Gateway Registry repository and customize it to support API key storage, MSP-specific vendor configurations, and credential entry UI.",
        "details": "1. Clone fork locally: 'wyre-mcp/mcp-gateway'\n2. Set up local development environment (Docker Compose)\n3. Extend 'credentials-provider/' to support API key storage (not just OAuth tokens)\n4. Add MSP-specific vendor configs to 'oauth_providers.yaml' equivalent\n5. Create vendor credential entry UI (FastAPI routes + Jinja2 templates)\n6. Customize branding/domain for 'mcp.wyre.ai'\n7. Implement session-aware stateful routing to map user sessions to stored credentials\n8. Add support for the following vendor routes:\n   - /v1/autotask/*\n   - /v1/datto-rmm/*\n   - /v1/itglue/*\n   - Additional vendor routes as needed\n9. Implement secure credential storage with AES-256 encryption",
        "testStrategy": "Unit tests for credential storage and retrieval. Integration tests for OAuth flow with PKCE. UI tests for credential entry pages. Security testing for encryption implementation. Load testing for routing performance.",
        "priority": "high",
        "dependencies": [
          42
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Fork Repository and Set Up Development Environment",
            "description": "Fork the MCP Gateway Registry repository and set up the local development environment with Docker Compose.",
            "dependencies": [],
            "details": "Clone the repository to 'wyre-mcp/mcp-gateway', configure Git remote to track upstream changes, and set up Docker Compose for local development. Ensure all dependencies are properly installed and the application runs locally.",
            "status": "pending",
            "testStrategy": "Verify successful local build and application startup. Test basic functionality to ensure the development environment is working correctly."
          },
          {
            "id": 2,
            "title": "Extend Credential Provider for API Key Storage",
            "description": "Modify the credentials-provider module to support API key storage in addition to OAuth tokens.",
            "dependencies": [
              1
            ],
            "details": "Extend the existing credential storage system to handle different credential types including API keys. Implement proper data models, storage mechanisms, and retrieval functions. Ensure backward compatibility with existing OAuth token storage.",
            "status": "pending",
            "testStrategy": "Unit tests for storing and retrieving different credential types. Security tests for credential encryption and decryption. Integration tests with the existing credential provider."
          },
          {
            "id": 3,
            "title": "Implement MSP-Specific Vendor Configurations",
            "description": "Add support for MSP-specific vendor configurations by extending the oauth_providers.yaml equivalent.",
            "dependencies": [
              2
            ],
            "details": "Create or modify configuration structures to support MSP-specific vendor settings. Implement a flexible configuration system that allows different MSPs to have their own vendor configurations while maintaining a common interface.",
            "status": "pending",
            "testStrategy": "Unit tests for configuration loading and validation. Integration tests with different MSP configurations to ensure proper isolation and functionality."
          },
          {
            "id": 4,
            "title": "Create Vendor Credential Entry UI",
            "description": "Develop a user interface for entering and managing vendor credentials using FastAPI routes and Jinja2 templates.",
            "dependencies": [
              3
            ],
            "details": "Design and implement FastAPI routes for credential management. Create Jinja2 templates for the UI components. Implement form validation, error handling, and success notifications. Customize branding for 'mcp.wyre.ai' and ensure responsive design.",
            "status": "pending",
            "testStrategy": "UI tests for form submission and validation. Accessibility testing. Cross-browser compatibility testing. User experience testing with sample workflows."
          },
          {
            "id": 5,
            "title": "Implement Session-Aware Routing and Vendor Routes",
            "description": "Develop session-aware stateful routing to map user sessions to stored credentials and add support for vendor-specific routes.",
            "dependencies": [
              4
            ],
            "details": "Implement session management to track user context. Create routing logic that maps sessions to the appropriate stored credentials. Add support for vendor-specific routes including /v1/autotask/*, /v1/datto-rmm/*, /v1/itglue/*, and others as needed. Implement secure credential access with AES-256 encryption for all stored credentials.",
            "status": "pending",
            "testStrategy": "Integration tests for routing logic. Security testing for session management. Load testing for routing performance. End-to-end tests for complete workflows with different vendor routes."
          }
        ]
      },
      {
        "id": 44,
        "title": "Implement Datto RMM MCP Server",
        "description": "Create the Datto RMM MCP server repository and implement the required tools to interact with the Datto RMM API.",
        "details": "1. Create repo: 'wyre-mcp/datto-rmm-mcp'\n2. Initialize TypeScript project with MCP SDK and @asachs01/node-datto-rmm\n3. Implement the following tools:\n   - datto_list_devices (GET /api/v2/account/devices)\n   - datto_get_device (GET /api/v2/device/{uid})\n   - datto_list_alerts (GET /api/v2/account/alerts)\n   - datto_resolve_alert (POST /api/v2/alert/{uid}/resolve)\n   - datto_list_sites (GET /api/v2/account/sites)\n   - datto_get_site (GET /api/v2/site/{uid})\n   - datto_run_quickjob (POST /api/v2/device/{uid}/quickjob)\n   - datto_get_audit (GET /api/v2/device/{uid}/audit/{type})\n4. Accept credentials via 'X-API-Key' / 'X-API-Secret' headers from gateway\n5. Create Dockerfile for containerization\n6. Implement error handling and rate limiting\n7. Add comprehensive logging",
        "testStrategy": "Unit tests for each tool implementation. Integration tests with mock Datto RMM API. End-to-end tests with real API credentials (in secure CI environment). Performance testing for response times. Security testing for credential handling.",
        "priority": "high",
        "dependencies": [
          42,
          43
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Repository and Initialize TypeScript Project",
            "description": "Set up the Datto RMM MCP server repository and initialize the TypeScript project with required dependencies.",
            "dependencies": [],
            "details": "Create the 'wyre-mcp/datto-rmm-mcp' repository on GitHub. Initialize a new TypeScript project with npm. Install the MCP SDK and @asachs01/node-datto-rmm package. Set up tsconfig.json, package.json, and basic project structure. Configure linting and formatting tools. Set up the initial server structure with Express.",
            "status": "pending",
            "testStrategy": "Verify project structure and dependency installation. Ensure the project builds without errors."
          },
          {
            "id": 2,
            "title": "Implement Device and Site Management Tools",
            "description": "Develop the tools for listing and retrieving device and site information from the Datto RMM API.",
            "dependencies": [
              1
            ],
            "details": "Implement the following tools: datto_list_devices (GET /api/v2/account/devices), datto_get_device (GET /api/v2/device/{uid}), datto_list_sites (GET /api/v2/account/sites), and datto_get_site (GET /api/v2/site/{uid}). Create proper request handling, parameter validation, and response formatting for each endpoint. Implement pagination for list endpoints. Add appropriate error handling and input validation.",
            "status": "pending",
            "testStrategy": "Unit tests for each tool implementation. Integration tests with mock Datto RMM API responses. Test pagination and error handling scenarios."
          },
          {
            "id": 3,
            "title": "Implement Alert Management and QuickJob Tools",
            "description": "Develop the tools for managing alerts and running quick jobs through the Datto RMM API.",
            "dependencies": [
              1
            ],
            "details": "Implement the following tools: datto_list_alerts (GET /api/v2/account/alerts), datto_resolve_alert (POST /api/v2/alert/{uid}/resolve), datto_run_quickjob (POST /api/v2/device/{uid}/quickjob), and datto_get_audit (GET /api/v2/device/{uid}/audit/{type}). Create proper request handling, parameter validation, and response formatting for each endpoint. Implement pagination for list endpoints. Add appropriate error handling and input validation.",
            "status": "pending",
            "testStrategy": "Unit tests for each tool implementation. Integration tests with mock Datto RMM API responses. Test various input scenarios and error conditions."
          },
          {
            "id": 4,
            "title": "Implement Authentication and Security Features",
            "description": "Develop the authentication mechanism and implement security features for the Datto RMM MCP server.",
            "dependencies": [
              1
            ],
            "details": "Implement authentication using 'X-API-Key' and 'X-API-Secret' headers from the gateway. Add middleware to validate these credentials before processing requests. Implement rate limiting to prevent API abuse. Add request logging for security auditing. Implement secure error handling that doesn't expose sensitive information. Add input sanitization to prevent injection attacks. Implement proper HTTP security headers.",
            "status": "pending",
            "testStrategy": "Security testing for credential handling. Test rate limiting functionality. Verify proper error handling with invalid credentials. Test input validation and sanitization."
          },
          {
            "id": 5,
            "title": "Containerize and Finalize Implementation",
            "description": "Create Docker configuration and finalize the implementation with comprehensive logging and documentation.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create a Dockerfile for containerization of the Datto RMM MCP server. Implement comprehensive logging throughout the application using a structured logging format. Add health check endpoints for container orchestration. Create documentation for API endpoints and usage. Add README with setup and configuration instructions. Implement graceful shutdown handling. Create CI/CD pipeline configuration for automated testing and deployment.",
            "status": "pending",
            "testStrategy": "Test Docker build and container functionality. Verify logging works correctly in containerized environment. End-to-end tests with real API credentials in a secure CI environment."
          }
        ]
      },
      {
        "id": 45,
        "title": "Implement IT Glue MCP Server",
        "description": "Create the IT Glue MCP server repository and implement the required tools to interact with the IT Glue API.",
        "details": "1. Create repo: 'wyre-mcp/itglue-mcp'\n2. Initialize TypeScript project with MCP SDK and @asachs01/node-it-glue\n3. Implement the following tools:\n   - itglue_search_organizations (GET /organizations)\n   - itglue_get_organization (GET /organizations/{id})\n   - itglue_search_configurations (GET /configurations)\n   - itglue_get_configuration (GET /configurations/{id})\n   - itglue_search_passwords (GET /passwords)\n   - itglue_get_password (GET /passwords/{id})\n   - itglue_search_documents (GET /documents)\n   - itglue_search_flexible_assets (GET /flexible_assets)\n4. Accept credentials via 'X-API-Key' header from gateway\n5. Create Dockerfile for containerization\n6. Implement error handling and rate limiting\n7. Add comprehensive logging",
        "testStrategy": "Unit tests for each tool implementation. Integration tests with mock IT Glue API. End-to-end tests with real API credentials (in secure CI environment). Performance testing for response times. Security testing for credential handling.",
        "priority": "high",
        "dependencies": [
          42,
          43
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create repository and initialize TypeScript project",
            "description": "Set up the IT Glue MCP server repository and initialize the TypeScript project with required dependencies.",
            "dependencies": [],
            "details": "Create the 'wyre-mcp/itglue-mcp' repository on GitHub. Initialize a TypeScript project with npm. Install required dependencies including MCP SDK and @asachs01/node-it-glue. Set up tsconfig.json, package.json, and basic project structure. Configure linting and formatting tools.",
            "status": "pending",
            "testStrategy": "Verify project structure and successful build with no errors. Ensure all dependencies are correctly installed and accessible."
          },
          {
            "id": 2,
            "title": "Implement organization and configuration tools",
            "description": "Implement the IT Glue API tools for searching and retrieving organizations and configurations.",
            "dependencies": [
              1
            ],
            "details": "Create implementations for itglue_search_organizations (GET /organizations), itglue_get_organization (GET /organizations/{id}), itglue_search_configurations (GET /configurations), and itglue_get_configuration (GET /configurations/{id}). Include parameter validation, response formatting, and error handling according to MCP specifications. Ensure proper API key handling via 'X-API-Key' header.",
            "status": "pending",
            "testStrategy": "Unit tests for each tool implementation. Integration tests with mock IT Glue API responses. Test error handling for various API failure scenarios."
          },
          {
            "id": 3,
            "title": "Implement password and document tools",
            "description": "Implement the IT Glue API tools for searching and retrieving passwords and documents.",
            "dependencies": [
              1
            ],
            "details": "Create implementations for itglue_search_passwords (GET /passwords), itglue_get_password (GET /passwords/{id}), itglue_search_documents (GET /documents), and itglue_search_flexible_assets (GET /flexible_assets). Implement secure handling of sensitive password data. Include parameter validation, response formatting, and error handling according to MCP specifications.",
            "status": "pending",
            "testStrategy": "Unit tests for each tool implementation. Security testing for password handling. Integration tests with mock IT Glue API responses. Test error handling for various API failure scenarios."
          },
          {
            "id": 4,
            "title": "Implement error handling and rate limiting",
            "description": "Add comprehensive error handling and rate limiting to prevent API abuse and improve reliability.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement error handling for all API interactions including network errors, authentication failures, and unexpected responses. Add rate limiting to prevent exceeding IT Glue API limits. Implement retry logic with exponential backoff for transient errors. Create standardized error responses following MCP specifications. Add detailed logging for troubleshooting.",
            "status": "pending",
            "testStrategy": "Unit tests for error handling scenarios. Performance testing to verify rate limiting effectiveness. Integration tests with simulated API failures and rate limit responses."
          },
          {
            "id": 5,
            "title": "Create Dockerfile and finalize implementation",
            "description": "Create Dockerfile for containerization and finalize the implementation with comprehensive logging.",
            "dependencies": [
              4
            ],
            "details": "Create a Dockerfile for containerizing the IT Glue MCP server. Implement comprehensive logging throughout the application using a structured logging format. Add health check endpoints. Finalize documentation including API usage examples, deployment instructions, and configuration options. Prepare the project for production deployment with proper versioning.",
            "status": "pending",
            "testStrategy": "Container build and run tests. End-to-end tests with real API credentials in a secure environment. Verify logging output and format. Test container health checks and restart capabilities."
          }
        ]
      },
      {
        "id": 46,
        "title": "Migrate Autotask MCP Server",
        "description": "Migrate the existing Autotask MCP server to the new organization and adapt it to work with the gateway architecture.",
        "details": "1. Fork/transfer 'asachs01/autotask-mcp' to 'wyre-mcp/autotask-mcp'\n2. Adapt to accept credentials via 'X-API-Key' / 'X-API-Secret' headers from gateway\n3. Update the codebase to match the standardized repository structure\n4. Create or update Dockerfile for containerization\n5. Update CI/CD workflow for ghcr.io/wyre-mcp\n6. Create migration guide for existing local MCP users\n7. Ensure compatibility with the gateway routing system\n8. Add comprehensive logging and error handling",
        "testStrategy": "Unit tests for credential handling changes. Integration tests with gateway. Compatibility tests with existing clients. End-to-end tests with real API credentials. Migration testing to verify smooth transition for existing users.",
        "priority": "medium",
        "dependencies": [
          42,
          43
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Repository Transfer and Initial Setup",
            "description": "Fork or transfer the existing Autotask MCP repository to the new organization and set up the basic project structure.",
            "dependencies": [],
            "details": "1. Transfer 'asachs01/autotask-mcp' to 'wyre-mcp/autotask-mcp' organization\n2. Update package.json with new organization details\n3. Update README.md with new organization information\n4. Set up the repository with standardized structure according to organization guidelines\n5. Configure initial project dependencies",
            "status": "pending",
            "testStrategy": "Verify repository transfer is complete and accessible. Ensure all files are properly transferred and the project structure follows organization standards."
          },
          {
            "id": 2,
            "title": "Implement Gateway Authentication Adaptation",
            "description": "Modify the authentication mechanism to work with the gateway architecture using API key headers.",
            "dependencies": [
              1
            ],
            "details": "1. Update authentication logic to accept 'X-API-Key' and 'X-API-Secret' headers from gateway\n2. Modify credential handling to extract and validate these headers\n3. Implement secure storage and processing of credentials\n4. Add unit tests for the new authentication flow\n5. Ensure backward compatibility with existing authentication methods where necessary",
            "status": "pending",
            "testStrategy": "Unit tests for credential handling. Integration tests with mock gateway. Security testing for proper credential handling and validation."
          },
          {
            "id": 3,
            "title": "Containerization and CI/CD Pipeline Setup",
            "description": "Create or update Dockerfile and implement CI/CD workflow for the containerized application.",
            "dependencies": [
              1
            ],
            "details": "1. Create or update Dockerfile for containerization\n2. Configure multi-stage build for optimized container size\n3. Set up GitHub Actions workflow for automated testing\n4. Configure container publishing to ghcr.io/wyre-mcp\n5. Implement versioning strategy for container images\n6. Add container health checks and monitoring",
            "status": "pending",
            "testStrategy": "Verify container builds successfully. Test container startup and operation. Validate CI/CD pipeline successfully builds and publishes containers."
          },
          {
            "id": 4,
            "title": "Gateway Compatibility and Routing Implementation",
            "description": "Ensure the MCP server is compatible with the gateway routing system and properly handles API requests.",
            "dependencies": [
              2,
              3
            ],
            "details": "1. Implement compatibility with gateway routing system\n2. Update API endpoints to match gateway routing patterns\n3. Add route configuration for the gateway\n4. Implement request/response transformation as needed\n5. Test integration with the gateway\n6. Document routing configuration for deployment",
            "status": "pending",
            "testStrategy": "Integration tests with actual gateway. End-to-end tests with sample requests through the gateway. Performance testing to ensure acceptable response times."
          },
          {
            "id": 5,
            "title": "Logging, Error Handling, and Migration Documentation",
            "description": "Implement comprehensive logging, error handling, and create migration documentation for existing users.",
            "dependencies": [
              4
            ],
            "details": "1. Add structured logging throughout the application\n2. Implement standardized error handling and error responses\n3. Create detailed migration guide for existing MCP users\n4. Document breaking changes and upgrade paths\n5. Provide examples of new authentication method\n6. Create troubleshooting guide for common migration issues\n7. Finalize all documentation",
            "status": "pending",
            "testStrategy": "Review logs for completeness and usefulness. Test error scenarios to ensure proper handling. Have existing users review migration documentation for clarity and completeness."
          }
        ]
      },
      {
        "id": 47,
        "title": "Implement OAuth 2.1 with PKCE Authentication Flow",
        "description": "Implement the OAuth 2.1 with PKCE authentication flow in the MCP Gateway to handle user authentication and credential management.",
        "details": "1. Implement OAuth 2.1 authorization endpoint (/oauth/authorize)\n2. Implement token endpoint (/oauth/token) with PKCE verification\n3. Implement token refresh mechanism\n4. Create credential entry UI for vendors without native OAuth\n5. Implement secure storage for refresh tokens\n6. Add token revocation endpoint (/oauth/revoke)\n7. Implement session management\n8. Add audit logging for all authentication events\n9. Ensure compliance with MCP spec update (June 2025)\n10. Implement proper error handling and user feedback",
        "testStrategy": "Unit tests for PKCE code challenge/verifier. Integration tests for the complete OAuth flow. Security testing for token handling. UI testing for credential entry pages. Compliance testing against MCP specification.",
        "priority": "high",
        "dependencies": [
          43
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement OAuth 2.1 Authorization Endpoint",
            "description": "Create the authorization endpoint (/oauth/authorize) that initiates the OAuth 2.1 flow with PKCE support.",
            "dependencies": [],
            "details": "Implement the authorization endpoint that handles client authentication requests. This includes validating client IDs, generating authorization codes, storing PKCE code challenges, implementing state parameter for CSRF protection, and redirecting users to the appropriate callback URLs. Ensure proper scope validation and user consent flow.",
            "status": "pending",
            "testStrategy": "Unit tests for parameter validation. Integration tests for the complete authorization flow. Security testing for CSRF protection. Compliance testing against OAuth 2.1 specification."
          },
          {
            "id": 2,
            "title": "Implement Token Endpoint with PKCE Verification",
            "description": "Create the token endpoint (/oauth/token) that exchanges authorization codes for access tokens with PKCE verification.",
            "dependencies": [
              1
            ],
            "details": "Implement the token endpoint that validates authorization codes, verifies PKCE code verifiers against stored code challenges, and issues access and refresh tokens. Include JWT generation for access tokens with appropriate claims and signatures. Implement proper error handling for invalid requests and failed verifications.",
            "status": "pending",
            "testStrategy": "Unit tests for PKCE verification logic. Integration tests for token exchange flow. Security testing for token generation. Performance testing for token issuance under load."
          },
          {
            "id": 3,
            "title": "Implement Token Refresh and Revocation Mechanisms",
            "description": "Create endpoints and logic for refreshing access tokens and revoking tokens when needed.",
            "dependencies": [
              2
            ],
            "details": "Implement the refresh token flow that allows clients to obtain new access tokens without user interaction. Create the token revocation endpoint (/oauth/revoke) that invalidates access and refresh tokens. Implement secure storage for refresh tokens using encryption at rest. Add token lifecycle management including expiration handling and rotation policies.",
            "status": "pending",
            "testStrategy": "Unit tests for token validation and refresh logic. Integration tests for the complete refresh flow. Security testing for token storage. Compliance testing against OAuth 2.1 specification for token revocation."
          },
          {
            "id": 4,
            "title": "Create Credential Entry UI for Vendors",
            "description": "Develop a user interface for vendors without native OAuth support to enter and manage their API credentials.",
            "dependencies": [
              3
            ],
            "details": "Design and implement a web-based UI for credential entry and management. Include form validation, secure transmission of credentials, and integration with the secure credential storage system. Implement user feedback for successful/failed operations and provide clear instructions for obtaining API credentials from various vendor platforms.",
            "status": "pending",
            "testStrategy": "UI testing for form validation and user experience. Integration tests with credential storage. Accessibility testing. Cross-browser compatibility testing. Security testing for credential transmission."
          },
          {
            "id": 5,
            "title": "Implement Session Management and Audit Logging",
            "description": "Create session management functionality and comprehensive audit logging for all authentication events.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement session creation, validation, and expiration handling. Create audit logging system that records all authentication events including login attempts, token issuance, token refresh, and revocation. Ensure logs contain necessary information for security analysis while respecting privacy requirements. Implement proper error handling and user feedback for authentication failures.",
            "status": "pending",
            "testStrategy": "Unit tests for session management logic. Integration tests for audit logging. Performance testing for high-volume logging. Compliance testing against security standards for audit trails."
          }
        ]
      },
      {
        "id": 48,
        "title": "Implement Secure Credential Storage",
        "description": "Implement a secure credential storage system for the MCP Gateway to safely store and manage vendor API credentials.",
        "details": "1. Design encrypted credential storage schema\n2. Implement AES-256 encryption for credentials at rest\n3. Create key derivation system (per-user encryption keys derived from master key)\n4. Implement secure credential retrieval mechanism\n5. Add audit logging for all credential access\n6. Implement tenant isolation to prevent cross-user data access\n7. Create credential rotation mechanism\n8. Implement secure deletion for user data removal\n9. Add backup and recovery procedures\n10. Document security practices for compliance purposes",
        "testStrategy": "Security testing for encryption implementation. Penetration testing for credential storage. Unit tests for encryption/decryption operations. Integration tests for credential lifecycle. Compliance testing against security standards.",
        "priority": "high",
        "dependencies": [
          43,
          47
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and implement encrypted credential storage schema",
            "description": "Create a secure database schema for storing encrypted vendor API credentials with proper tenant isolation.",
            "dependencies": [],
            "details": "Design a database schema that supports AES-256 encryption for credentials at rest. Include fields for encrypted credential data, initialization vectors, tenant IDs for isolation, creation/modification timestamps, and credential metadata. Implement the database models and migration scripts.",
            "status": "pending",
            "testStrategy": "Unit tests for schema validation. Security review of database design. Test data isolation between tenants."
          },
          {
            "id": 2,
            "title": "Implement encryption and key derivation system",
            "description": "Create a secure encryption service with AES-256 and a key derivation system for per-user encryption keys.",
            "dependencies": [
              1
            ],
            "details": "Implement an encryption service that uses AES-256 for credential encryption. Create a key derivation function that generates per-user encryption keys from a master key. Ensure secure key storage and management. Implement functions for encrypting and decrypting credential data with proper IV handling.",
            "status": "pending",
            "testStrategy": "Unit tests for encryption/decryption operations. Security testing of key derivation implementation. Penetration testing for encryption vulnerabilities."
          },
          {
            "id": 3,
            "title": "Develop secure credential retrieval and management API",
            "description": "Create API endpoints for securely storing, retrieving, and managing vendor credentials with proper authentication.",
            "dependencies": [
              2
            ],
            "details": "Implement RESTful API endpoints for credential CRUD operations. Ensure all endpoints require proper authentication and authorization. Implement tenant isolation to prevent cross-user data access. Add input validation and sanitization for all API inputs. Create credential rotation mechanism for periodic updates.",
            "status": "pending",
            "testStrategy": "Integration tests for API endpoints. Security testing for authentication and authorization. Load testing for API performance."
          },
          {
            "id": 4,
            "title": "Implement comprehensive audit logging system",
            "description": "Add detailed audit logging for all credential access and management operations for security compliance.",
            "dependencies": [
              3
            ],
            "details": "Create an audit logging service that records all credential access, modifications, and administrative actions. Log user ID, timestamp, action type, affected credential IDs (without sensitive data), and source IP. Ensure logs are tamper-resistant and stored securely. Implement log rotation and retention policies.",
            "status": "pending",
            "testStrategy": "Unit tests for logging functionality. Verification of log completeness for all credential operations. Compliance testing against security standards."
          },
          {
            "id": 5,
            "title": "Implement backup, recovery, and secure deletion procedures",
            "description": "Create mechanisms for secure credential backup, recovery, and complete deletion when required.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement secure backup procedures for encrypted credentials with proper access controls. Create recovery mechanisms for restoring credentials from backups. Implement secure deletion functionality that ensures complete removal of user data when requested, including from backups. Document all security practices for compliance purposes.",
            "status": "pending",
            "testStrategy": "Integration tests for backup and recovery processes. Verification of secure deletion implementation. Documentation review for compliance requirements."
          }
        ]
      },
      {
        "id": "49",
        "title": "Deploy MCP Gateway to Azure Container Apps",
        "description": "Deploy the MCP Gateway to Azure Container Apps using the existing Terraform configuration from the MCP Gateway Registry.",
        "status": "pending",
        "dependencies": [
          43,
          47,
          48
        ],
        "priority": "medium",
        "details": "1. Set up Azure account and configure credentials\n2. Review and customize the existing Terraform/Bicep configuration\n3. Configure domain and SSL certificates for mcp.wyre.ai\n4. Set up Azure Container Apps environment\n5. Configure load balancer and auto-scaling\n6. Set up Azure Database for PostgreSQL for session storage\n7. Configure Azure Cache for Redis for caching and rate limiting\n8. Implement monitoring and alerting\n9. Set up CI/CD pipeline for automated deployment\n10. Document deployment process and infrastructure",
        "testStrategy": "Infrastructure testing with Terraform/Bicep validation. Load testing for auto-scaling. Failover testing for high availability. Security testing for Azure configuration. End-to-end testing of deployed gateway.",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Azure infrastructure with Terraform/Bicep",
            "description": "Configure Azure account credentials and initialize the Terraform/Bicep environment using the existing configuration from MCP Gateway Registry.",
            "dependencies": [],
            "details": "Set up Azure CLI with proper credentials, clone the Terraform/Bicep configuration from MCP Gateway Registry, initialize Terraform workspace or Bicep modules, and customize variables for our deployment. Ensure Azure permissions are properly configured for Container Apps deployment.",
            "status": "pending",
            "testStrategy": "Validate Terraform configuration using 'terraform validate' and 'terraform plan' or Bicep using 'az deployment what-if' to ensure no errors before deployment."
          },
          {
            "id": 2,
            "title": "Configure networking and security components",
            "description": "Set up Virtual Network, subnets, network security groups, and configure domain with SSL certificates for mcp.wyre.ai.",
            "dependencies": [
              1
            ],
            "details": "Create or update Virtual Network configuration, configure subnets, set up network security groups with proper inbound/outbound rules, register domain in Azure DNS, request SSL certificate through Azure App Service certificates or import existing certificates, and validate domain ownership for the certificate.",
            "status": "pending",
            "testStrategy": "Verify DNS resolution, SSL certificate validity, and network security group configurations through Azure portal and CLI tools."
          },
          {
            "id": 3,
            "title": "Deploy Azure Container Apps with load balancing",
            "description": "Create Azure Container Apps environment, container app definitions, and configure load balancing with auto-scaling capabilities.",
            "dependencies": [
              2
            ],
            "details": "Define Container Apps based on MCP Gateway container requirements, create Container Apps environment with desired replicas, configure Application Gateway or Azure Front Door for load balancing, set up auto-scaling policies based on CPU/memory utilization, and ensure proper health checks are in place.",
            "status": "pending",
            "testStrategy": "Test load balancer functionality, verify auto-scaling triggers under load, and confirm container health checks are functioning correctly."
          },
          {
            "id": 4,
            "title": "Set up supporting services (Azure Database for PostgreSQL and Azure Cache for Redis)",
            "description": "Deploy and configure Azure Database for PostgreSQL for session storage and Azure Cache for Redis for caching and rate limiting.",
            "dependencies": [
              2
            ],
            "details": "Create Azure Database for PostgreSQL instance, configure firewall rules for database access, set up Azure Cache for Redis, configure backup policies, implement encryption at rest, and integrate connection strings with MCP Gateway configuration.",
            "status": "pending",
            "testStrategy": "Verify database connectivity from Container Apps, test Redis caching functionality, and validate data persistence across container restarts."
          },
          {
            "id": 5,
            "title": "Implement CI/CD pipeline and monitoring",
            "description": "Set up CI/CD pipeline for automated deployment and configure monitoring and alerting for the infrastructure.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create GitHub Actions or Azure DevOps pipeline workflow for automated builds and deployments to Azure Container Registry and Container Apps, configure Azure Monitor for logs and metrics collection, set up alerts for critical metrics, implement Application Insights for distributed tracing, and document the entire deployment process and infrastructure for future reference.",
            "status": "pending",
            "testStrategy": "Verify CI/CD pipeline by making test commits, validate monitoring dashboards show appropriate metrics, and test alerting by triggering threshold violations."
          }
        ]
      },
      {
        "id": 50,
        "title": "Implement HaloPSA MCP Server with Native OAuth",
        "description": "Create the HaloPSA MCP server repository and implement native OAuth passthrough to leverage HaloPSA's built-in OAuth support.",
        "details": "1. Create repo: 'wyre-mcp/halopsa-mcp'\n2. Initialize TypeScript project with MCP SDK and @asachs01/node-halopsa\n3. Implement native OAuth passthrough to HaloPSA's OAuth system\n4. Configure OAuth client registration with HaloPSA\n5. Implement token refresh handling\n6. Create tools for HaloPSA API interaction\n7. Create Dockerfile for containerization\n8. Implement error handling and logging\n9. Add gateway route configuration for /v1/halopsa/*\n10. Document OAuth configuration requirements",
        "testStrategy": "Unit tests for OAuth implementation. Integration tests with HaloPSA OAuth sandbox. End-to-end tests with real OAuth credentials. Security testing for token handling. Performance testing for response times.",
        "priority": "medium",
        "dependencies": [
          42,
          43,
          47
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create HaloPSA MCP repository and initialize TypeScript project",
            "description": "Set up the repository structure and initialize the TypeScript project with required dependencies.",
            "dependencies": [],
            "details": "Create the 'wyre-mcp/halopsa-mcp' repository. Initialize a TypeScript project with proper configuration. Install MCP SDK and @asachs01/node-halopsa packages. Set up the project structure following MCP standards. Configure ESLint and Prettier for code quality. Set up Jest for testing.",
            "status": "pending",
            "testStrategy": "Verify project structure and dependencies. Run basic smoke tests to ensure the project builds correctly."
          },
          {
            "id": 2,
            "title": "Implement HaloPSA OAuth passthrough and client registration",
            "description": "Create the OAuth passthrough implementation to leverage HaloPSA's built-in OAuth system and configure client registration.",
            "dependencies": [
              1
            ],
            "details": "Implement OAuth authorization endpoints that pass through to HaloPSA's OAuth system. Create configuration for OAuth client registration with HaloPSA. Implement secure storage for client credentials. Create documentation for the OAuth configuration requirements. Implement proper error handling for OAuth failures.",
            "status": "pending",
            "testStrategy": "Unit tests for OAuth implementation. Integration tests with HaloPSA OAuth sandbox. Security testing for proper credential handling."
          },
          {
            "id": 3,
            "title": "Implement token refresh handling and API interaction tools",
            "description": "Create token refresh mechanism and build tools for interacting with the HaloPSA API.",
            "dependencies": [
              2
            ],
            "details": "Implement automatic token refresh when tokens expire. Create error handling for failed refreshes. Build a set of utility functions for common HaloPSA API interactions. Implement proper logging for API calls and responses. Create abstraction layer for API interactions to simplify tool development.",
            "status": "pending",
            "testStrategy": "Unit tests for token refresh logic. Integration tests with mock API responses. Performance testing for API interaction tools."
          },
          {
            "id": 4,
            "title": "Create Dockerfile and containerization setup",
            "description": "Implement containerization for the HaloPSA MCP server with proper configuration.",
            "dependencies": [
              1
            ],
            "details": "Create a Dockerfile for containerizing the HaloPSA MCP server. Implement multi-stage builds for optimized container size. Configure environment variables for runtime configuration. Set up health checks and proper signal handling. Create docker-compose configuration for local development. Document container deployment requirements.",
            "status": "pending",
            "testStrategy": "Build and run container tests. Verify proper environment variable handling. Test container startup and shutdown procedures."
          },
          {
            "id": 5,
            "title": "Configure gateway routes and finalize documentation",
            "description": "Add gateway route configuration and complete comprehensive documentation for the HaloPSA MCP server.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Configure gateway routes for /v1/halopsa/* endpoints. Implement proper error handling and logging for all routes. Create comprehensive documentation including setup instructions, OAuth configuration, API usage examples, and troubleshooting guides. Add API endpoint documentation with request/response examples. Create deployment guides for various environments.",
            "status": "pending",
            "testStrategy": "End-to-end testing with gateway integration. Documentation review and validation. User acceptance testing with documentation."
          }
        ]
      },
      {
        "id": 51,
        "title": "Implement Additional Vendor MCP Servers",
        "description": "Create MCP servers for additional vendors: Syncro, Atera, SuperOps, ConnectWise PSA, and ConnectWise Automate.",
        "details": "1. Create repositories for each vendor:\n   - wyre-mcp/syncro-mcp\n   - wyre-mcp/atera-mcp\n   - wyre-mcp/superops-mcp\n   - wyre-mcp/connectwise-psa-mcp\n   - wyre-mcp/connectwise-automate-mcp\n2. Initialize TypeScript projects with MCP SDK and respective node libraries\n3. Implement credential handling for each vendor's authentication method\n4. Create tools for each vendor's API interaction\n5. Create Dockerfiles for containerization\n6. Implement error handling and logging\n7. Add gateway route configurations for each vendor\n8. Create credential entry UI for each vendor\n9. Document API capabilities and limitations\n10. Implement rate limiting and error handling specific to each vendor",
        "testStrategy": "Unit tests for each vendor implementation. Integration tests with mock APIs. End-to-end tests with real credentials (in secure CI environment). Performance testing for response times. Security testing for credential handling.",
        "priority": "low",
        "dependencies": [
          42,
          43,
          47,
          48
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create and initialize vendor MCP repositories",
            "description": "Set up the repository structure for all five vendors and initialize TypeScript projects with MCP SDK.",
            "dependencies": [],
            "details": "Create GitHub repositories for Syncro, Atera, SuperOps, ConnectWise PSA, and ConnectWise Automate. Initialize each with TypeScript, install MCP SDK and respective vendor API libraries. Set up project structure with standard folders (src, tests, config). Configure tsconfig.json, package.json, and basic CI/CD pipeline.",
            "status": "pending",
            "testStrategy": "Verify repository structure and successful build of each project. Test dependency installation and project initialization scripts."
          },
          {
            "id": 2,
            "title": "Implement vendor-specific authentication and credential handling",
            "description": "Create authentication modules for each vendor's specific authentication requirements and integrate with secure credential storage.",
            "dependencies": [
              1
            ],
            "details": "Implement authentication modules for each vendor: OAuth for Syncro and SuperOps, API key for Atera, and complex authentication for ConnectWise products. Integrate with the secure credential storage system from Task 48. Create credential validation and refresh mechanisms. Implement proper error handling for authentication failures.",
            "status": "pending",
            "testStrategy": "Unit tests for authentication modules. Integration tests with mock credentials. Security testing for proper credential handling and storage."
          },
          {
            "id": 3,
            "title": "Develop vendor-specific API interaction tools",
            "description": "Create the core API interaction tools for each vendor, implementing the required MCP functionality.",
            "dependencies": [
              2
            ],
            "details": "Implement API interaction tools for each vendor, focusing on device/asset management, alert handling, and site/customer management. Create standardized interfaces that conform to MCP specifications. Implement rate limiting, pagination handling, and error recovery. Ensure proper logging of API interactions while protecting sensitive data.",
            "status": "pending",
            "testStrategy": "Unit tests for each API tool. Integration tests with mock API responses. End-to-end tests with sandbox environments where available."
          },
          {
            "id": 4,
            "title": "Create containerization and deployment configurations",
            "description": "Develop Dockerfiles and deployment configurations for each vendor MCP server.",
            "dependencies": [
              3
            ],
            "details": "Create Dockerfiles for each vendor MCP server with proper base images, security considerations, and optimization. Implement multi-stage builds to minimize image size. Configure environment variables for runtime configuration. Create docker-compose files for local development. Add gateway route configurations for each vendor in the MCP Gateway.",
            "status": "pending",
            "testStrategy": "Test Docker builds and container startup. Verify proper configuration loading. Test gateway routing and connection to each vendor MCP server."
          },
          {
            "id": 5,
            "title": "Implement documentation and testing",
            "description": "Create comprehensive documentation and implement testing strategies for each vendor MCP server.",
            "dependencies": [
              4
            ],
            "details": "Document API capabilities and limitations for each vendor. Create usage examples and troubleshooting guides. Implement comprehensive test suites including unit tests, integration tests, and end-to-end tests. Create performance benchmarks and security validation tests. Document known issues and vendor-specific quirks or limitations.",
            "status": "pending",
            "testStrategy": "Review documentation for completeness and accuracy. Verify test coverage meets project standards. Perform security and performance testing against actual vendor APIs in controlled environments."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2026-02-05T14:29:59.590Z",
      "updated": "2026-02-05T14:36:58.052Z",
      "description": "Tasks for master context"
    }
  },
  "node-it-glue": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up project structure and core configuration",
        "description": "Initialize the project with the required directory structure, package.json, TypeScript configuration, and build tools.",
        "details": "1. Initialize a new Node.js project with `npm init -y`\n2. Install TypeScript and required dependencies:\n```bash\nnpm install typescript tsup vitest @types/node --save-dev\nnpm install undici --save\n```\n3. Create the directory structure as specified in the PRD:\n```\nnode-it-glue/\n src/\n    index.ts\n    client.ts\n    config.ts\n    errors.ts\n    http.ts\n    pagination.ts\n    rate-limiter.ts\n    jsonapi.ts\n    types/\n    resources/\n tests/\n    setup.ts\n    fixtures/\n    mocks/\n    unit/\n    integration/\n```\n4. Configure TypeScript in `tsconfig.json`:\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"outDir\": \"./dist\",\n    \"declaration\": true,\n    \"skipLibCheck\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n5. Set up tsup for building in `package.json`:\n```json\n{\n  \"scripts\": {\n    \"build\": \"tsup src/index.ts --format esm,cjs --dts\",\n    \"test\": \"vitest run\"\n  }\n}\n```\n6. Create a basic README.md with project description",
        "testStrategy": "1. Verify the project structure is correctly set up\n2. Ensure TypeScript compilation works with `npm run build`\n3. Confirm the package.json has the correct dependencies and scripts\n4. Validate the tsconfig.json settings are appropriate for the project requirements",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-05T00:04:52.540Z"
      },
      {
        "id": 2,
        "title": "Implement error handling classes",
        "description": "Create custom error classes for handling different types of API errors as specified in the PRD.",
        "details": "Create `src/errors.ts` with the following error classes:\n\n```typescript\nexport class ITGlueError extends Error {\n  statusCode: number;\n  response: any;\n\n  constructor(message: string, statusCode: number, response?: any) {\n    super(message);\n    this.name = this.constructor.name;\n    this.statusCode = statusCode;\n    this.response = response;\n    // Ensure instanceof works correctly in TypeScript\n    Object.setPrototypeOf(this, ITGlueError.prototype);\n  }\n}\n\nexport class ITGlueAuthenticationError extends ITGlueError {\n  constructor(message: string, statusCode: number, response?: any) {\n    super(message, statusCode, response);\n    Object.setPrototypeOf(this, ITGlueAuthenticationError.prototype);\n  }\n}\n\nexport class ITGlueNotFoundError extends ITGlueError {\n  constructor(message: string, response?: any) {\n    super(message, 404, response);\n    Object.setPrototypeOf(this, ITGlueNotFoundError.prototype);\n  }\n}\n\nexport class ITGlueValidationError extends ITGlueError {\n  errors: Array<{ title: string; detail: string; source?: any }>;\n\n  constructor(message: string, errors: Array<{ title: string; detail: string; source?: any }>, response?: any) {\n    super(message, 422, response);\n    this.errors = errors;\n    Object.setPrototypeOf(this, ITGlueValidationError.prototype);\n  }\n}\n\nexport class ITGlueRateLimitError extends ITGlueError {\n  constructor(message: string, response?: any) {\n    super(message, 429, response);\n    Object.setPrototypeOf(this, ITGlueRateLimitError.prototype);\n  }\n}\n\nexport class ITGlueServerError extends ITGlueError {\n  constructor(message: string, statusCode: number, response?: any) {\n    super(message, statusCode, response);\n    Object.setPrototypeOf(this, ITGlueServerError.prototype);\n  }\n}\n```\n\nExport all error classes from `src/index.ts` to make them available to library consumers.",
        "testStrategy": "Create unit tests in `tests/unit/errors.test.ts` that:\n1. Verify each error class can be instantiated with the correct properties\n2. Test that instanceof checks work correctly for error hierarchy\n3. Ensure error messages and status codes are properly set\n4. Validate that the ITGlueValidationError correctly stores the errors array",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-05T00:05:04.802Z"
      },
      {
        "id": 3,
        "title": "Create HTTP client wrapper",
        "description": "Implement the HTTP layer that handles requests to the IT Glue API, including headers, request formatting, and response handling.",
        "details": "Create `src/http.ts` with a wrapper around the fetch API (using undici):\n\n```typescript\nimport { fetch } from 'undici';\nimport { ITGlueAuthenticationError, ITGlueNotFoundError, ITGlueRateLimitError, ITGlueServerError, ITGlueValidationError } from './errors';\n\nexport interface HttpClientConfig {\n  baseUrl: string;\n  apiKey: string;\n  timeout?: number;\n}\n\nexport class HttpClient {\n  private baseUrl: string;\n  private apiKey: string;\n  private timeout: number;\n\n  constructor(config: HttpClientConfig) {\n    this.baseUrl = config.baseUrl;\n    this.apiKey = config.apiKey;\n    this.timeout = config.timeout || 30000; // 30 seconds default\n  }\n\n  private getHeaders(): Record<string, string> {\n    return {\n      'x-api-key': this.apiKey,\n      'Content-Type': 'application/vnd.api+json',\n      'Accept': 'application/vnd.api+json'\n    };\n  }\n\n  private async handleResponse(response: Response) {\n    const contentType = response.headers.get('content-type');\n    const isJson = contentType && contentType.includes('application/vnd.api+json');\n    const data = isJson ? await response.json() : await response.text();\n\n    if (!response.ok) {\n      switch (response.status) {\n        case 401:\n        case 403:\n          throw new ITGlueAuthenticationError(\n            `Authentication failed: ${response.status} ${response.statusText}`,\n            response.status,\n            data\n          );\n        case 404:\n          throw new ITGlueNotFoundError(\n            `Resource not found: ${response.url}`,\n            data\n          );\n        case 422:\n          throw new ITGlueValidationError(\n            'Validation failed',\n            isJson && data.errors ? data.errors : [],\n            data\n          );\n        case 429:\n          throw new ITGlueRateLimitError(\n            'Rate limit exceeded',\n            data\n          );\n        default:\n          throw new ITGlueServerError(\n            `Server error: ${response.status} ${response.statusText}`,\n            response.status,\n            data\n          );\n      }\n    }\n\n    return data;\n  }\n\n  async request<T>(method: string, path: string, options: { body?: any; params?: Record<string, any> } = {}): Promise<T> {\n    const url = new URL(path, this.baseUrl);\n    \n    // Add query parameters\n    if (options.params) {\n      Object.entries(options.params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n\n    const fetchOptions: RequestInit = {\n      method,\n      headers: this.getHeaders(),\n      signal: AbortSignal.timeout(this.timeout)\n    };\n\n    if (options.body) {\n      fetchOptions.body = JSON.stringify(options.body);\n    }\n\n    const response = await fetch(url.toString(), fetchOptions);\n    return this.handleResponse(response) as Promise<T>;\n  }\n\n  async get<T>(path: string, params?: Record<string, any>): Promise<T> {\n    return this.request<T>('GET', path, { params });\n  }\n\n  async post<T>(path: string, body?: any, params?: Record<string, any>): Promise<T> {\n    return this.request<T>('POST', path, { body, params });\n  }\n\n  async patch<T>(path: string, body?: any, params?: Record<string, any>): Promise<T> {\n    return this.request<T>('PATCH', path, { body, params });\n  }\n\n  async delete<T>(path: string, params?: Record<string, any>): Promise<T> {\n    return this.request<T>('DELETE', path, { params });\n  }\n}\n```",
        "testStrategy": "Create unit tests in `tests/unit/http.test.ts` that:\n1. Test successful GET, POST, PATCH, and DELETE requests\n2. Verify correct headers are sent with each request\n3. Test error handling for each error type (401, 403, 404, 422, 429, 500)\n4. Validate query parameter handling\n5. Test timeout behavior\n\nUse MSW or nock to mock HTTP responses for each test case.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-05T00:05:06.612Z"
      },
      {
        "id": 4,
        "title": "Implement JSON:API serialization/deserialization",
        "description": "Create utilities to transform between JSON:API format and flat TypeScript objects as specified in the PRD.",
        "details": "Create `src/jsonapi.ts` with functions to handle JSON:API format:\n\n```typescript\nexport interface JsonApiResource {\n  id?: string;\n  type: string;\n  attributes?: Record<string, any>;\n  relationships?: Record<string, { data: JsonApiResourceIdentifier | JsonApiResourceIdentifier[] }>;\n}\n\nexport interface JsonApiResourceIdentifier {\n  id: string;\n  type: string;\n}\n\nexport interface JsonApiResponse {\n  data: JsonApiResource | JsonApiResource[];\n  included?: JsonApiResource[];\n  meta?: Record<string, any>;\n}\n\n// Convert kebab-case to camelCase\nexport function toCamelCase(str: string): string {\n  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());\n}\n\n// Convert camelCase to kebab-case\nexport function toKebabCase(str: string): string {\n  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n\n// Transform keys in an object from kebab-case to camelCase\nexport function transformKeys(obj: Record<string, any>): Record<string, any> {\n  if (!obj || typeof obj !== 'object') return obj;\n  \n  if (Array.isArray(obj)) {\n    return obj.map(item => transformKeys(item));\n  }\n  \n  const result: Record<string, any> = {};\n  \n  for (const [key, value] of Object.entries(obj)) {\n    const camelKey = toCamelCase(key);\n    result[camelKey] = transformKeys(value);\n  }\n  \n  return result;\n}\n\n// Deserialize JSON:API response to flat objects\nexport function deserialize(response: JsonApiResponse): any {\n  if (!response) return null;\n  \n  const result: Record<string, any> = {};\n  \n  // Handle meta information\n  if (response.meta) {\n    result.meta = transformKeys(response.meta);\n  }\n  \n  // Handle data\n  if (response.data) {\n    const processResource = (resource: JsonApiResource) => {\n      const flatResource: Record<string, any> = {\n        id: resource.id,\n        type: resource.type\n      };\n      \n      // Flatten attributes\n      if (resource.attributes) {\n        Object.assign(flatResource, transformKeys(resource.attributes));\n      }\n      \n      // Process relationships\n      if (resource.relationships) {\n        flatResource.relationships = {};\n        \n        for (const [key, relationship] of Object.entries(resource.relationships)) {\n          const camelKey = toCamelCase(key);\n          flatResource.relationships[camelKey] = relationship.data;\n        }\n      }\n      \n      return flatResource;\n    };\n    \n    if (Array.isArray(response.data)) {\n      result.data = response.data.map(processResource);\n    } else {\n      result.data = processResource(response.data);\n    }\n  }\n  \n  // Handle included resources\n  if (response.included) {\n    result.included = response.included.map(resource => {\n      const flatResource: Record<string, any> = {\n        id: resource.id,\n        type: resource.type\n      };\n      \n      if (resource.attributes) {\n        Object.assign(flatResource, transformKeys(resource.attributes));\n      }\n      \n      return flatResource;\n    });\n  }\n  \n  return result;\n}\n\n// Serialize flat objects to JSON:API format\nexport function serialize(type: string, data: Record<string, any>): JsonApiResponse {\n  const { id, relationships, ...attributes } = data;\n  const resource: JsonApiResource = { type };\n  \n  if (id) resource.id = id;\n  \n  // Convert attributes to kebab-case\n  const kebabAttributes: Record<string, any> = {};\n  for (const [key, value] of Object.entries(attributes)) {\n    if (value !== undefined && value !== null) {\n      kebabAttributes[toKebabCase(key)] = value;\n    }\n  }\n  \n  if (Object.keys(kebabAttributes).length > 0) {\n    resource.attributes = kebabAttributes;\n  }\n  \n  // Handle relationships\n  if (relationships && Object.keys(relationships).length > 0) {\n    resource.relationships = {};\n    \n    for (const [key, value] of Object.entries(relationships)) {\n      const kebabKey = toKebabCase(key);\n      resource.relationships[kebabKey] = { data: value };\n    }\n  }\n  \n  return { data: resource };\n}\n```",
        "testStrategy": "Create unit tests in `tests/unit/jsonapi.test.ts` that:\n1. Test toCamelCase and toKebabCase functions with various inputs\n2. Test transformKeys with nested objects and arrays\n3. Test deserialize with single resources and collections\n4. Test deserialize with included resources\n5. Test serialize with various attribute types\n6. Test handling of relationships during serialization and deserialization\n7. Verify that the transformation correctly handles the examples from the PRD",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-05T00:05:08.435Z"
      },
      {
        "id": 5,
        "title": "Implement rate limiting and throttling",
        "description": "Create a rate limiter that enforces IT Glue's 3000 requests per 5-minute sliding window with preemptive throttling and retry logic.",
        "details": "Create `src/rate-limiter.ts` with the following implementation:\n\n```typescript\nexport interface RateLimitConfig {\n  enabled: boolean;\n  maxRequests: number;\n  windowMs: number;\n  throttleThreshold: number;\n  retryAfterMs: number;\n  maxRetries: number;\n}\n\nexport const DEFAULT_RATE_LIMIT_CONFIG: RateLimitConfig = {\n  enabled: true,\n  maxRequests: 3000,\n  windowMs: 300000, // 5 minutes\n  throttleThreshold: 0.8, // 80%\n  retryAfterMs: 5000, // 5 seconds\n  maxRetries: 3\n};\n\nexport class RateLimiter {\n  private config: RateLimitConfig;\n  private requestTimestamps: number[] = [];\n  \n  constructor(config: Partial<RateLimitConfig> = {}) {\n    this.config = { ...DEFAULT_RATE_LIMIT_CONFIG, ...config };\n  }\n  \n  private cleanupOldRequests(): void {\n    const now = Date.now();\n    const windowStart = now - this.config.windowMs;\n    this.requestTimestamps = this.requestTimestamps.filter(timestamp => timestamp >= windowStart);\n  }\n  \n  private getCurrentUsage(): number {\n    this.cleanupOldRequests();\n    return this.requestTimestamps.length;\n  }\n  \n  private getThrottleDelay(): number {\n    if (!this.config.enabled) return 0;\n    \n    const currentUsage = this.getCurrentUsage();\n    const usageRatio = currentUsage / this.config.maxRequests;\n    \n    if (usageRatio >= this.config.throttleThreshold) {\n      // Calculate a delay that increases as we approach the limit\n      const severityFactor = (usageRatio - this.config.throttleThreshold) / (1 - this.config.throttleThreshold);\n      return Math.min(this.config.retryAfterMs * severityFactor, this.config.retryAfterMs);\n    }\n    \n    return 0;\n  }\n  \n  async acquireToken(): Promise<void> {\n    if (!this.config.enabled) return;\n    \n    const delay = this.getThrottleDelay();\n    if (delay > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    \n    this.requestTimestamps.push(Date.now());\n  }\n  \n  async executeWithRetry<T>(fn: () => Promise<T>): Promise<T> {\n    if (!this.config.enabled) return fn();\n    \n    let retries = 0;\n    \n    while (true) {\n      try {\n        await this.acquireToken();\n        return await fn();\n      } catch (error: any) {\n        if (error?.statusCode === 429 && retries < this.config.maxRetries) {\n          retries++;\n          const delay = this.config.retryAfterMs * Math.pow(2, retries - 1); // Exponential backoff\n          await new Promise(resolve => setTimeout(resolve, delay));\n        } else {\n          throw error;\n        }\n      }\n    }\n  }\n  \n  getRemainingRequests(): number {\n    return this.config.maxRequests - this.getCurrentUsage();\n  }\n  \n  getConfig(): RateLimitConfig {\n    return { ...this.config };\n  }\n  \n  updateConfig(config: Partial<RateLimitConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n}\n```",
        "testStrategy": "Create unit tests in `tests/unit/rate-limiter.test.ts` that:\n1. Test that requests are tracked correctly within the time window\n2. Verify that old requests are cleaned up after the window expires\n3. Test the throttling behavior when approaching the threshold\n4. Test the retry logic with exponential backoff\n5. Verify that the rate limiter can be disabled via configuration\n6. Test the getRemainingRequests method\n7. Test updateConfig method",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-05T00:05:10.177Z"
      },
      {
        "id": 6,
        "title": "Implement pagination utilities",
        "description": "Create pagination utilities that handle IT Glue's page-based pagination, including async iterators for automatic multi-page traversal.",
        "details": "Create `src/pagination.ts` with the following implementation:\n\n```typescript\nexport interface PaginationParams {\n  page?: {\n    size?: number;\n    number?: number;\n  };\n}\n\nexport interface PaginationMeta {\n  currentPage: number;\n  nextPage: number | null;\n  prevPage: number | null;\n  totalPages: number;\n  totalCount: number;\n}\n\nexport interface PaginatedResponse<T> {\n  data: T[];\n  meta: PaginationMeta;\n}\n\nexport class PaginationIterator<T, P extends PaginationParams> {\n  private fetchPage: (params: P) => Promise<PaginatedResponse<T>>;\n  private params: P;\n  private currentPage: number;\n  private hasMorePages: boolean = true;\n  private buffer: T[] = [];\n  private bufferIndex: number = 0;\n  \n  constructor(fetchPage: (params: P) => Promise<PaginatedResponse<T>>, params: P) {\n    this.fetchPage = fetchPage;\n    this.params = { ...params };\n    this.currentPage = params.page?.number || 1;\n    \n    // Ensure page params exist\n    if (!this.params.page) this.params.page = {};\n  }\n  \n  private async fetchNextPage(): Promise<void> {\n    if (!this.hasMorePages) return;\n    \n    // Update page number in params\n    this.params.page!.number = this.currentPage;\n    \n    const response = await this.fetchPage(this.params);\n    \n    // Add items to buffer\n    this.buffer = response.data;\n    this.bufferIndex = 0;\n    \n    // Check if there are more pages\n    this.hasMorePages = response.meta.nextPage !== null;\n    if (this.hasMorePages) {\n      this.currentPage = response.meta.nextPage!;\n    }\n  }\n  \n  async next(): Promise<IteratorResult<T>> {\n    // If buffer is empty or we've consumed all items, fetch next page\n    if (this.buffer.length === 0 || this.bufferIndex >= this.buffer.length) {\n      if (!this.hasMorePages) {\n        return { done: true, value: undefined };\n      }\n      \n      await this.fetchNextPage();\n      \n      // If buffer is still empty after fetch, we're done\n      if (this.buffer.length === 0) {\n        return { done: true, value: undefined };\n      }\n    }\n    \n    // Return next item from buffer\n    return { done: false, value: this.buffer[this.bufferIndex++] };\n  }\n  \n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n  \n  async toArray(): Promise<T[]> {\n    const result: T[] = [];\n    for await (const item of this) {\n      result.push(item);\n    }\n    return result;\n  }\n}\n```",
        "testStrategy": "Create unit tests in `tests/unit/pagination.test.ts` that:\n1. Test the async iterator protocol implementation\n2. Verify that pages are fetched correctly as the iterator progresses\n3. Test behavior when there are no more pages\n4. Test the toArray method\n5. Test with empty result sets\n6. Test with single page results\n7. Test with multiple pages",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-05T00:05:11.960Z"
      },
      {
        "id": 7,
        "title": "Create client configuration and initialization",
        "description": "Implement the main ITGlueClient class with configuration options and resource initialization.",
        "details": "Create `src/config.ts` with configuration types:\n\n```typescript\nimport { RateLimitConfig, DEFAULT_RATE_LIMIT_CONFIG } from './rate-limiter';\n\nexport type Region = 'us' | 'eu' | 'au';\n\nexport interface ITGlueClientConfig {\n  apiKey: string;\n  region?: Region;\n  baseUrl?: string;\n  timeout?: number;\n  rateLimiter?: Partial<RateLimitConfig>;\n}\n\nexport const REGION_BASE_URLS: Record<Region, string> = {\n  us: 'https://api.itglue.com',\n  eu: 'https://api.eu.itglue.com',\n  au: 'https://api.au.itglue.com'\n};\n\nexport function getBaseUrl(config: ITGlueClientConfig): string {\n  if (config.baseUrl) return config.baseUrl;\n  if (!config.region) return REGION_BASE_URLS.us;\n  return REGION_BASE_URLS[config.region];\n}\n```\n\nCreate `src/client.ts` with the main client class:\n\n```typescript\nimport { HttpClient } from './http';\nimport { RateLimiter } from './rate-limiter';\nimport { ITGlueClientConfig, getBaseUrl } from './config';\n\n// Import resource classes (to be implemented)\nimport { OrganizationsResource } from './resources/organizations';\n// Import other resources as needed\n\nexport class ITGlueClient {\n  private http: HttpClient;\n  private rateLimiter: RateLimiter;\n  \n  // Resource instances\n  readonly organizations: OrganizationsResource;\n  // Add other resources as they are implemented\n  \n  constructor(config: ITGlueClientConfig) {\n    if (!config.apiKey) {\n      throw new Error('API key is required');\n    }\n    \n    const baseUrl = getBaseUrl(config);\n    \n    this.http = new HttpClient({\n      baseUrl,\n      apiKey: config.apiKey,\n      timeout: config.timeout\n    });\n    \n    this.rateLimiter = new RateLimiter(config.rateLimiter);\n    \n    // Initialize resources\n    this.organizations = new OrganizationsResource(this.http, this.rateLimiter);\n    // Initialize other resources as they are implemented\n  }\n  \n  getRateLimiter(): RateLimiter {\n    return this.rateLimiter;\n  }\n}\n```",
        "testStrategy": "Create unit tests in `tests/unit/client.test.ts` that:\n1. Test client initialization with different configuration options\n2. Verify error is thrown when API key is missing\n3. Test region to baseUrl mapping\n4. Verify resources are properly initialized\n5. Test getRateLimiter method",
        "priority": "high",
        "dependencies": [
          "3",
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-05T00:05:13.699Z"
      },
      {
        "id": 8,
        "title": "Implement core resource types",
        "description": "Create TypeScript type definitions for the core IT Glue resources (organizations, configurations, contacts, etc.).",
        "details": "Create type definitions in the `src/types/` directory:\n\n1. First, create `src/types/common.ts` with shared types:\n\n```typescript\nexport interface FilterParams {\n  [key: string]: any;\n}\n\nexport interface SortParams {\n  sort?: string;\n}\n\nexport interface IncludeParams {\n  include?: string;\n}\n\nexport interface PaginationParams {\n  page?: {\n    size?: number;\n    number?: number;\n  };\n}\n\nexport interface ResourceParams extends FilterParams, SortParams, IncludeParams, PaginationParams {}\n\nexport interface Timestamps {\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface ResourceIdentifier {\n  id: string;\n  type: string;\n}\n\nexport interface ResourceRelationships {\n  [key: string]: ResourceIdentifier | ResourceIdentifier[];\n}\n```\n\n2. Create `src/types/organizations.ts`:\n\n```typescript\nimport { Timestamps, ResourceRelationships } from './common';\n\nexport interface Organization extends Timestamps {\n  id: string;\n  type: 'organizations';\n  name: string;\n  description?: string;\n  shortName?: string;\n  organizationTypeId?: number;\n  organizationStatusId?: number;\n  accountNumber?: string;\n  alertsEnabled?: boolean;\n  primaryEmail?: string;\n  primaryPhone?: string;\n  billingEmail?: string;\n  billingPhone?: string;\n  fax?: string;\n  website?: string;\n  taxNumber?: string;\n  industry?: string;\n  securePassword?: string;\n  notes?: string;\n  relationships?: ResourceRelationships;\n}\n\nexport interface OrganizationType extends Timestamps {\n  id: string;\n  type: 'organization-types';\n  name: string;\n  description?: string;\n}\n\nexport interface OrganizationStatus extends Timestamps {\n  id: string;\n  type: 'organization-statuses';\n  name: string;\n  description?: string;\n}\n\nexport interface CreateOrganizationData {\n  name: string;\n  description?: string;\n  shortName?: string;\n  organizationTypeId?: number;\n  organizationStatusId?: number;\n  accountNumber?: string;\n  alertsEnabled?: boolean;\n  primaryEmail?: string;\n  primaryPhone?: string;\n  billingEmail?: string;\n  billingPhone?: string;\n  fax?: string;\n  website?: string;\n  taxNumber?: string;\n  industry?: string;\n  securePassword?: string;\n  notes?: string;\n}\n\nexport interface UpdateOrganizationData extends Partial<CreateOrganizationData> {}\n```\n\n3. Create `src/types/configurations.ts`:\n\n```typescript\nimport { Timestamps, ResourceRelationships } from './common';\n\nexport interface Configuration extends Timestamps {\n  id: string;\n  type: 'configurations';\n  name: string;\n  configurationTypeId: number;\n  configurationStatusId?: number;\n  organizationId: number;\n  locationId?: number;\n  contactId?: number;\n  serialNumber?: string;\n  assetTag?: string;\n  hostname?: string;\n  primaryIp?: string;\n  macAddress?: string;\n  manufacturer?: string;\n  model?: string;\n  operatingSystem?: string;\n  warrantyExpirationDate?: string;\n  installationDate?: string;\n  purchaseDate?: string;\n  purchaseCost?: number;\n  notes?: string;\n  relationships?: ResourceRelationships;\n}\n\nexport interface ConfigurationType extends Timestamps {\n  id: string;\n  type: 'configuration-types';\n  name: string;\n  icon?: string;\n  showInMenu?: boolean;\n  position?: number;\n}\n\nexport interface ConfigurationStatus extends Timestamps {\n  id: string;\n  type: 'configuration-statuses';\n  name: string;\n  description?: string;\n}\n\nexport interface ConfigurationInterface extends Timestamps {\n  id: string;\n  type: 'configuration-interfaces';\n  configurationId: number;\n  name?: string;\n  ipAddress?: string;\n  macAddress?: string;\n  primary?: boolean;\n  notes?: string;\n}\n\nexport interface CreateConfigurationData {\n  name: string;\n  configurationTypeId: number;\n  configurationStatusId?: number;\n  organizationId: number;\n  locationId?: number;\n  contactId?: number;\n  serialNumber?: string;\n  assetTag?: string;\n  hostname?: string;\n  primaryIp?: string;\n  macAddress?: string;\n  manufacturer?: string;\n  model?: string;\n  operatingSystem?: string;\n  warrantyExpirationDate?: string;\n  installationDate?: string;\n  purchaseDate?: string;\n  purchaseCost?: number;\n  notes?: string;\n}\n\nexport interface UpdateConfigurationData extends Partial<CreateConfigurationData> {}\n```\n\n4. Create additional type files for other resources following the same pattern.\n\n5. Create `src/types/index.ts` to re-export all types:\n\n```typescript\nexport * from './common';\nexport * from './organizations';\nexport * from './configurations';\n// Export other type modules as they are created\n```",
        "testStrategy": "These are type definitions, so direct testing is not applicable. However, we should:\n1. Verify that the types compile correctly\n2. Ensure the types are comprehensive and match the IT Glue API documentation\n3. Validate that the types are properly exported from the index file\n4. Use these types in resource implementation tests to verify they work as expected",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-05T00:05:15.461Z"
      },
      {
        "id": 9,
        "title": "Implement organizations resource",
        "description": "Create the organizations resource with CRUD operations, serving as a reference implementation for other resources.",
        "details": "Create `src/resources/organizations.ts` with the following implementation:\n\n```typescript\nimport { HttpClient } from '../http';\nimport { RateLimiter } from '../rate-limiter';\nimport { PaginationIterator, PaginatedResponse } from '../pagination';\nimport { deserialize, serialize } from '../jsonapi';\nimport { Organization, CreateOrganizationData, UpdateOrganizationData } from '../types/organizations';\nimport { ResourceParams } from '../types/common';\n\nexport class OrganizationsResource {\n  private http: HttpClient;\n  private rateLimiter: RateLimiter;\n  private readonly basePath = '/organizations';\n  \n  constructor(http: HttpClient, rateLimiter: RateLimiter) {\n    this.http = http;\n    this.rateLimiter = rateLimiter;\n  }\n  \n  async list(params: ResourceParams = {}): Promise<PaginatedResponse<Organization>> {\n    return this.rateLimiter.executeWithRetry(async () => {\n      const response = await this.http.get(this.basePath, this.formatParams(params));\n      return deserialize(response);\n    });\n  }\n  \n  listAll(params: ResourceParams = {}): PaginationIterator<Organization, ResourceParams> {\n    return new PaginationIterator<Organization, ResourceParams>(\n      (p) => this.list(p),\n      params\n    );\n  }\n  \n  async get(id: string | number, params: ResourceParams = {}): Promise<{ data: Organization }> {\n    return this.rateLimiter.executeWithRetry(async () => {\n      const response = await this.http.get(`${this.basePath}/${id}`, this.formatParams(params));\n      return deserialize(response);\n    });\n  }\n  \n  async create(data: CreateOrganizationData): Promise<{ data: Organization }> {\n    return this.rateLimiter.executeWithRetry(async () => {\n      const payload = serialize('organizations', data);\n      const response = await this.http.post(this.basePath, payload);\n      return deserialize(response);\n    });\n  }\n  \n  async update(id: string | number, data: UpdateOrganizationData): Promise<{ data: Organization }> {\n    return this.rateLimiter.executeWithRetry(async () => {\n      const payload = serialize('organizations', data);\n      const response = await this.http.patch(`${this.basePath}/${id}`, payload);\n      return deserialize(response);\n    });\n  }\n  \n  async delete(id: string | number): Promise<void> {\n    return this.rateLimiter.executeWithRetry(async () => {\n      await this.http.delete(`${this.basePath}/${id}`);\n    });\n  }\n  \n  private formatParams(params: ResourceParams): Record<string, any> {\n    const result: Record<string, any> = {};\n    \n    // Handle filter parameters\n    if (params.filter) {\n      for (const [key, value] of Object.entries(params.filter)) {\n        if (value === undefined || value === null) continue;\n        \n        if (typeof value === 'object' && !Array.isArray(value)) {\n          // Handle operators like gt, lt, etc.\n          for (const [op, opValue] of Object.entries(value)) {\n            result[`filter[${key}][${op}]`] = opValue;\n          }\n        } else if (Array.isArray(value)) {\n          // Handle arrays (comma-separated values)\n          result[`filter[${key}]`] = value.join(',');\n        } else {\n          // Handle simple values\n          result[`filter[${key}]`] = value;\n        }\n      }\n    }\n    \n    // Handle pagination\n    if (params.page) {\n      if (params.page.size !== undefined) {\n        result['page[size]'] = params.page.size;\n      }\n      if (params.page.number !== undefined) {\n        result['page[number]'] = params.page.number;\n      }\n    }\n    \n    // Handle sorting\n    if (params.sort) {\n      result.sort = params.sort;\n    }\n    \n    // Handle includes\n    if (params.include) {\n      result.include = params.include;\n    }\n    \n    return result;\n  }\n}\n```\n\nAlso create `src/resources/organization-types.ts` and `src/resources/organization-statuses.ts` following a similar pattern.",
        "testStrategy": "Create integration tests in `tests/integration/organizations.test.ts` that:\n1. Test list, get, create, update, and delete operations\n2. Verify pagination works correctly with listAll\n3. Test filter parameter formatting\n4. Test sort parameter handling\n5. Test include parameter for related resources\n6. Verify error handling for various scenarios\n\nUse MSW or nock to mock the HTTP responses with realistic fixtures.",
        "priority": "medium",
        "dependencies": [
          "3",
          "4",
          "5",
          "6",
          "7",
          "8"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-05T00:05:17.229Z"
      },
      {
        "id": 10,
        "title": "Set up test infrastructure with mock server",
        "description": "Create the test infrastructure including mock server setup, fixtures, and test utilities.",
        "details": "1. Install test dependencies:\n```bash\nnpm install msw vitest --save-dev\n```\n\n2. Create `tests/setup.ts` for global test setup:\n\n```typescript\nimport { afterAll, afterEach, beforeAll } from 'vitest';\nimport { setupServer } from 'msw/node';\nimport { handlers } from './mocks/handlers';\n\n// Setup MSW server\nexport const server = setupServer(...handlers);\n\n// Start server before all tests\nbeforeAll(() => server.listen({ onUnhandledRequest: 'error' }));\n\n// Reset handlers after each test\nafterEach(() => server.resetHandlers());\n\n// Close server after all tests\nafterAll(() => server.close());\n```\n\n3. Create `tests/mocks/handlers.ts` with mock API handlers:\n\n```typescript\nimport { http, HttpResponse } from 'msw';\nimport organizationsFixture from '../fixtures/organizations/list.json';\nimport organizationFixture from '../fixtures/organizations/get-single.json';\nimport createdOrganizationFixture from '../fixtures/organizations/created.json';\nimport updatedOrganizationFixture from '../fixtures/organizations/updated.json';\nimport notFoundFixture from '../fixtures/errors/not-found.json';\nimport validationErrorFixture from '../fixtures/errors/validation.json';\n\nexport const handlers = [\n  // Organizations endpoints\n  http.get('https://api.itglue.com/organizations', ({ request }) => {\n    const url = new URL(request.url);\n    const page = url.searchParams.get('page[number]') || '1';\n    const pageSize = url.searchParams.get('page[size]') || '50';\n    \n    // Return different responses based on page number for pagination testing\n    if (page === '1') {\n      return HttpResponse.json(organizationsFixture);\n    }\n    \n    // Empty result for last page\n    return HttpResponse.json({\n      data: [],\n      meta: {\n        'current-page': parseInt(page),\n        'next-page': null,\n        'prev-page': parseInt(page) - 1,\n        'total-pages': parseInt(page),\n        'total-count': organizationsFixture.data.length\n      }\n    });\n  }),\n  \n  http.get('https://api.itglue.com/organizations/:id', ({ params }) => {\n    const { id } = params;\n    \n    if (id === '404') {\n      return HttpResponse.json(notFoundFixture, { status: 404 });\n    }\n    \n    // Clone the fixture and set the correct ID\n    const response = JSON.parse(JSON.stringify(organizationFixture));\n    response.data.id = id;\n    return HttpResponse.json(response);\n  }),\n  \n  http.post('https://api.itglue.com/organizations', async ({ request }) => {\n    const body = await request.json();\n    \n    // Validation error test case\n    if (!body.data.attributes.name) {\n      return HttpResponse.json(validationErrorFixture, { status: 422 });\n    }\n    \n    return HttpResponse.json(createdOrganizationFixture, { status: 201 });\n  }),\n  \n  http.patch('https://api.itglue.com/organizations/:id', ({ params }) => {\n    const { id } = params;\n    const response = JSON.parse(JSON.stringify(updatedOrganizationFixture));\n    response.data.id = id;\n    return HttpResponse.json(response);\n  }),\n  \n  http.delete('https://api.itglue.com/organizations/:id', () => {\n    return new HttpResponse(null, { status: 204 });\n  }),\n  \n  // Rate limit test endpoint\n  http.get('https://api.itglue.com/rate-limited', () => {\n    return new HttpResponse(null, { status: 429 });\n  }),\n  \n  // Authentication error test endpoint\n  http.get('https://api.itglue.com/auth-error', () => {\n    return new HttpResponse(null, { status: 401 });\n  }),\n  \n  // Server error test endpoint\n  http.get('https://api.itglue.com/server-error', () => {\n    return new HttpResponse(null, { status: 500 });\n  })\n];\n```\n\n4. Create fixture files in `tests/fixtures/` directory:\n\n- `tests/fixtures/organizations/list.json`\n- `tests/fixtures/organizations/get-single.json`\n- `tests/fixtures/organizations/created.json`\n- `tests/fixtures/organizations/updated.json`\n- `tests/fixtures/errors/not-found.json`\n- `tests/fixtures/errors/validation.json`\n\nEach fixture should contain realistic JSON:API formatted responses.\n\n5. Create `vitest.config.ts`:\n\n```typescript\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    setupFiles: ['./tests/setup.ts'],\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html'],\n      exclude: ['**/node_modules/**', '**/tests/**']\n    }\n  }\n});\n```",
        "testStrategy": "This task is about setting up the test infrastructure itself, so the testing strategy is to:\n1. Verify that the MSW server starts and stops correctly\n2. Ensure fixtures are loaded properly\n3. Test that the mock handlers respond with the expected data\n4. Confirm that the test setup is properly integrated with Vitest\n5. Run a simple test to validate the entire setup",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-05T00:05:19.026Z"
      },
      {
        "id": 11,
        "title": "Implement remaining resource classes",
        "description": "Create resource classes for all remaining IT Glue API endpoints following the pattern established by the organizations resource.",
        "details": "Implement the remaining resource classes in the `src/resources/` directory following the pattern established by the organizations resource. Each resource should:\n\n1. Have a dedicated class with CRUD operations as appropriate\n2. Use the rate limiter for all API calls\n3. Handle serialization and deserialization of JSON:API data\n4. Support pagination, filtering, sorting, and includes\n5. Follow consistent naming conventions\n\nFor example, implement `src/resources/configurations.ts`:\n\n```typescript\nimport { HttpClient } from '../http';\nimport { RateLimiter } from '../rate-limiter';\nimport { PaginationIterator, PaginatedResponse } from '../pagination';\nimport { deserialize, serialize } from '../jsonapi';\nimport { Configuration, CreateConfigurationData, UpdateConfigurationData } from '../types/configurations';\nimport { ResourceParams } from '../types/common';\n\nexport class ConfigurationsResource {\n  private http: HttpClient;\n  private rateLimiter: RateLimiter;\n  private readonly basePath = '/configurations';\n  \n  constructor(http: HttpClient, rateLimiter: RateLimiter) {\n    this.http = http;\n    this.rateLimiter = rateLimiter;\n  }\n  \n  async list(params: ResourceParams = {}): Promise<PaginatedResponse<Configuration>> {\n    return this.rateLimiter.executeWithRetry(async () => {\n      const response = await this.http.get(this.basePath, this.formatParams(params));\n      return deserialize(response);\n    });\n  }\n  \n  async listByOrg(orgId: string | number, params: ResourceParams = {}): Promise<PaginatedResponse<Configuration>> {\n    return this.rateLimiter.executeWithRetry(async () => {\n      const path = `/organizations/${orgId}/relationships/configurations`;\n      const response = await this.http.get(path, this.formatParams(params));\n      return deserialize(response);\n    });\n  }\n  \n  listAll(params: ResourceParams = {}): PaginationIterator<Configuration, ResourceParams> {\n    return new PaginationIterator<Configuration, ResourceParams>(\n      (p) => this.list(p),\n      params\n    );\n  }\n  \n  listAllByOrg(orgId: string | number, params: ResourceParams = {}): PaginationIterator<Configuration, ResourceParams> {\n    return new PaginationIterator<Configuration, ResourceParams>(\n      (p) => this.listByOrg(orgId, p),\n      params\n    );\n  }\n  \n  async get(id: string | number, params: ResourceParams = {}): Promise<{ data: Configuration }> {\n    return this.rateLimiter.executeWithRetry(async () => {\n      const response = await this.http.get(`${this.basePath}/${id}`, this.formatParams(params));\n      return deserialize(response);\n    });\n  }\n  \n  async create(data: CreateConfigurationData): Promise<{ data: Configuration }> {\n    return this.rateLimiter.executeWithRetry(async () => {\n      const payload = serialize('configurations', data);\n      const response = await this.http.post(this.basePath, payload);\n      return deserialize(response);\n    });\n  }\n  \n  async update(id: string | number, data: UpdateConfigurationData): Promise<{ data: Configuration }> {\n    return this.rateLimiter.executeWithRetry(async () => {\n      const payload = serialize('configurations', data);\n      const response = await this.http.patch(`${this.basePath}/${id}`, payload);\n      return deserialize(response);\n    });\n  }\n  \n  async delete(id: string | number): Promise<void> {\n    return this.rateLimiter.executeWithRetry(async () => {\n      await this.http.delete(`${this.basePath}/${id}`);\n    });\n  }\n  \n  private formatParams(params: ResourceParams): Record<string, any> {\n    const result: Record<string, any> = {};\n    \n    // Handle filter parameters\n    if (params.filter) {\n      for (const [key, value] of Object.entries(params.filter)) {\n        if (value === undefined || value === null) continue;\n        \n        if (typeof value === 'object' && !Array.isArray(value)) {\n          // Handle operators like gt, lt, etc.\n          for (const [op, opValue] of Object.entries(value)) {\n            result[`filter[${key}][${op}]`] = opValue;\n          }\n        } else if (Array.isArray(value)) {\n          // Handle arrays (comma-separated values)\n          result[`filter[${key}]`] = value.join(',');\n        } else {\n          // Handle simple values\n          result[`filter[${key}]`] = value;\n        }\n      }\n    }\n    \n    // Handle pagination\n    if (params.page) {\n      if (params.page.size !== undefined) {\n        result['page[size]'] = params.page.size;\n      }\n      if (params.page.number !== undefined) {\n        result['page[number]'] = params.page.number;\n      }\n    }\n    \n    // Handle sorting\n    if (params.sort) {\n      result.sort = params.sort;\n    }\n    \n    // Handle includes\n    if (params.include) {\n      result.include = params.include;\n    }\n    \n    return result;\n  }\n}\n```\n\nImplement similar classes for all other resources listed in the PRD's endpoint inventory, including:\n- Contacts and Contact Types\n- Passwords, Password Categories, and Password Folders\n- Documents, Document Sections, and Document Images\n- Flexible Assets, Flexible Asset Types, and Flexible Asset Fields\n- Locations\n- Users and User Metrics\n- Manufacturers and Models\n- And all other resources listed in the PRD\n\nUpdate the client class to initialize all these resources.",
        "testStrategy": "For each resource class:\n1. Create integration tests that verify CRUD operations\n2. Test relationship endpoints (e.g., listByOrg)\n3. Test pagination with listAll methods\n4. Test filter, sort, and include parameters\n5. Verify error handling\n\nCreate appropriate fixtures for each resource type in the tests/fixtures directory.",
        "priority": "medium",
        "dependencies": [
          "9",
          "10"
        ],
        "status": "in-progress",
        "subtasks": [],
        "updatedAt": "2026-02-05T00:05:32.654Z"
      },
      {
        "id": 12,
        "title": "Create comprehensive documentation and examples",
        "description": "Create detailed documentation including README, usage examples, and API reference.",
        "details": "1. Create a comprehensive README.md with:\n   - Project overview and purpose\n   - Installation instructions\n   - Basic usage examples\n   - Configuration options\n   - Rate limiting explanation\n   - Pagination usage\n   - Filtering examples\n   - Error handling\n   - Link to full API reference\n\n2. Create a CHANGELOG.md file with initial version information\n\n3. Add JSDoc comments to all public methods and classes\n\n4. Create usage examples for common scenarios:\n   - Authentication and client setup\n   - Working with organizations\n   - Managing configurations\n   - Handling documents\n   - Working with passwords\n   - Using flexible assets\n   - Pagination examples\n   - Error handling examples\n\n5. Document all available filter options for each resource\n\nExample README.md structure:\n\n```markdown\n# node-it-glue\n\nA comprehensive, fully-typed Node.js/TypeScript library providing complete coverage of the IT Glue API.\n\n## Features\n\n- Complete API coverage  Every documented IT Glue endpoint is implemented\n- Strong TypeScript types  Full type definitions for all request/response payloads\n- JSON:API abstraction  Unwrap the JSON:API envelope so consumers work with clean objects\n- Automatic pagination  Iterator/generator patterns for seamless multi-page retrieval\n- Rate limit handling  Built-in request throttling (3000 req / 5 min) with backoff\n- Zero live API testing  Full test suite with mocked HTTP responses\n\n## Installation\n\n```bash\nnpm install node-it-glue\n```\n\n## Quick Start\n\n```typescript\nimport { ITGlueClient } from 'node-it-glue';\n\nconst client = new ITGlueClient({\n  apiKey: 'ITG.xxxxxxxxxxxxxxxxxxxxxxxx',\n  region: 'us',\n});\n\n// List organizations\nconst orgs = await client.organizations.list({\n  filter: { organizationStatusId: 1 },\n  page: { size: 50 },\n});\n\n// Auto-paginate all configurations for an org\nfor await (const config of client.configurations.listAll({\n  filter: { organizationId: 12345 },\n})) {\n  console.log(config.name, config.serialNumber);\n}\n```\n\n## Configuration\n\n```typescript\nconst client = new ITGlueClient({\n  apiKey: 'ITG.xxxxxxxxxxxxxxxxxxxxxxxx', // Required\n  region: 'us',                           // 'us' | 'eu' | 'au'\n  // OR explicit base URL:\n  // baseUrl: 'https://api.itglue.com',\n  timeout: 30000,                         // Request timeout in ms\n  rateLimiter: {                          // Rate limiting options\n    enabled: true,\n    maxRequests: 3000,\n    windowMs: 300000,                     // 5 minutes\n    throttleThreshold: 0.8,               // 80%\n    retryAfterMs: 5000,\n    maxRetries: 3\n  }\n});\n```\n\n## Pagination\n\nAll list methods return paginated results. You can manually paginate:\n\n```typescript\nconst page1 = await client.organizations.list({ page: { size: 50, number: 1 } });\nconst page2 = await client.organizations.list({ page: { size: 50, number: 2 } });\n```\n\nOr use automatic pagination with async iterators:\n\n```typescript\n// Iterate through all items\nfor await (const org of client.organizations.listAll()) {\n  console.log(org.name);\n}\n\n// Collect all into an array\nconst allOrgs = await client.organizations.listAll().toArray();\n```\n\n## Filtering\n\n```typescript\nconst orgs = await client.organizations.list({\n  filter: {\n    name: 'Acme',\n    organizationTypeId: 42,\n    organizationStatusId: 1,\n    excludeId: [100, 200],\n    createdAt: { gt: '2024-01-01' },\n    updatedAt: { lt: '2025-01-01' },\n  },\n  sort: 'name',          // or '-name' for descending\n  page: { size: 100, number: 1 },\n  include: 'locations',  // sideload related resources\n});\n```\n\n## Error Handling\n\n```typescript\nimport { ITGlueClient, ITGlueNotFoundError, ITGlueValidationError } from 'node-it-glue';\n\ntry {\n  await client.organizations.get('12345');\n} catch (error) {\n  if (error instanceof ITGlueNotFoundError) {\n    console.error('Organization not found');\n  } else if (error instanceof ITGlueValidationError) {\n    console.error('Validation errors:', error.errors);\n  } else {\n    console.error('Unexpected error:', error);\n  }\n}\n```\n\n## API Reference\n\nSee the [full API reference](./API.md) for detailed documentation of all available methods and types.\n```",
        "testStrategy": "This is documentation, so formal testing is not applicable. However, we should:\n1. Verify all code examples compile and work correctly\n2. Ensure documentation is comprehensive and covers all features\n3. Check for typos and formatting issues\n4. Validate that the API reference accurately reflects the implemented functionality",
        "priority": "low",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-05T00:05:32.655Z",
      "taskCount": 12,
      "completedCount": 10,
      "tags": [
        "node-it-glue"
      ],
      "created": "2026-02-05T03:53:10.433Z",
      "description": "Tasks for node-it-glue context"
    }
  },
  "node-datto-rmm": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up project structure and core configuration",
        "description": "Create the initial project structure, package.json, tsconfig.json, and core configuration files according to the PRD specifications.",
        "details": "1. Initialize a new TypeScript project with `npm init -y`\n2. Install required dependencies:\n   ```bash\n   npm install --save-dev typescript tsup vitest msw @types/node\n   ```\n3. Create the following directory structure:\n   ```\n   node-datto-rmm/\n    src/\n       index.ts\n       client.ts\n       config.ts\n       errors.ts\n       http.ts\n       auth.ts\n       pagination.ts\n       rate-limiter.ts\n       types/\n       resources/\n    tests/\n       setup.ts\n       fixtures/\n       mocks/\n       unit/\n       integration/\n    package.json\n    tsconfig.json\n    vitest.config.ts\n    README.md\n    CHANGELOG.md\n    LICENSE\n   ```\n4. Configure `tsconfig.json` with strict mode enabled:\n   ```json\n   {\n     \"compilerOptions\": {\n       \"target\": \"ES2020\",\n       \"module\": \"ESNext\",\n       \"moduleResolution\": \"node\",\n       \"esModuleInterop\": true,\n       \"strict\": true,\n       \"declaration\": true,\n       \"outDir\": \"./dist\",\n       \"rootDir\": \"./src\",\n       \"lib\": [\"ES2020\"],\n       \"types\": [\"node\", \"vitest/globals\"]\n     },\n     \"include\": [\"src/**/*\"],\n     \"exclude\": [\"node_modules\", \"dist\"]\n   }\n   ```\n5. Configure `vitest.config.ts`:\n   ```typescript\n   import { defineConfig } from 'vitest/config';\n\n   export default defineConfig({\n     test: {\n       globals: true,\n       environment: 'node',\n       setupFiles: ['./tests/setup.ts'],\n       coverage: {\n         reporter: ['text', 'json', 'html'],\n         exclude: ['**/node_modules/**', '**/dist/**', '**/tests/**']\n       }\n     }\n   });\n   ```\n6. Configure `package.json` with scripts and metadata:\n   ```json\n   {\n     \"name\": \"node-datto-rmm\",\n     \"version\": \"1.0.0\",\n     \"description\": \"Node.js/TypeScript client for the Datto RMM API v2\",\n     \"type\": \"module\",\n     \"main\": \"./dist/index.js\",\n     \"module\": \"./dist/index.js\",\n     \"types\": \"./dist/index.d.ts\",\n     \"exports\": {\n       \"import\": \"./dist/index.js\",\n       \"require\": \"./dist/index.cjs\"\n     },\n     \"scripts\": {\n       \"build\": \"tsup\",\n       \"test\": \"vitest run\",\n       \"test:watch\": \"vitest\",\n       \"test:coverage\": \"vitest run --coverage\"\n     },\n     \"engines\": {\n       \"node\": \">=18.0.0\"\n     },\n     \"repository\": {\n       \"type\": \"git\",\n       \"url\": \"git+https://github.com/kaseya/datto-rmm/node-datto-rmm.git\"\n     },\n     \"keywords\": [\"datto\", \"rmm\", \"api\", \"client\", \"kaseya\", \"msp\"],\n     \"author\": \"Kaseya\",\n     \"license\": \"MIT\"\n   }\n   ```\n7. Configure `tsup.config.ts` for building both ESM and CJS:\n   ```typescript\n   import { defineConfig } from 'tsup';\n\n   export default defineConfig({\n     entry: ['src/index.ts'],\n     format: ['esm', 'cjs'],\n     dts: true,\n     splitting: false,\n     sourcemap: true,\n     clean: true,\n   });\n   ```",
        "testStrategy": "1. Verify project structure is created correctly\n2. Ensure all configuration files are valid\n3. Run `npm run build` to verify the build process works\n4. Run `npm test` to verify the test setup works\n5. Check that TypeScript compilation succeeds with no errors",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement core types and error handling",
        "description": "Create the type definitions and error classes required for the library, including configuration types, error classes, and common types.",
        "details": "1. Create `src/types/common.ts` with shared types:\n   ```typescript\n   export interface PageDetails {\n     count: number;\n     page: number;\n     prevPageUrl: string | null;\n     nextPageUrl: string | null;\n   }\n\n   export interface PaginatedResponse<T> {\n     pageDetails: PageDetails;\n     [key: string]: any; // The actual data will be under a property like 'devices', 'sites', etc.\n   }\n\n   export type TimestampFormat = 'date' | 'number' | 'iso';\n\n   export interface DattoRmmPlatform {\n     name: string;\n     apiUrl: string;\n   }\n   ```\n\n2. Create `src/config.ts` with configuration types:\n   ```typescript\n   import { TimestampFormat } from './types/common';\n\n   export interface DattoRmmClientConfig {\n     apiKey: string;\n     apiSecretKey: string;\n     platform?: 'pinotage' | 'merlot' | 'concord' | 'vidal' | 'zinfandel' | 'syrah';\n     apiUrl?: string; // Alternative to platform\n     timestamps?: TimestampFormat;\n     rateLimiter?: RateLimitConfig;\n   }\n\n   export interface RateLimitConfig {\n     enabled: boolean;\n     maxRequests: number;\n     windowMs: number;\n     throttleThreshold: number;\n     retryAfterMs: number;\n     maxRetries: number;\n     ipBlockCooldownMs: number;\n   }\n\n   export const DEFAULT_RATE_LIMIT_CONFIG: RateLimitConfig = {\n     enabled: true,\n     maxRequests: 600,\n     windowMs: 60000, // 60 seconds\n     throttleThreshold: 0.8, // 80% = 480 requests\n     retryAfterMs: 5000,\n     maxRetries: 3,\n     ipBlockCooldownMs: 300000, // 5 minutes\n   };\n\n   export const PLATFORM_URLS: Record<string, string> = {\n     pinotage: 'https://pinotage-api.centrastage.net',\n     merlot: 'https://merlot-api.centrastage.net',\n     concord: 'https://concord-api.centrastage.net',\n     vidal: 'https://vidal-api.centrastage.net',\n     zinfandel: 'https://zinfandel-api.centrastage.net',\n     syrah: 'https://syrah-api.centrastage.net',\n   };\n   ```\n\n3. Create `src/errors.ts` with custom error classes:\n   ```typescript\n   export class DattoRmmError extends Error {\n     statusCode: number;\n     response: any;\n\n     constructor(message: string, statusCode: number, response?: any) {\n       super(message);\n       this.name = 'DattoRmmError';\n       this.statusCode = statusCode;\n       this.response = response;\n     }\n   }\n\n   export class DattoRmmAuthenticationError extends DattoRmmError {\n     constructor(message: string, statusCode: number, response?: any) {\n       super(message, statusCode, response);\n       this.name = 'DattoRmmAuthenticationError';\n     }\n   }\n\n   export class DattoRmmNotFoundError extends DattoRmmError {\n     constructor(message: string, response?: any) {\n       super(message, 404, response);\n       this.name = 'DattoRmmNotFoundError';\n     }\n   }\n\n   export class DattoRmmRateLimitError extends DattoRmmError {\n     constructor(message: string, response?: any) {\n       super(message, 429, response);\n       this.name = 'DattoRmmRateLimitError';\n     }\n   }\n\n   export class DattoRmmIpBlockedError extends DattoRmmError {\n     constructor(message: string, response?: any) {\n       super(message, 403, response);\n       this.name = 'DattoRmmIpBlockedError';\n     }\n   }\n\n   export class DattoRmmForbiddenError extends DattoRmmError {\n     constructor(message: string, response?: any) {\n       super(message, 403, response);\n       this.name = 'DattoRmmForbiddenError';\n     }\n   }\n\n   export class DattoRmmServerError extends DattoRmmError {\n     constructor(message: string, statusCode: number, response?: any) {\n       super(message, statusCode, response);\n       this.name = 'DattoRmmServerError';\n     }\n   }\n   ```\n\n4. Create alert context type definitions in `src/types/alert-contexts.ts`:\n   ```typescript\n   export interface BaseAlertContext {\n     '@class': string;\n   }\n\n   export interface EventLogAlertContext extends BaseAlertContext {\n     '@class': 'eventlog_ctx';\n     eventLogSource: string;\n     eventLogId: number;\n     eventLogType: string;\n     eventLogMessage: string;\n   }\n\n   export interface DiskUsageAlertContext extends BaseAlertContext {\n     '@class': 'perf_disk_usage_ctx';\n     drive: string;\n     threshold: number;\n     usagePercent: number;\n     freeSpaceBytes: number;\n   }\n\n   // Add all other alert context types following the same pattern\n   export interface AntivirusAlertContext extends BaseAlertContext {\n     '@class': 'antivirus_ctx';\n     // Add specific properties\n   }\n\n   // ... add all 25+ alert context types\n\n   export type AlertContext =\n     | AntivirusAlertContext\n     | ComponentScriptAlertContext\n     | CustomSnmpAlertContext\n     | DiskHealthAlertContext\n     | EventLogAlertContext\n     | FanAlertContext\n     | FsObjectAlertContext\n     | OnlineOfflineAlertContext\n     | PatchAlertContext\n     | DiskUsageAlertContext\n     | PerfMonAlertContext\n     | ResourceUsageAlertContext\n     | PingAlertContext\n     | ProcessResourceAlertContext\n     | ProcessStatusAlertContext\n     | PsuAlertContext\n     | RansomwareAlertContext\n     | SecurityManagementAlertContext\n     | ServiceResourceAlertContext\n     | ServiceStatusAlertContext\n     | SoftwareActionAlertContext\n     | TemperatureAlertContext\n     | WmiAlertContext;\n   ```\n\n5. Create type index file `src/types/index.ts`:\n   ```typescript\n   export * from './common';\n   export * from './alert-contexts';\n   // Export other type modules as they're created\n   ```",
        "testStrategy": "1. Verify all types compile without errors\n2. Create unit tests for error classes to ensure they properly extend Error\n3. Test error instances have the correct properties\n4. Verify alert context type discriminated unions work correctly\n5. Test platform URL mapping with different platform values",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement OAuth 2.0 token management",
        "description": "Create the authentication module to handle OAuth 2.0 token acquisition, caching, and refresh for the Datto RMM API.",
        "details": "1. Create `src/auth.ts` with token management:\n   ```typescript\n   import { DattoRmmAuthenticationError } from './errors';\n\n   interface TokenInfo {\n     accessToken: string;\n     tokenType: string;\n     expiresAt: number; // Unix timestamp in milliseconds\n   }\n\n   interface TokenResponse {\n     access_token: string;\n     token_type: string;\n     expires_in: number; // Seconds until expiry\n   }\n\n   export class TokenManager {\n     private apiKey: string;\n     private apiSecretKey: string;\n     private apiUrl: string;\n     private tokenInfo: TokenInfo | null = null;\n     private tokenRefreshPromise: Promise<TokenInfo> | null = null;\n     private tokenRefreshThresholdMs = 5 * 60 * 1000; // 5 minutes\n\n     constructor(apiKey: string, apiSecretKey: string, apiUrl: string) {\n       this.apiKey = apiKey;\n       this.apiSecretKey = apiSecretKey;\n       this.apiUrl = apiUrl;\n     }\n\n     async getToken(): Promise<string> {\n       // If we have a valid token that's not near expiry, return it\n       if (this.tokenInfo && Date.now() < this.tokenInfo.expiresAt - this.tokenRefreshThresholdMs) {\n         return this.tokenInfo.accessToken;\n       }\n\n       // If a token refresh is already in progress, wait for it\n       if (this.tokenRefreshPromise) {\n         const tokenInfo = await this.tokenRefreshPromise;\n         return tokenInfo.accessToken;\n       }\n\n       // Otherwise, start a new token refresh\n       this.tokenRefreshPromise = this.refreshToken();\n       try {\n         const tokenInfo = await this.tokenRefreshPromise;\n         return tokenInfo.accessToken;\n       } finally {\n         this.tokenRefreshPromise = null;\n       }\n     }\n\n     private async refreshToken(): Promise<TokenInfo> {\n       const tokenUrl = `${this.apiUrl}/auth/oauth/token`;\n       const basicAuth = Buffer.from('public-client:public').toString('base64');\n       \n       const formData = new URLSearchParams();\n       formData.append('grant_type', 'password');\n       formData.append('username', this.apiKey);\n       formData.append('password', this.apiSecretKey);\n\n       const response = await fetch(tokenUrl, {\n         method: 'POST',\n         headers: {\n           'Authorization': `Basic ${basicAuth}`,\n           'Content-Type': 'application/x-www-form-urlencoded',\n         },\n         body: formData.toString(),\n       });\n\n       if (!response.ok) {\n         const errorData = await response.json().catch(() => ({}));\n         throw new DattoRmmAuthenticationError(\n           `Failed to acquire token: ${response.status} ${response.statusText}`,\n           response.status,\n           errorData\n         );\n       }\n\n       const data = await response.json() as TokenResponse;\n       \n       this.tokenInfo = {\n         accessToken: data.access_token,\n         tokenType: data.token_type,\n         expiresAt: Date.now() + (data.expires_in * 1000),\n       };\n\n       return this.tokenInfo;\n     }\n\n     invalidateToken(): void {\n       this.tokenInfo = null;\n     }\n   }\n   ```\n\n2. Create test fixtures for token responses in `tests/fixtures/auth/`:\n   - `token-success.json`:\n     ```json\n     {\n       \"access_token\": \"mock-jwt-token\",\n       \"token_type\": \"bearer\",\n       \"expires_in\": 360000\n     }\n     ```\n   - `token-failure.json`:\n     ```json\n     {\n       \"error\": \"invalid_grant\",\n       \"error_description\": \"Bad credentials\"\n     }\n     ```\n\n3. Create mock handlers for token endpoints in `tests/mocks/handlers.ts`:\n   ```typescript\n   import { http, HttpResponse } from 'msw';\n   import tokenSuccess from '../fixtures/auth/token-success.json';\n   import tokenFailure from '../fixtures/auth/token-failure.json';\n\n   export const handlers = [\n     // OAuth token endpoint\n     http.post('*/auth/oauth/token', async ({ request }) => {\n       const body = await request.text();\n       if (body.includes('bad-key')) {\n         return HttpResponse.json(tokenFailure, { status: 400 });\n       }\n       return HttpResponse.json(tokenSuccess);\n     }),\n     // Add other handlers as needed\n   ];\n   ```\n\n4. Set up the mock server in `tests/mocks/server.ts`:\n   ```typescript\n   import { setupServer } from 'msw/node';\n   import { handlers } from './handlers';\n\n   export const server = setupServer(...handlers);\n   ```\n\n5. Configure test setup in `tests/setup.ts`:\n   ```typescript\n   import { beforeAll, afterAll, afterEach } from 'vitest';\n   import { server } from './mocks/server';\n\n   beforeAll(() => server.listen());\n   afterEach(() => server.resetHandlers());\n   afterAll(() => server.close());\n   ```",
        "testStrategy": "1. Test successful token acquisition\n2. Test token caching (should not make a second request)\n3. Test token refresh when near expiry\n4. Test token refresh on 401 response\n5. Test error handling for bad credentials\n6. Test concurrent token requests (should only make one API call)\n7. Test token invalidation",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement HTTP layer with rate limiting",
        "description": "Create the HTTP client layer that handles requests, authentication headers, rate limiting, and error handling.",
        "details": "1. Create `src/rate-limiter.ts`:\n   ```typescript\n   import { RateLimitConfig, DEFAULT_RATE_LIMIT_CONFIG } from './config';\n   import { DattoRmmRateLimitError, DattoRmmIpBlockedError } from './errors';\n\n   export class RateLimiter {\n     private config: RateLimitConfig;\n     private requestTimestamps: number[] = [];\n     private ipBlockedUntil: number = 0;\n\n     constructor(config: Partial<RateLimitConfig> = {}) {\n       this.config = { ...DEFAULT_RATE_LIMIT_CONFIG, ...config };\n     }\n\n     async acquirePermit(): Promise<void> {\n       if (!this.config.enabled) return;\n\n       // Check if IP is blocked\n       if (Date.now() < this.ipBlockedUntil) {\n         const waitTimeMs = this.ipBlockedUntil - Date.now();\n         throw new DattoRmmIpBlockedError(\n           `IP is blocked. Retry after ${Math.ceil(waitTimeMs / 1000)} seconds.`\n         );\n       }\n\n       // Clean up old timestamps outside the window\n       const windowStart = Date.now() - this.config.windowMs;\n       this.requestTimestamps = this.requestTimestamps.filter(ts => ts >= windowStart);\n\n       // Check if we're over the limit\n       if (this.requestTimestamps.length >= this.config.maxRequests) {\n         throw new DattoRmmRateLimitError(\n           `Rate limit exceeded: ${this.requestTimestamps.length}/${this.config.maxRequests} requests in ${this.config.windowMs}ms`\n         );\n       }\n\n       // If we're over the throttle threshold, add delay\n       if (this.requestTimestamps.length >= this.config.maxRequests * this.config.throttleThreshold) {\n         const delay = 1000; // 1 second delay as per Datto RMM docs\n         await new Promise(resolve => setTimeout(resolve, delay));\n       }\n\n       // Record this request\n       this.requestTimestamps.push(Date.now());\n     }\n\n     handleResponse(statusCode: number): void {\n       if (statusCode === 429) {\n         // 429 Too Many Requests\n         // We'll retry with backoff in the HTTP client\n       } else if (statusCode === 403) {\n         // Check if this might be an IP block due to rate limiting\n         // This is a heuristic - we can't know for sure if 403 is due to rate limiting or permissions\n         const recentRequests = this.requestTimestamps.filter(\n           ts => ts >= Date.now() - 10000 // Last 10 seconds\n         ).length;\n         \n         if (recentRequests > 10) { // If we've made several requests recently, assume IP block\n           this.ipBlockedUntil = Date.now() + this.config.ipBlockCooldownMs;\n         }\n       }\n     }\n\n     getCurrentRate(): number {\n       const windowStart = Date.now() - this.config.windowMs;\n       const requestsInWindow = this.requestTimestamps.filter(ts => ts >= windowStart).length;\n       return requestsInWindow;\n     }\n\n     isIpBlocked(): boolean {\n       return Date.now() < this.ipBlockedUntil;\n     }\n   }\n   ```\n\n2. Create `src/http.ts`:\n   ```typescript\n   import { TokenManager } from './auth';\n   import { RateLimiter } from './rate-limiter';\n   import {\n     DattoRmmError,\n     DattoRmmAuthenticationError,\n     DattoRmmNotFoundError,\n     DattoRmmRateLimitError,\n     DattoRmmIpBlockedError,\n     DattoRmmForbiddenError,\n     DattoRmmServerError\n   } from './errors';\n\n   type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\n\n   interface RequestOptions {\n     method?: HttpMethod;\n     params?: Record<string, string | number | boolean | undefined>;\n     data?: any;\n     retryCount?: number;\n   }\n\n   export class HttpClient {\n     private baseUrl: string;\n     private tokenManager: TokenManager;\n     private rateLimiter: RateLimiter;\n     private maxRetries: number;\n\n     constructor(\n       baseUrl: string,\n       tokenManager: TokenManager,\n       rateLimiter: RateLimiter,\n       maxRetries: number = 3\n     ) {\n       this.baseUrl = baseUrl;\n       this.tokenManager = tokenManager;\n       this.rateLimiter = rateLimiter;\n       this.maxRetries = maxRetries;\n     }\n\n     async request<T>(\n       path: string,\n       options: RequestOptions = {}\n     ): Promise<T> {\n       const {\n         method = 'GET',\n         params = {},\n         data,\n         retryCount = 0\n       } = options;\n\n       // Build URL with query parameters\n       const url = new URL(`${this.baseUrl}${path}`);\n       Object.entries(params).forEach(([key, value]) => {\n         if (value !== undefined) {\n           url.searchParams.append(key, String(value));\n         }\n       });\n\n       try {\n         // Acquire rate limit permit\n         await this.rateLimiter.acquirePermit();\n\n         // Get auth token\n         const token = await this.tokenManager.getToken();\n\n         // Prepare headers\n         const headers: HeadersInit = {\n           'Authorization': `Bearer ${token}`,\n           'Accept': 'application/json',\n         };\n\n         // Add content-type for requests with body\n         if (data && method !== 'GET') {\n           headers['Content-Type'] = 'application/json';\n         }\n\n         // Make the request\n         const response = await fetch(url.toString(), {\n           method,\n           headers,\n           body: data ? JSON.stringify(data) : undefined,\n         });\n\n         // Handle rate limiting response\n         this.rateLimiter.handleResponse(response.status);\n\n         // Handle different response statuses\n         if (response.status === 204) {\n           // No content\n           return {} as T;\n         } else if (response.status === 401) {\n           // Unauthorized - token might be expired\n           if (retryCount < 1) { // Only retry once for auth errors\n             this.tokenManager.invalidateToken();\n             return this.request<T>(path, { ...options, retryCount: retryCount + 1 });\n           }\n           throw new DattoRmmAuthenticationError(\n             'Authentication failed after token refresh',\n             401,\n             await this.parseResponseBody(response)\n           );\n         } else if (response.status === 404) {\n           throw new DattoRmmNotFoundError(\n             `Resource not found: ${path}`,\n             await this.parseResponseBody(response)\n           );\n         } else if (response.status === 429) {\n           // Too many requests\n           if (retryCount < this.maxRetries) {\n             const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff\n             await new Promise(resolve => setTimeout(resolve, delay));\n             return this.request<T>(path, { ...options, retryCount: retryCount + 1 });\n           }\n           throw new DattoRmmRateLimitError(\n             'Rate limit exceeded and max retries reached',\n             await this.parseResponseBody(response)\n           );\n         } else if (response.status === 403) {\n           // Check if this is an IP block or a permission issue\n           if (this.rateLimiter.isIpBlocked()) {\n             throw new DattoRmmIpBlockedError(\n               'IP address has been blocked due to excessive requests',\n               await this.parseResponseBody(response)\n             );\n           }\n           throw new DattoRmmForbiddenError(\n             'Access forbidden',\n             await this.parseResponseBody(response)\n           );\n         } else if (response.status >= 500) {\n           // Server error\n           if (retryCount < this.maxRetries) {\n             const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff\n             await new Promise(resolve => setTimeout(resolve, delay));\n             return this.request<T>(path, { ...options, retryCount: retryCount + 1 });\n           }\n           throw new DattoRmmServerError(\n             `Server error: ${response.status} ${response.statusText}`,\n             response.status,\n             await this.parseResponseBody(response)\n           );\n         } else if (!response.ok) {\n           // Any other error\n           throw new DattoRmmError(\n             `Request failed: ${response.status} ${response.statusText}`,\n             response.status,\n             await this.parseResponseBody(response)\n           );\n         }\n\n         // Parse successful response\n         return await this.parseResponseBody(response);\n       } catch (error) {\n         if (error instanceof DattoRmmError) {\n           throw error;\n         }\n         throw new DattoRmmError(\n           `Request failed: ${error instanceof Error ? error.message : String(error)}`,\n           0\n         );\n       }\n     }\n\n     private async parseResponseBody(response: Response): Promise<any> {\n       const contentType = response.headers.get('content-type');\n       if (contentType && contentType.includes('application/json')) {\n         return await response.json();\n       }\n       return await response.text();\n     }\n\n     // Convenience methods\n     async get<T>(path: string, params?: Record<string, string | number | boolean | undefined>): Promise<T> {\n       return this.request<T>(path, { method: 'GET', params });\n     }\n\n     async post<T>(path: string, data?: any, params?: Record<string, string | number | boolean | undefined>): Promise<T> {\n       return this.request<T>(path, { method: 'POST', data, params });\n     }\n\n     async put<T>(path: string, data?: any, params?: Record<string, string | number | boolean | undefined>): Promise<T> {\n       return this.request<T>(path, { method: 'PUT', data, params });\n     }\n\n     async delete<T>(path: string, params?: Record<string, string | number | boolean | undefined>): Promise<T> {\n       return this.request<T>(path, { method: 'DELETE', params });\n     }\n   }\n   ```",
        "testStrategy": "1. Test successful GET, POST, PUT, DELETE requests\n2. Test request with query parameters\n3. Test rate limiting behavior (throttling at threshold)\n4. Test 429 response handling with retry\n5. Test 403 IP block detection and cooldown\n6. Test 401 token refresh\n7. Test 404 error handling\n8. Test 500 error handling with retry\n9. Test exponential backoff on retries",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement pagination utilities",
        "description": "Create pagination utilities to handle automatic traversal of paginated responses from the Datto RMM API.",
        "details": "1. Create `src/pagination.ts`:\n   ```typescript\n   import { HttpClient } from './http';\n   import { PageDetails, PaginatedResponse } from './types/common';\n\n   export class PaginatedIterator<T> {\n     private httpClient: HttpClient;\n     private initialPath: string;\n     private initialParams: Record<string, string | number | boolean | undefined>;\n     private dataKey: string;\n     private currentPage: T[] | null = null;\n     private currentPageDetails: PageDetails | null = null;\n     private currentIndex = 0;\n     private isDone = false;\n\n     constructor(\n       httpClient: HttpClient,\n       path: string,\n       params: Record<string, string | number | boolean | undefined> = {},\n       dataKey: string\n     ) {\n       this.httpClient = httpClient;\n       this.initialPath = path;\n       this.initialParams = params;\n       this.dataKey = dataKey;\n     }\n\n     async next(): Promise<IteratorResult<T>> {\n       // If we're done, return done\n       if (this.isDone) {\n         return { done: true, value: undefined as any };\n       }\n\n       // If we don't have a page yet, or we've reached the end of the current page\n       if (!this.currentPage || this.currentIndex >= this.currentPage.length) {\n         // If we have a page but reached the end, and there's no next page, we're done\n         if (this.currentPage && (!this.currentPageDetails || !this.currentPageDetails.nextPageUrl)) {\n           this.isDone = true;\n           return { done: true, value: undefined as any };\n         }\n\n         // Otherwise, fetch the next page\n         await this.fetchNextPage();\n\n         // If the page is empty, we're done\n         if (!this.currentPage || this.currentPage.length === 0) {\n           this.isDone = true;\n           return { done: true, value: undefined as any };\n         }\n\n         // Reset index for the new page\n         this.currentIndex = 0;\n       }\n\n       // Return the current item and advance the index\n       return { done: false, value: this.currentPage[this.currentIndex++] };\n     }\n\n     private async fetchNextPage(): Promise<void> {\n       let response: PaginatedResponse<T[]>;\n\n       if (!this.currentPageDetails || !this.currentPageDetails.nextPageUrl) {\n         // First page or no nextPageUrl available\n         response = await this.httpClient.get<PaginatedResponse<T[]>>(\n           this.initialPath,\n           this.initialParams\n         );\n       } else {\n         // Use the nextPageUrl directly\n         // Extract the path from the full URL\n         const url = new URL(this.currentPageDetails.nextPageUrl);\n         const path = url.pathname.replace('/api/v2', ''); // Remove the base path\n         \n         // Extract query parameters\n         const params: Record<string, string> = {};\n         url.searchParams.forEach((value, key) => {\n           params[key] = value;\n         });\n\n         response = await this.httpClient.get<PaginatedResponse<T[]>>(path, params);\n       }\n\n       this.currentPageDetails = response.pageDetails;\n       this.currentPage = response[this.dataKey] as T[];\n     }\n\n     // Make the iterator async iterable\n     [Symbol.asyncIterator](): AsyncIterator<T> {\n       return this;\n     }\n\n     // Helper to collect all items into an array\n     async toArray(): Promise<T[]> {\n       const results: T[] = [];\n       for await (const item of this) {\n         results.push(item);\n       }\n       return results;\n     }\n   }\n\n   // Helper function to create a paginated iterator\n   export function createPaginatedIterator<T>(\n     httpClient: HttpClient,\n     path: string,\n     params: Record<string, string | number | boolean | undefined> = {},\n     dataKey: string\n   ): PaginatedIterator<T> {\n     return new PaginatedIterator<T>(httpClient, path, params, dataKey);\n   }\n   ```",
        "testStrategy": "1. Test iterating through a single page of results\n2. Test iterating through multiple pages (following nextPageUrl)\n3. Test empty results handling\n4. Test toArray() method to collect all results\n5. Test with various data keys (devices, sites, alerts, etc.)\n6. Test with query parameters\n7. Test handling of null nextPageUrl (last page)",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement timestamp handling utilities",
        "description": "Create utilities for handling Unix timestamps with millisecond precision, converting between Date objects, ISO strings, and raw numbers.",
        "details": "1. Create timestamp utilities in `src/utils/timestamps.ts`:\n   ```typescript\n   import { TimestampFormat } from '../types/common';\n\n   /**\n    * Converts a timestamp to the specified format\n    * @param timestamp Unix timestamp in milliseconds, Date object, or ISO string\n    * @param format The desired output format\n    * @returns The timestamp in the specified format\n    */\n   export function formatTimestamp(\n     timestamp: number | Date | string | undefined,\n     format: TimestampFormat = 'date'\n   ): Date | number | string | undefined {\n     if (timestamp === undefined) return undefined;\n\n     // Convert to milliseconds number first\n     let timestampMs: number;\n\n     if (timestamp instanceof Date) {\n       timestampMs = timestamp.getTime();\n     } else if (typeof timestamp === 'string') {\n       timestampMs = new Date(timestamp).getTime();\n     } else {\n       timestampMs = timestamp;\n     }\n\n     // Convert to desired format\n     switch (format) {\n       case 'date':\n         return new Date(timestampMs);\n       case 'iso':\n         return new Date(timestampMs).toISOString();\n       case 'number':\n       default:\n         return timestampMs;\n     }\n   }\n\n   /**\n    * Converts a timestamp to Unix milliseconds for API requests\n    * @param timestamp Date object, ISO string, or Unix milliseconds\n    * @returns Unix timestamp in milliseconds\n    */\n   export function toApiTimestamp(\n     timestamp: Date | string | number | undefined\n   ): number | undefined {\n     if (timestamp === undefined) return undefined;\n\n     if (timestamp instanceof Date) {\n       return timestamp.getTime();\n     } else if (typeof timestamp === 'string') {\n       return new Date(timestamp).getTime();\n     }\n     return timestamp;\n   }\n\n   /**\n    * Recursively processes an object, converting all timestamp fields to the specified format\n    * @param obj The object to process\n    * @param format The desired timestamp format\n    * @param timestampFields Array of field names that should be treated as timestamps\n    * @returns A new object with converted timestamps\n    */\n   export function processTimestamps<T>(\n     obj: T,\n     format: TimestampFormat,\n     timestampFields: string[] = [\n       'createdAt', 'updatedAt', 'lastSeen', 'lastSeenDate', 'expiresAt',\n       'startTime', 'endTime', 'timestamp', 'date', 'resolvedOn', 'warrantyExpiryDate'\n     ]\n   ): T {\n     if (!obj || typeof obj !== 'object') return obj;\n\n     const result = Array.isArray(obj) ? [] : {} as any;\n\n     for (const [key, value] of Object.entries(obj)) {\n       if (timestampFields.includes(key) && (typeof value === 'number' || value instanceof Date || typeof value === 'string')) {\n         result[key] = formatTimestamp(value, format);\n       } else if (typeof value === 'object' && value !== null) {\n         result[key] = processTimestamps(value, format, timestampFields);\n       } else {\n         result[key] = value;\n       }\n     }\n\n     return result as T;\n   }\n   ```\n\n2. Create a directory for utilities:\n   ```bash\n   mkdir -p src/utils\n   ```\n\n3. Create an index file for utilities in `src/utils/index.ts`:\n   ```typescript\n   export * from './timestamps';\n   ```",
        "testStrategy": "1. Test converting Date objects to Unix milliseconds\n2. Test converting ISO strings to Unix milliseconds\n3. Test converting Unix milliseconds to Date objects\n4. Test converting Unix milliseconds to ISO strings\n5. Test recursive timestamp processing in complex objects\n6. Test handling of undefined values\n7. Test with custom timestamp field names",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement DattoRmmClient class",
        "description": "Create the main client class that integrates all components and exposes the API resources.",
        "details": "1. Create `src/client.ts`:\n   ```typescript\n   import { TokenManager } from './auth';\n   import { HttpClient } from './http';\n   import { RateLimiter } from './rate-limiter';\n   import { DattoRmmClientConfig, PLATFORM_URLS, DEFAULT_RATE_LIMIT_CONFIG } from './config';\n   import { TimestampFormat } from './types/common';\n   import { processTimestamps } from './utils/timestamps';\n\n   // Import resource classes (to be implemented)\n   import { AccountResource } from './resources/account';\n   import { SitesResource } from './resources/sites';\n   import { DevicesResource } from './resources/devices';\n   import { AlertsResource } from './resources/alerts';\n   import { AuditResource } from './resources/audit';\n   import { JobsResource } from './resources/jobs';\n   import { FiltersResource } from './resources/filters';\n   import { SystemResource } from './resources/system';\n   import { UsersResource } from './resources/users';\n   import { ActivityLogsResource } from './resources/activity-logs';\n\n   export class DattoRmmClient {\n     private httpClient: HttpClient;\n     private tokenManager: TokenManager;\n     private rateLimiter: RateLimiter;\n     private timestampFormat: TimestampFormat;\n\n     // Resources\n     readonly account: AccountResource;\n     readonly sites: SitesResource;\n     readonly devices: DevicesResource;\n     readonly alerts: AlertsResource;\n     readonly audit: AuditResource;\n     readonly jobs: JobsResource;\n     readonly filters: FiltersResource;\n     readonly system: SystemResource;\n     readonly users: UsersResource;\n     readonly activityLogs: ActivityLogsResource;\n\n     constructor(config: DattoRmmClientConfig) {\n       // Validate config\n       if (!config.apiKey || !config.apiSecretKey) {\n         throw new Error('API key and API secret key are required');\n       }\n\n       // Determine API URL\n       let apiUrl: string;\n       if (config.apiUrl) {\n         apiUrl = config.apiUrl;\n       } else if (config.platform && PLATFORM_URLS[config.platform]) {\n         apiUrl = PLATFORM_URLS[config.platform];\n       } else {\n         throw new Error('Either platform or apiUrl must be provided');\n       }\n\n       // Set up components\n       this.timestampFormat = config.timestamps || 'date';\n       this.rateLimiter = new RateLimiter(config.rateLimiter);\n       this.tokenManager = new TokenManager(config.apiKey, config.apiSecretKey, apiUrl);\n       this.httpClient = new HttpClient(\n         `${apiUrl}/api/v2`,\n         this.tokenManager,\n         this.rateLimiter\n       );\n\n       // Initialize resources\n       this.account = new AccountResource(this.httpClient, this.timestampFormat);\n       this.sites = new SitesResource(this.httpClient, this.timestampFormat);\n       this.devices = new DevicesResource(this.httpClient, this.timestampFormat);\n       this.alerts = new AlertsResource(this.httpClient, this.timestampFormat);\n       this.audit = new AuditResource(this.httpClient, this.timestampFormat);\n       this.jobs = new JobsResource(this.httpClient, this.timestampFormat);\n       this.filters = new FiltersResource(this.httpClient, this.timestampFormat);\n       this.system = new SystemResource(this.httpClient, this.timestampFormat);\n       this.users = new UsersResource(this.httpClient, this.timestampFormat);\n       this.activityLogs = new ActivityLogsResource(this.httpClient, this.timestampFormat);\n     }\n\n     /**\n      * Process API response data, converting timestamps to the configured format\n      * @param data The data to process\n      * @returns Processed data with converted timestamps\n      */\n     processResponse<T>(data: T): T {\n       return processTimestamps(data, this.timestampFormat);\n     }\n   }\n   ```\n\n2. Create a base resource class in `src/resources/base.ts`:\n   ```typescript\n   import { HttpClient } from '../http';\n   import { TimestampFormat } from '../types/common';\n   import { processTimestamps } from '../utils/timestamps';\n   import { createPaginatedIterator, PaginatedIterator } from '../pagination';\n\n   export abstract class BaseResource {\n     protected httpClient: HttpClient;\n     protected timestampFormat: TimestampFormat;\n\n     constructor(httpClient: HttpClient, timestampFormat: TimestampFormat = 'date') {\n       this.httpClient = httpClient;\n       this.timestampFormat = timestampFormat;\n     }\n\n     /**\n      * Process API response data, converting timestamps to the configured format\n      * @param data The data to process\n      * @returns Processed data with converted timestamps\n      */\n     protected processResponse<T>(data: T): T {\n       return processTimestamps(data, this.timestampFormat);\n     }\n\n     /**\n      * Create a paginated iterator for a resource\n      * @param path API path\n      * @param params Query parameters\n      * @param dataKey The key in the response that contains the data array\n      * @returns A paginated iterator\n      */\n     protected createPaginatedIterator<T>(\n       path: string,\n       params: Record<string, string | number | boolean | undefined> = {},\n       dataKey: string\n     ): PaginatedIterator<T> {\n       return createPaginatedIterator<T>(this.httpClient, path, params, dataKey);\n     }\n   }\n   ```\n\n3. Create `src/index.ts` to export the public API:\n   ```typescript\n   export { DattoRmmClient } from './client';\n   export { DattoRmmError, DattoRmmAuthenticationError, DattoRmmNotFoundError, DattoRmmRateLimitError, DattoRmmIpBlockedError, DattoRmmForbiddenError, DattoRmmServerError } from './errors';\n   export type { DattoRmmClientConfig, RateLimitConfig } from './config';\n   export type { TimestampFormat, PageDetails, PaginatedResponse } from './types/common';\n   export type { AlertContext } from './types/alert-contexts';\n   // Export other types as needed\n   ```",
        "testStrategy": "1. Test client initialization with different configuration options\n2. Test platform URL mapping\n3. Test validation of required configuration parameters\n4. Test resource initialization\n5. Test timestamp format configuration\n6. Test error handling for invalid configuration",
        "priority": "high",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Account resource",
        "description": "Implement the Account resource with methods for retrieving account information, users, sites, devices, components, alerts, and variables.",
        "details": "1. Create type definitions for Account in `src/types/account.ts`:\n   ```typescript\n   import { PageDetails } from './common';\n\n   export interface Account {\n     uid: string;\n     name: string;\n     // Add other account properties\n   }\n\n   export interface User {\n     uid: string;\n     username: string;\n     firstName: string;\n     lastName: string;\n     email: string;\n     // Add other user properties\n   }\n\n   export interface Site {\n     uid: string;\n     name: string;\n     description: string;\n     // Add other site properties\n   }\n\n   export interface Device {\n     uid: string;\n     hostname: string;\n     deviceClass: string;\n     deviceType: string;\n     siteUid: string;\n     siteName: string;\n     operatingSystem: string;\n     // Add other device properties\n   }\n\n   export interface Component {\n     uid: string;\n     name: string;\n     description: string;\n     // Add other component properties\n   }\n\n   export interface Alert {\n     uid: string;\n     deviceUid: string;\n     deviceName: string;\n     alertType: string;\n     alertContext: any; // Will be typed with AlertContext union\n     // Add other alert properties\n   }\n\n   export interface Variable {\n     id: number;\n     name: string;\n     value: string;\n     masked: boolean;\n   }\n\n   export interface VariableCreate {\n     name: string;\n     value: string;\n     masked?: boolean;\n   }\n\n   export interface VariableUpdate {\n     value: string;\n     masked?: boolean;\n   }\n\n   export interface AccountUsersResponse {\n     pageDetails: PageDetails;\n     users: User[];\n   }\n\n   export interface AccountSitesResponse {\n     pageDetails: PageDetails;\n     sites: Site[];\n   }\n\n   export interface AccountDevicesResponse {\n     pageDetails: PageDetails;\n     devices: Device[];\n   }\n\n   export interface AccountComponentsResponse {\n     pageDetails: PageDetails;\n     components: Component[];\n   }\n\n   export interface AccountAlertsResponse {\n     pageDetails: PageDetails;\n     alerts: Alert[];\n   }\n\n   export interface AccountVariablesResponse {\n     variables: Variable[];\n   }\n   ```\n\n2. Create the Account resource in `src/resources/account.ts`:\n   ```typescript\n   import { BaseResource } from './base';\n   import {\n     Account,\n     User,\n     Site,\n     Device,\n     Component,\n     Alert,\n     Variable,\n     VariableCreate,\n     VariableUpdate,\n     AccountUsersResponse,\n     AccountSitesResponse,\n     AccountDevicesResponse,\n     AccountComponentsResponse,\n     AccountAlertsResponse,\n     AccountVariablesResponse\n   } from '../types/account';\n   import { PaginatedIterator } from '../pagination';\n\n   export class AccountResource extends BaseResource {\n     /**\n      * Get account information\n      */\n     async get(): Promise<Account> {\n       const response = await this.httpClient.get<Account>('/account');\n       return this.processResponse(response);\n     }\n\n     /**\n      * Get account users\n      * @param params Pagination parameters\n      */\n     async users(params: { page?: number; max?: number } = {}): Promise<AccountUsersResponse> {\n       const response = await this.httpClient.get<AccountUsersResponse>('/account/users', params);\n       return this.processResponse(response);\n     }\n\n     /**\n      * Get all account users (auto-paginated)\n      */\n     usersAll(): PaginatedIterator<User> {\n       return this.createPaginatedIterator<User>('/account/users', {}, 'users');\n     }\n\n     /**\n      * Get account sites\n      * @param params Pagination parameters\n      */\n     async sites(params: { page?: number; max?: number } = {}): Promise<AccountSitesResponse> {\n       const response = await this.httpClient.get<AccountSitesResponse>('/account/sites', params);\n       return this.processResponse(response);\n     }\n\n     /**\n      * Get all account sites (auto-paginated)\n      */\n     sitesAll(): PaginatedIterator<Site> {\n       return this.createPaginatedIterator<Site>('/account/sites', {}, 'sites');\n     }\n\n     /**\n      * Get account devices\n      * @param params Pagination and filter parameters\n      */\n     async devices(params: { page?: number; max?: number; filter?: string } = {}): Promise<AccountDevicesResponse> {\n       const response = await this.httpClient.get<AccountDevicesResponse>('/account/devices', params);\n       return this.processResponse(response);\n     }\n\n     /**\n      * Get all account devices (auto-paginated)\n      * @param params Filter parameters\n      */\n     devicesAll(params: { filter?: string } = {}): PaginatedIterator<Device> {\n       return this.createPaginatedIterator<Device>('/account/devices', params, 'devices');\n     }\n\n     /**\n      * Get account components\n      * @param params Pagination parameters\n      */\n     async components(params: { page?: number; max?: number } = {}): Promise<AccountComponentsResponse> {\n       const response = await this.httpClient.get<AccountComponentsResponse>('/account/components', params);\n       return this.processResponse(response);\n     }\n\n     /**\n      * Get all account components (auto-paginated)\n      */\n     componentsAll(): PaginatedIterator<Component> {\n       return this.createPaginatedIterator<Component>('/account/components', {}, 'components');\n     }\n\n     /**\n      * Get open alerts for the account\n      * @param params Pagination parameters\n      */\n     async alertsOpen(params: { page?: number; max?: number } = {}): Promise<AccountAlertsResponse> {\n       const response = await this.httpClient.get<AccountAlertsResponse>('/account/alerts/open', params);\n       return this.processResponse(response);\n     }\n\n     /**\n      * Get all open alerts for the account (auto-paginated)\n      */\n     alertsOpenAll(): PaginatedIterator<Alert> {\n       return this.createPaginatedIterator<Alert>('/account/alerts/open', {}, 'alerts');\n     }\n\n     /**\n      * Get resolved alerts for the account\n      * @param params Pagination parameters\n      */\n     async alertsResolved(params: { page?: number; max?: number } = {}): Promise<AccountAlertsResponse> {\n       const response = await this.httpClient.get<AccountAlertsResponse>('/account/alerts/resolved', params);\n       return this.processResponse(response);\n     }\n\n     /**\n      * Get all resolved alerts for the account (auto-paginated)\n      */\n     alertsResolvedAll(): PaginatedIterator<Alert> {\n       return this.createPaginatedIterator<Alert>('/account/alerts/resolved', {}, 'alerts');\n     }\n\n     /**\n      * Get account variables\n      */\n     async variables(): Promise<Variable[]> {\n       const response = await this.httpClient.get<AccountVariablesResponse>('/account/variables');\n       return this.processResponse(response.variables);\n     }\n\n     /**\n      * Create an account variable\n      * @param data Variable data\n      */\n     async createVariable(data: VariableCreate): Promise<Variable> {\n       const response = await this.httpClient.put<Variable>('/account/variable', data);\n       return this.processResponse(response);\n     }\n\n     /**\n      * Update an account variable\n      * @param variableId Variable ID\n      * @param data Update data\n      */\n     async updateVariable(variableId: number, data: VariableUpdate): Promise<Variable> {\n       const response = await this.httpClient.post<Variable>(`/account/variable/${variableId}`, data);\n       return this.processResponse(response);\n     }\n\n     /**\n      * Delete an account variable\n      * @param variableId Variable ID\n      */\n     async deleteVariable(variableId: number): Promise<void> {\n       await this.httpClient.delete(`/account/variable/${variableId}`);\n     }\n   }\n   ```\n\n3. Create test fixtures for account responses in `tests/fixtures/account/`:\n   - `data.json` - Account information\n   - `users.json` - Account users\n   - `sites-page1.json` - First page of sites\n   - `devices-page1.json` - First page of devices\n   - `alerts-open.json` - Open alerts\n   - `variables.json` - Account variables",
        "testStrategy": "1. Test get() method returns account information\n2. Test users() method returns paginated users\n3. Test usersAll() method auto-paginates all users\n4. Test sites() method returns paginated sites\n5. Test devices() method returns paginated devices\n6. Test devices() with filter parameter\n7. Test alertsOpen() and alertsResolved() methods\n8. Test variables() method returns all variables\n9. Test createVariable(), updateVariable(), and deleteVariable() methods\n10. Test error handling for each method",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement remaining core resources",
        "description": "Implement the Sites, Devices, Alerts, Audit, Jobs, Filters, System, Users, and ActivityLogs resources.",
        "details": "For each resource, follow this pattern:\n\n1. Create type definitions in `src/types/[resource].ts`\n2. Create the resource class in `src/resources/[resource].ts`\n3. Create test fixtures in `tests/fixtures/[resource]/`\n\nImplement the following resources:\n\n1. **Sites Resource** (`src/resources/sites.ts`):\n   ```typescript\n   import { BaseResource } from './base';\n   // Import types\n\n   export class SitesResource extends BaseResource {\n     async create(data: SiteCreate): Promise<Site> { /* ... */ }\n     async get(siteUid: string): Promise<Site> { /* ... */ }\n     async update(siteUid: string, data: SiteUpdate): Promise<Site> { /* ... */ }\n     async devices(siteUid: string, params?: { page?: number; max?: number }): Promise<SiteDevicesResponse> { /* ... */ }\n     devicesAll(siteUid: string): PaginatedIterator<Device> { /* ... */ }\n     async networkInterfaces(siteUid: string, params?: { page?: number; max?: number }): Promise<NetworkInterfacesResponse> { /* ... */ }\n     async settings(siteUid: string): Promise<SiteSettings> { /* ... */ }\n     async filters(siteUid: string): Promise<SiteFilters> { /* ... */ }\n     async alertsOpen(siteUid: string, params?: { page?: number; max?: number }): Promise<SiteAlertsResponse> { /* ... */ }\n     alertsOpenAll(siteUid: string): PaginatedIterator<Alert> { /* ... */ }\n     async alertsResolved(siteUid: string, params?: { page?: number; max?: number }): Promise<SiteAlertsResponse> { /* ... */ }\n     alertsResolvedAll(siteUid: string): PaginatedIterator<Alert> { /* ... */ }\n     async variables(siteUid: string): Promise<Variable[]> { /* ... */ }\n     async createVariable(siteUid: string, data: VariableCreate): Promise<Variable> { /* ... */ }\n     async updateVariable(siteUid: string, variableId: number, data: VariableUpdate): Promise<Variable> { /* ... */ }\n     async deleteVariable(siteUid: string, variableId: number): Promise<void> { /* ... */ }\n     async setProxy(siteUid: string, data: ProxySettings): Promise<void> { /* ... */ }\n     async deleteProxy(siteUid: string): Promise<void> { /* ... */ }\n   }\n   ```\n\n2. **Devices Resource** (`src/resources/devices.ts`):\n   ```typescript\n   import { BaseResource } from './base';\n   // Import types\n\n   export class DevicesResource extends BaseResource {\n     async get(deviceUid: string): Promise<Device> { /* ... */ }\n     async getById(deviceId: string): Promise<Device> { /* ... */ }\n     async getByMac(macAddress: string): Promise<Device> { /* ... */ }\n     async alertsOpen(deviceUid: string, params?: { page?: number; max?: number }): Promise<DeviceAlertsResponse> { /* ... */ }\n     alertsOpenAll(deviceUid: string): PaginatedIterator<Alert> { /* ... */ }\n     async alertsResolved(deviceUid: string, params?: { page?: number; max?: number }): Promise<DeviceAlertsResponse> { /* ... */ }\n     alertsResolvedAll(deviceUid: string): PaginatedIterator<Alert> { /* ... */ }\n     async move(deviceUid: string, siteUid: string): Promise<void> { /* ... */ }\n     async createQuickJob(deviceUid: string, data: QuickJobCreate): Promise<QuickJob> { /* ... */ }\n     async updateWarranty(deviceUid: string, data: WarrantyUpdate): Promise<Device> { /* ... */ }\n     async setUdf(deviceUid: string, data: Record<string, string>): Promise<Device> { /* ... */ }\n   }\n   ```\n\n3. **Alerts Resource** (`src/resources/alerts.ts`):\n   ```typescript\n   import { BaseResource } from './base';\n   // Import types\n\n   export class AlertsResource extends BaseResource {\n     async get(alertUid: string): Promise<Alert> { /* ... */ }\n     async resolve(alertUid: string): Promise<void> { /* ... */ }\n     async mute(alertUid: string): Promise<void> { /* ... */ }\n     async unmute(alertUid: string): Promise<void> { /* ... */ }\n   }\n   ```\n\n4. **Audit Resource** (`src/resources/audit.ts`):\n   ```typescript\n   import { BaseResource } from './base';\n   // Import types\n\n   export class AuditResource extends BaseResource {\n     async device(deviceUid: string): Promise<DeviceAudit> { /* ... */ }\n     async deviceSoftware(deviceUid: string): Promise<DeviceSoftware[]> { /* ... */ }\n     async deviceByMac(macAddress: string): Promise<DeviceAudit> { /* ... */ }\n     async esxiHost(deviceUid: string): Promise<EsxiHostAudit> { /* ... */ }\n     async printer(deviceUid: string): Promise<PrinterAudit> { /* ... */ }\n   }\n   ```\n\n5. **Jobs Resource** (`src/resources/jobs.ts`):\n   ```typescript\n   import { BaseResource } from './base';\n   // Import types\n\n   export class JobsResource extends BaseResource {\n     async get(jobUid: string): Promise<Job> { /* ... */ }\n     async results(jobUid: string, deviceUid: string): Promise<JobResults> { /* ... */ }\n     async stdout(jobUid: string, deviceUid: string): Promise<string> { /* ... */ }\n     async stderr(jobUid: string, deviceUid: string): Promise<string> { /* ... */ }\n     async components(jobUid: string): Promise<JobComponent[]> { /* ... */ }\n   }\n   ```\n\n6. **Filters Resource** (`src/resources/filters.ts`):\n   ```typescript\n   import { BaseResource } from './base';\n   // Import types\n\n   export class FiltersResource extends BaseResource {\n     async defaults(): Promise<DefaultFilter[]> { /* ... */ }\n     async custom(): Promise<CustomFilter[]> { /* ... */ }\n   }\n   ```\n\n7. **System Resource** (`src/resources/system.ts`):\n   ```typescript\n   import { BaseResource } from './base';\n   // Import types\n\n   export class SystemResource extends BaseResource {\n     async status(): Promise<SystemStatus> { /* ... */ }\n     async requestRate(): Promise<RequestRate> { /* ... */ }\n     async pagination(): Promise<PaginationInfo> { /* ... */ }\n   }\n   ```\n\n8. **Users Resource** (`src/resources/users.ts`):\n   ```typescript\n   import { BaseResource } from './base';\n   // Import types\n\n   export class UsersResource extends BaseResource {\n     async resetApiKeys(): Promise<ApiKeys> { /* ... */ }\n   }\n   ```\n\n9. **ActivityLogs Resource** (`src/resources/activity-logs.ts`):\n   ```typescript\n   import { BaseResource } from './base';\n   // Import types\n\n   export class ActivityLogsResource extends BaseResource {\n     async list(params?: ActivityLogsParams): Promise<ActivityLogsResponse> { /* ... */ }\n     listAll(params?: ActivityLogsParams): PaginatedIterator<ActivityLog> { /* ... */ }\n   }\n   ```\n\nFor each resource, implement the methods according to the API documentation, following the patterns established in the Account resource.",
        "testStrategy": "For each resource:\n1. Create unit tests for each method\n2. Test successful responses\n3. Test error handling\n4. Test pagination for methods that support it\n5. Test parameter validation\n6. Test timestamp conversion\n7. Ensure all methods follow the same patterns and conventions",
        "priority": "high",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Create comprehensive test suite",
        "description": "Create a comprehensive test suite with unit and integration tests for all components of the library.",
        "details": "1. Set up the test directory structure:\n   ```\n   tests/\n    setup.ts\n    fixtures/\n       auth/\n       account/\n       sites/\n       devices/\n       alerts/\n       audit/\n       jobs/\n       filters/\n       system/\n       users/\n       activity-logs/\n    mocks/\n       handlers.ts\n       server.ts\n    unit/\n       client.test.ts\n       auth.test.ts\n       http.test.ts\n       pagination.test.ts\n       rate-limiter.test.ts\n       timestamps.test.ts\n    integration/\n        account.test.ts\n        sites.test.ts\n        devices.test.ts\n        alerts.test.ts\n        audit.test.ts\n        jobs.test.ts\n        filters.test.ts\n        system.test.ts\n        users.test.ts\n        activity-logs.test.ts\n   ```\n\n2. Create unit tests for core components:\n\n   **auth.test.ts**:\n   ```typescript\n   import { describe, it, expect, beforeEach, vi } from 'vitest';\n   import { TokenManager } from '../../src/auth';\n   import { server } from '../mocks/server';\n   import { http, HttpResponse } from 'msw';\n\n   describe('TokenManager', () => {\n     const apiKey = 'test-api-key';\n     const apiSecretKey = 'test-api-secret';\n     const apiUrl = 'https://merlot-api.centrastage.net';\n     let tokenManager: TokenManager;\n\n     beforeEach(() => {\n       tokenManager = new TokenManager(apiKey, apiSecretKey, apiUrl);\n     });\n\n     it('should acquire a token successfully', async () => {\n       const token = await tokenManager.getToken();\n       expect(token).toBe('mock-jwt-token');\n     });\n\n     it('should cache the token', async () => {\n       // First call should make an API request\n       await tokenManager.getToken();\n\n       // Mock to track if a second request is made\n       const requestSpy = vi.fn();\n       server.use(\n         http.post('*/auth/oauth/token', ({ request }) => {\n           requestSpy();\n           return HttpResponse.json({\n             access_token: 'new-token',\n             token_type: 'bearer',\n             expires_in: 360000,\n           });\n         })\n       );\n\n       // Second call should use cached token\n       const token = await tokenManager.getToken();\n       expect(token).toBe('mock-jwt-token');\n       expect(requestSpy).not.toHaveBeenCalled();\n     });\n\n     it('should handle authentication errors', async () => {\n       // Override the handler to return an error\n       server.use(\n         http.post('*/auth/oauth/token', () => {\n           return HttpResponse.json({ error: 'invalid_grant' }, { status: 400 });\n         })\n       );\n\n       const tokenManager = new TokenManager('bad-key', apiSecretKey, apiUrl);\n       await expect(tokenManager.getToken()).rejects.toThrow('Failed to acquire token');\n     });\n\n     // Add more tests for token refresh, invalidation, etc.\n   });\n   ```\n\n   **rate-limiter.test.ts**:\n   ```typescript\n   import { describe, it, expect, beforeEach } from 'vitest';\n   import { RateLimiter } from '../../src/rate-limiter';\n\n   describe('RateLimiter', () => {\n     let rateLimiter: RateLimiter;\n\n     beforeEach(() => {\n       rateLimiter = new RateLimiter({\n         enabled: true,\n         maxRequests: 10, // Smaller for testing\n         windowMs: 1000,  // Shorter window for testing\n         throttleThreshold: 0.8,\n         retryAfterMs: 100,\n         maxRetries: 3,\n         ipBlockCooldownMs: 500,\n       });\n     });\n\n     it('should allow requests under the limit', async () => {\n       for (let i = 0; i < 8; i++) {\n         await expect(rateLimiter.acquirePermit()).resolves.toBeUndefined();\n       }\n       expect(rateLimiter.getCurrentRate()).toBe(8);\n     });\n\n     it('should block requests over the limit', async () => {\n       // Fill up to the limit\n       for (let i = 0; i < 10; i++) {\n         await rateLimiter.acquirePermit();\n       }\n\n       // Next request should be blocked\n       await expect(rateLimiter.acquirePermit()).rejects.toThrow('Rate limit exceeded');\n     });\n\n     it('should handle IP blocks', () => {\n       rateLimiter.handleResponse(403);\n       expect(rateLimiter.isIpBlocked()).toBe(true);\n     });\n\n     // Add more tests for throttling, window sliding, etc.\n   });\n   ```\n\n3. Create integration tests for resources:\n\n   **account.test.ts**:\n   ```typescript\n   import { describe, it, expect, beforeEach } from 'vitest';\n   import { DattoRmmClient } from '../../src/client';\n   import { server } from '../mocks/server';\n   import { http, HttpResponse } from 'msw';\n   import accountData from '../fixtures/account/data.json';\n   import accountUsers from '../fixtures/account/users.json';\n\n   describe('AccountResource', () => {\n     let client: DattoRmmClient;\n\n     beforeEach(() => {\n       client = new DattoRmmClient({\n         apiKey: 'test-api-key',\n         apiSecretKey: 'test-api-secret',\n         platform: 'merlot',\n       });\n\n       // Add specific handlers for account endpoints\n       server.use(\n         http.get('*/api/v2/account', () => {\n           return HttpResponse.json(accountData);\n         }),\n         http.get('*/api/v2/account/users', () => {\n           return HttpResponse.json(accountUsers);\n         })\n         // Add more handlers as needed\n       );\n     });\n\n     it('should get account information', async () => {\n       const account = await client.account.get();\n       expect(account).toEqual(accountData);\n     });\n\n     it('should get account users', async () => {\n       const response = await client.account.users();\n       expect(response.users).toHaveLength(accountUsers.users.length);\n       expect(response.pageDetails).toEqual(accountUsers.pageDetails);\n     });\n\n     // Add more tests for other account methods\n   });\n   ```\n\n4. Create tests for pagination:\n\n   **pagination.test.ts**:\n   ```typescript\n   import { describe, it, expect, vi } from 'vitest';\n   import { PaginatedIterator } from '../../src/pagination';\n   import { HttpClient } from '../../src/http';\n\n   describe('PaginatedIterator', () => {\n     it('should iterate through a single page', async () => {\n       const mockHttpClient = {\n         get: vi.fn().mockResolvedValue({\n           pageDetails: {\n             count: 2,\n             page: 1,\n             prevPageUrl: null,\n             nextPageUrl: null\n           },\n           items: [\n             { id: 1, name: 'Item 1' },\n             { id: 2, name: 'Item 2' }\n           ]\n         })\n       } as unknown as HttpClient;\n\n       const iterator = new PaginatedIterator<any>(\n         mockHttpClient,\n         '/test',\n         {},\n         'items'\n       );\n\n       const results = [];\n       for await (const item of iterator) {\n         results.push(item);\n       }\n\n       expect(results).toHaveLength(2);\n       expect(results[0].id).toBe(1);\n       expect(results[1].id).toBe(2);\n       expect(mockHttpClient.get).toHaveBeenCalledTimes(1);\n     });\n\n     it('should follow nextPageUrl for multiple pages', async () => {\n       const mockHttpClient = {\n         get: vi.fn()\n           .mockResolvedValueOnce({\n             pageDetails: {\n               count: 2,\n               page: 1,\n               prevPageUrl: null,\n               nextPageUrl: 'https://api.example.com/api/v2/test?page=2'\n             },\n             items: [\n               { id: 1, name: 'Item 1' },\n               { id: 2, name: 'Item 2' }\n             ]\n           })\n           .mockResolvedValueOnce({\n             pageDetails: {\n               count: 1,\n               page: 2,\n               prevPageUrl: 'https://api.example.com/api/v2/test?page=1',\n               nextPageUrl: null\n             },\n             items: [\n               { id: 3, name: 'Item 3' }\n             ]\n           })\n       } as unknown as HttpClient;\n\n       const iterator = new PaginatedIterator<any>(\n         mockHttpClient,\n         '/test',\n         {},\n         'items'\n       );\n\n       const results = await iterator.toArray();\n\n       expect(results).toHaveLength(3);\n       expect(results[0].id).toBe(1);\n       expect(results[1].id).toBe(2);\n       expect(results[2].id).toBe(3);\n       expect(mockHttpClient.get).toHaveBeenCalledTimes(2);\n     });\n\n     // Add more tests for empty results, error handling, etc.\n   });\n   ```\n\n5. Create tests for timestamp handling:\n\n   **timestamps.test.ts**:\n   ```typescript\n   import { describe, it, expect } from 'vitest';\n   import { formatTimestamp, toApiTimestamp, processTimestamps } from '../../src/utils/timestamps';\n\n   describe('Timestamp utilities', () => {\n     it('should convert Date to Unix milliseconds', () => {\n       const date = new Date('2023-01-01T00:00:00Z');\n       const timestamp = toApiTimestamp(date);\n       expect(timestamp).toBe(date.getTime());\n     });\n\n     it('should convert ISO string to Unix milliseconds', () => {\n       const iso = '2023-01-01T00:00:00Z';\n       const timestamp = toApiTimestamp(iso);\n       expect(timestamp).toBe(new Date(iso).getTime());\n     });\n\n     it('should format Unix milliseconds to Date', () => {\n       const ms = 1672531200000; // 2023-01-01T00:00:00Z\n       const formatted = formatTimestamp(ms, 'date');\n       expect(formatted).toBeInstanceOf(Date);\n       expect((formatted as Date).getTime()).toBe(ms);\n     });\n\n     it('should process timestamps in complex objects', () => {\n       const input = {\n         id: 1,\n         name: 'Test',\n         createdAt: 1672531200000, // 2023-01-01T00:00:00Z\n         updatedAt: 1672617600000, // 2023-01-02T00:00:00Z\n         nested: {\n           timestamp: 1672704000000, // 2023-01-03T00:00:00Z\n         },\n         items: [\n           { id: 1, lastSeen: 1672790400000 } // 2023-01-04T00:00:00Z\n         ]\n       };\n\n       const processed = processTimestamps(input, 'date');\n\n       expect(processed.createdAt).toBeInstanceOf(Date);\n       expect((processed.createdAt as Date).getTime()).toBe(1672531200000);\n       expect(processed.updatedAt).toBeInstanceOf(Date);\n       expect(processed.nested.timestamp).toBeInstanceOf(Date);\n       expect(processed.items[0].lastSeen).toBeInstanceOf(Date);\n     });\n\n     // Add more tests for other timestamp formats and edge cases\n   });\n   ```",
        "testStrategy": "1. Run all unit tests to verify core components work correctly\n2. Run all integration tests to verify resource implementations\n3. Verify test coverage is at least 90%\n4. Ensure all tests pass without making actual API calls\n5. Test error scenarios and edge cases\n6. Verify timestamp handling works correctly\n7. Test pagination with multiple pages\n8. Test rate limiting behavior",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-02-04T23:46:35.275Z",
      "updated": "2026-02-04T23:46:35.275Z",
      "description": "Tasks for node-datto-rmm context"
    }
  },
  "it-glue-plugin": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up project directory structure",
        "description": "Create the initial directory structure for the IT Glue Claude Code Plugin according to the PRD specifications.",
        "details": "Create the following directory structure:\n```\nkaseya/it-glue/\n .claude-plugin/\n    plugin.json\n .mcp.json\n README.md\n skills/\n    organizations/\n       SKILL.md\n    configurations/\n       SKILL.md\n    contacts/\n       SKILL.md\n    passwords/\n       SKILL.md\n    documents/\n       SKILL.md\n    flexible-assets/\n       SKILL.md\n    api-patterns/\n        SKILL.md\n commands/\n     lookup-asset.md\n     search-docs.md\n     get-password.md\n     find-organization.md\n```\nEnsure all directories and placeholder files are created with the correct naming conventions. This structure follows the established plugin architecture pattern from other plugins in the MSP Claude Plugin Marketplace.",
        "testStrategy": "Verify that all directories and files exist in the correct locations. Run a directory listing command to confirm the structure matches the PRD specifications.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create plugin.json manifest",
        "description": "Create the plugin.json manifest file with all required configuration for the IT Glue Claude Code Plugin.",
        "details": "Create the plugin.json file in the .claude-plugin directory with the following content:\n```json\n{\n  \"name\": \"kaseya-it-glue\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Claude plugins for IT Glue documentation platform - organizations, assets, passwords, documents\",\n  \"author\": \"MSP Claude Plugins Community\",\n  \"vendor\": \"kaseya\",\n  \"product\": \"it-glue\",\n  \"api_version\": \"v1\",\n  \"requires_api_key\": true,\n  \"documentation_url\": \"https://api.itglue.com/developer/\",\n  \"skills\": [\n    \"organizations\",\n    \"configurations\",\n    \"contacts\",\n    \"passwords\",\n    \"documents\",\n    \"flexible-assets\",\n    \"api-patterns\"\n  ],\n  \"commands\": [\n    \"lookup-asset\",\n    \"search-docs\",\n    \"get-password\",\n    \"find-organization\"\n  ]\n}\n```\nEnsure the manifest includes all required fields and correctly references all skills and commands that will be implemented.",
        "testStrategy": "Validate the JSON syntax using a JSON linter. Verify that all skills and commands listed in the manifest match the directory structure created in Task 1.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create .mcp.json configuration",
        "description": "Create the .mcp.json configuration file for the MCP server integration with IT Glue.",
        "details": "Create the .mcp.json file in the root directory with the following content:\n```json\n{\n  \"mcpServers\": {\n    \"it-glue\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"it-glue-mcp\"],\n      \"env\": {\n        \"IT_GLUE_API_KEY\": \"${IT_GLUE_API_KEY}\",\n        \"IT_GLUE_REGION\": \"${IT_GLUE_REGION:-us}\"\n      }\n    }\n  }\n}\n```\nThis configuration sets up the MCP server to use environment variables for API key and region, with a default region of 'us'. The configuration uses the `it-glue-mcp` package via npx.",
        "testStrategy": "Validate the JSON syntax using a JSON linter. Verify that the configuration uses environment variables for sensitive information and does not contain hardcoded credentials.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement API Patterns skill",
        "description": "Create the API Patterns skill that serves as the foundation for IT Glue API interactions.",
        "details": "Create the api-patterns/SKILL.md file with comprehensive documentation on IT Glue API patterns. Include the following sections:\n\n1. **Overview** - Introduction to the IT Glue API and its JSON:API structure\n2. **Key Concepts** - Authentication, endpoints, request/response format\n3. **Field Reference** - Common fields and data types\n4. **API Patterns** - Detailed examples of:\n   - Authentication with x-api-key header\n   - Regional endpoints (US, EU, AU)\n   - JSON:API structure (data, attributes, relationships, included)\n   - Filtering with filter[field]=value syntax\n   - Sorting with sort=field,-field\n   - Pagination (page[size], page[number])\n   - Rate limiting (3000 req / 5 min)\n   - Sideloading related resources with include parameter\n5. **Workflows** - Common API interaction patterns\n6. **Error Handling** - Common errors and resolution steps\n7. **Best Practices** - Optimization and security considerations\n8. **Related Skills** - References to other IT Glue skills\n\nEnsure the skill includes proper frontmatter with description and triggers as specified in the PRD.",
        "testStrategy": "Review the skill document to ensure it contains all required sections. Validate API examples against the IT Glue API documentation at https://api.itglue.com/developer/. Verify that the triggers match those specified in the PRD.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Organizations skill",
        "description": "Create the Organizations skill for managing IT Glue organizations (companies/clients).",
        "details": "Create the organizations/SKILL.md file with comprehensive documentation on IT Glue organizations. Include the following sections:\n\n1. **Overview** - Introduction to organizations in IT Glue\n2. **Key Concepts** - Organization types, statuses, relationships\n3. **Field Reference** - Detailed description of fields:\n   - name, description, quick_notes\n   - organization_type_id, organization_status_id\n   - Parent/child relationships\n   - PSA sync configuration\n4. **API Patterns** - CRUD operations for organizations\n5. **Workflows** - Common organization management tasks\n6. **Error Handling** - Common errors and resolution steps\n7. **Best Practices** - Organization management best practices\n8. **Related Skills** - References to configurations, contacts skills\n\nEnsure the skill includes proper frontmatter with description and triggers: 'it glue organization', 'it glue company', 'client documentation', 'organization lookup'.",
        "testStrategy": "Review the skill document to ensure it contains all required sections. Validate API examples against the IT Glue API documentation. Verify that the triggers match those specified in the PRD.",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Configurations skill",
        "description": "Create the Configurations skill for managing configuration items (assets) in IT Glue.",
        "details": "Create the configurations/SKILL.md file with comprehensive documentation on IT Glue configurations. Include the following sections:\n\n1. **Overview** - Introduction to configurations (assets) in IT Glue\n2. **Key Concepts** - Configuration types, statuses, interfaces\n3. **Field Reference** - Detailed description of fields:\n   - name, hostname, primary_ip, mac_address, serial_number\n   - Configuration interfaces (network interfaces, IPs, MACs)\n   - Asset tagging and categorization\n   - Warranty tracking\n4. **API Patterns** - CRUD operations for configurations\n5. **Workflows** - Common asset management tasks\n6. **Error Handling** - Common errors and resolution steps\n7. **Best Practices** - Asset management best practices\n8. **Related Skills** - References to organizations, flexible-assets skills\n\nEnsure the skill includes proper frontmatter with description and triggers: 'it glue configuration', 'it glue asset', 'server documentation', 'workstation lookup', 'network device'.",
        "testStrategy": "Review the skill document to ensure it contains all required sections. Validate API examples against the IT Glue API documentation. Verify that the triggers match those specified in the PRD.",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Contacts skill",
        "description": "Create the Contacts skill for managing contacts associated with organizations in IT Glue.",
        "details": "Create the contacts/SKILL.md file with comprehensive documentation on IT Glue contacts. Include the following sections:\n\n1. **Overview** - Introduction to contacts in IT Glue\n2. **Key Concepts** - Contact types, organization relationships\n3. **Field Reference** - Detailed description of fields:\n   - name, title, email, phone, location\n   - Organization relationships\n   - Contact notes and quick notes\n4. **API Patterns** - CRUD operations for contacts\n5. **Workflows** - Common contact management tasks\n6. **Error Handling** - Common errors and resolution steps\n7. **Best Practices** - Contact management best practices\n8. **Related Skills** - References to organizations skill\n\nEnsure the skill includes proper frontmatter with description and triggers: 'it glue contact', 'client contact', 'technical contact', 'contact lookup'.",
        "testStrategy": "Review the skill document to ensure it contains all required sections. Validate API examples against the IT Glue API documentation. Verify that the triggers match those specified in the PRD.",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Passwords skill",
        "description": "Create the Passwords skill for managing passwords in IT Glue with security considerations.",
        "details": "Create the passwords/SKILL.md file with comprehensive documentation on IT Glue passwords. Include the following sections:\n\n1. **Overview** - Introduction to password management in IT Glue\n2. **Key Concepts** - Password categories, folders, security model\n3. **Field Reference** - Detailed description of fields:\n   - name, username, password, url, notes\n   - Password categories and folders\n   - Embedded passwords in documents\n4. **API Patterns** - CRUD operations for passwords with security considerations\n5. **Workflows** - Common password management tasks\n6. **Error Handling** - Common errors and resolution steps\n7. **Best Practices** - Security best practices, audit logging\n8. **Related Skills** - References to organizations, documents skills\n\nEnsure the skill includes proper frontmatter with description and triggers: 'it glue password', 'credential lookup', 'password management', 'secure credentials'.",
        "testStrategy": "Review the skill document to ensure it contains all required sections. Validate API examples against the IT Glue API documentation. Verify that the triggers match those specified in the PRD. Ensure security best practices are properly documented.",
        "priority": "high",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Documents skill",
        "description": "Create the Documents skill for managing documentation in IT Glue.",
        "details": "Create the documents/SKILL.md file with comprehensive documentation on IT Glue documents. Include the following sections:\n\n1. **Overview** - Introduction to documentation in IT Glue\n2. **Key Concepts** - Document structure, folders, organization\n3. **Field Reference** - Detailed description of fields:\n   - name, content, folder\n   - Document sections and formatting\n   - Version history\n   - Related items linking\n   - Embedded passwords\n4. **API Patterns** - CRUD operations for documents\n5. **Workflows** - Common document management tasks\n6. **Error Handling** - Common errors and resolution steps\n7. **Best Practices** - Documentation best practices\n8. **Related Skills** - References to organizations, passwords skills\n\nEnsure the skill includes proper frontmatter with description and triggers: 'it glue document', 'documentation', 'runbook', 'procedure documentation'.",
        "testStrategy": "Review the skill document to ensure it contains all required sections. Validate API examples against the IT Glue API documentation. Verify that the triggers match those specified in the PRD.",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Flexible Assets skill",
        "description": "Create the Flexible Assets skill for managing flexible assets (custom asset types) in IT Glue.",
        "details": "Create the flexible-assets/SKILL.md file with comprehensive documentation on IT Glue flexible assets. Include the following sections:\n\n1. **Overview** - Introduction to flexible assets in IT Glue\n2. **Key Concepts** - Flexible asset types, definitions, fields\n3. **Field Reference** - Detailed description of fields and types:\n   - text, number, date, tag, select, password, etc.\n   - Field types and configuration\n   - Cross-linking with configurations and organizations\n   - Common flexible asset examples (Network Overview, Application Documentation)\n4. **API Patterns** - CRUD operations for flexible assets and types\n5. **Workflows** - Common flexible asset management tasks\n6. **Error Handling** - Common errors and resolution steps\n7. **Best Practices** - Flexible asset design and management best practices\n8. **Related Skills** - References to organizations, configurations skills\n\nEnsure the skill includes proper frontmatter with description and triggers: 'it glue flexible asset', 'custom asset', 'flexible asset type', 'it glue custom documentation'.",
        "testStrategy": "Review the skill document to ensure it contains all required sections. Validate API examples against the IT Glue API documentation. Verify that the triggers match those specified in the PRD.",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement lookup-asset command",
        "description": "Create the lookup-asset command for finding configuration items by name, hostname, or serial number.",
        "details": "Create the commands/lookup-asset.md file with comprehensive documentation on the lookup-asset command. Include the following sections:\n\n1. **Prerequisites** - Required skills and API access\n2. **Steps** - Detailed steps for executing the command\n3. **Parameters** - Document all parameters:\n   - query (required): Asset name, hostname, serial number, or IP address\n   - organization (optional): Filter by organization name\n   - type (optional): Filter by configuration type\n4. **Examples** - Provide usage examples like:\n   ```\n   /lookup-asset \"DC-01\" --organization \"Acme Corp\"\n   ```\n5. **Output** - Describe the expected output format (asset details including hostname, IP, type, organization, location)\n6. **Error Handling** - Common errors and resolution steps\n\nEnsure the command includes proper frontmatter with name, description, and arguments as specified in the PRD.",
        "testStrategy": "Review the command document to ensure it contains all required sections. Verify that the parameters match those specified in the PRD. Test the command syntax against the IT Glue API documentation.",
        "priority": "medium",
        "dependencies": [
          1,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement search-docs command",
        "description": "Create the search-docs command for searching IT Glue documentation.",
        "details": "Create the commands/search-docs.md file with comprehensive documentation on the search-docs command. Include the following sections:\n\n1. **Prerequisites** - Required skills and API access\n2. **Steps** - Detailed steps for executing the command\n3. **Parameters** - Document all parameters:\n   - query (required): Search query\n   - organization (optional): Filter by organization\n   - type (optional): Filter by document type\n4. **Examples** - Provide usage examples like:\n   ```\n   /search-docs \"backup procedure\" --organization \"Acme Corp\"\n   ```\n5. **Output** - Describe the expected output format (list of matching documents with snippets)\n6. **Error Handling** - Common errors and resolution steps\n\nEnsure the command includes proper frontmatter with name, description, and arguments as specified in the PRD.",
        "testStrategy": "Review the command document to ensure it contains all required sections. Verify that the parameters match those specified in the PRD. Test the command syntax against the IT Glue API documentation.",
        "priority": "medium",
        "dependencies": [
          1,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement get-password command",
        "description": "Create the get-password command for retrieving passwords with security logging.",
        "details": "Create the commands/get-password.md file with comprehensive documentation on the get-password command. Include the following sections:\n\n1. **Prerequisites** - Required skills and API access\n2. **Steps** - Detailed steps for executing the command\n3. **Parameters** - Document all parameters:\n   - name (required): Password name or partial match\n   - organization (required): Organization name (required for security)\n   - category (optional): Password category filter\n4. **Examples** - Provide usage examples like:\n   ```\n   /get-password \"Domain Admin\" --organization \"Acme Corp\"\n   ```\n5. **Output** - Describe the expected output format (password details with masked password that can be revealed)\n6. **Error Handling** - Common errors and resolution steps\n\nEnsure the command includes proper frontmatter with name, description, and arguments as specified in the PRD. Include security considerations such as audit logging for password access.",
        "testStrategy": "Review the command document to ensure it contains all required sections. Verify that the parameters match those specified in the PRD. Test the command syntax against the IT Glue API documentation. Ensure security considerations are properly documented.",
        "priority": "high",
        "dependencies": [
          1,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement find-organization command",
        "description": "Create the find-organization command for finding organizations by name.",
        "details": "Create the commands/find-organization.md file with comprehensive documentation on the find-organization command. Include the following sections:\n\n1. **Prerequisites** - Required skills and API access\n2. **Steps** - Detailed steps for executing the command\n3. **Parameters** - Document all parameters:\n   - name (required): Organization name (partial match supported)\n   - type (optional): Filter by organization type\n4. **Examples** - Provide usage examples like:\n   ```\n   /find-organization \"Acme\"\n   ```\n5. **Output** - Describe the expected output format (organization details, contact count, asset count, status)\n6. **Error Handling** - Common errors and resolution steps\n\nEnsure the command includes proper frontmatter with name, description, and arguments as specified in the PRD.",
        "testStrategy": "Review the command document to ensure it contains all required sections. Verify that the parameters match those specified in the PRD. Test the command syntax against the IT Glue API documentation.",
        "priority": "medium",
        "dependencies": [
          1,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Create README.md with comprehensive documentation",
        "description": "Create a comprehensive README.md file for the IT Glue Claude Code Plugin.",
        "details": "Create the README.md file in the root directory with comprehensive documentation on the IT Glue Claude Code Plugin. Include the following sections:\n\n1. **Overview** - Introduction to the plugin and its purpose\n2. **Installation** - Instructions for installing and configuring the plugin\n3. **Skills** - Summary of all skills with links to their documentation\n4. **Commands** - Summary of all commands with links to their documentation\n5. **Configuration** - Details on configuring the plugin with IT Glue API keys\n6. **Security Considerations** - Security best practices for using the plugin\n7. **Development** - Information for developers contributing to the plugin\n8. **License** - License information\n\nEnsure the README includes clear instructions for setting up the plugin and configuring the IT Glue API integration.",
        "testStrategy": "Review the README to ensure it contains all required sections. Verify that the documentation is clear and comprehensive. Check for any broken links or references.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Update marketplace.json with IT Glue plugin entry",
        "description": "Update the marketplace.json file to include the IT Glue plugin in the MSP Claude Plugin Marketplace.",
        "details": "Update the marketplace.json file in the parent project (MSP Claude Plugin Marketplace) to include the IT Glue plugin. Add an entry with the following information:\n\n```json\n{\n  \"name\": \"kaseya-it-glue\",\n  \"displayName\": \"IT Glue\",\n  \"description\": \"Claude plugins for IT Glue documentation platform - organizations, assets, passwords, documents\",\n  \"vendor\": \"kaseya\",\n  \"version\": \"1.0.0\",\n  \"repository\": \"kaseya/it-glue\",\n  \"icon\": \"https://path-to-icon/it-glue-icon.png\",\n  \"tags\": [\"documentation\", \"msp\", \"it-glue\", \"kaseya\"],\n  \"skills\": 7,\n  \"commands\": 4\n}\n```\n\nEnsure the entry includes all required fields and accurately reflects the plugin's capabilities.",
        "testStrategy": "Validate the JSON syntax using a JSON linter. Verify that the entry includes all required fields and accurately reflects the plugin's capabilities.",
        "priority": "low",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-02-05T01:25:33.656Z",
      "updated": "2026-02-05T01:25:33.656Z",
      "description": "Tasks for it-glue-plugin context"
    }
  },
  "datto-rmm-plugin": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Plugin Directory Structure",
        "description": "Set up the initial directory structure for the Datto RMM Claude Code Plugin according to the specifications in the PRD.",
        "details": "Create the following directory structure:\n\n```\nkaseya/datto-rmm/\n .claude-plugin/\n    plugin.json\n .mcp.json\n README.md\n skills/\n    devices/\n       SKILL.md\n    alerts/\n       SKILL.md\n    sites/\n       SKILL.md\n    jobs/\n       SKILL.md\n    audit/\n       SKILL.md\n    variables/\n       SKILL.md\n    api-patterns/\n        SKILL.md\n commands/\n     device-lookup.md\n     resolve-alert.md\n     run-job.md\n     site-devices.md\n```\n\nEnsure all directories and placeholder files are created with appropriate permissions. This structure follows the standard Claude plugin architecture pattern.",
        "testStrategy": "Verify that all directories and files exist in the correct locations with appropriate permissions. Run a directory listing command to confirm the structure matches the PRD specification.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create Plugin Manifest and MCP Configuration",
        "description": "Create the plugin.json manifest and .mcp.json configuration files with the required content as specified in the PRD.",
        "details": "1. Create `.claude-plugin/plugin.json` with the following content:\n```json\n{\n  \"name\": \"kaseya-datto-rmm\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Claude plugins for Datto RMM - devices, alerts, sites, jobs, remote monitoring\",\n  \"author\": \"MSP Claude Plugins Community\",\n  \"vendor\": \"kaseya\",\n  \"product\": \"datto-rmm\",\n  \"api_version\": \"v2\",\n  \"requires_api_key\": true,\n  \"documentation_url\": \"https://rmm.datto.com/help/en/Content/2SETUP/APIv2.htm\",\n  \"skills\": [\n    \"devices\",\n    \"alerts\",\n    \"sites\",\n    \"jobs\",\n    \"audit\",\n    \"variables\",\n    \"api-patterns\"\n  ],\n  \"commands\": [\n    \"device-lookup\",\n    \"resolve-alert\",\n    \"run-job\",\n    \"site-devices\"\n  ]\n}\n```\n\n2. Create `.mcp.json` with the following content:\n```json\n{\n  \"mcpServers\": {\n    \"datto-rmm\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"datto-rmm-mcp\"],\n      \"env\": {\n        \"DATTO_API_KEY\": \"${DATTO_API_KEY}\",\n        \"DATTO_API_SECRET\": \"${DATTO_API_SECRET}\",\n        \"DATTO_PLATFORM\": \"${DATTO_PLATFORM:-merlot}\"\n      }\n    }\n  }\n}\n```\n\nEnsure both files are properly formatted JSON and contain all required fields. The configuration should use environment variables for credentials, not hardcoded values.",
        "testStrategy": "Validate both JSON files using a JSON validator to ensure they are well-formed. Verify that all required fields are present and correctly formatted. Check that no credentials are hardcoded in the configuration files.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement API Patterns Skill",
        "description": "Create the API Patterns skill documentation that serves as the foundation for all Datto RMM API interactions.",
        "details": "Create `skills/api-patterns/SKILL.md` with comprehensive documentation on Datto RMM API patterns including:\n\n1. **Overview** - Introduction to the Datto RMM API and its role in the plugin\n2. **Key Concepts**:\n   - OAuth 2.0 authentication flow\n   - Platform-specific base URLs for all 6 platforms (Pinotage, Merlot, Concord, Vidal, Zinfandel, Syrah)\n   - Token lifecycle (100-hour expiry, refresh mechanism)\n   - Rate limiting (600 req/60s, IP blocking)\n\n3. **Field Reference**:\n   - Common API response structures\n   - Pagination parameters (250 max per page, nextPageUrl)\n   - Timestamp handling (Unix milliseconds)\n\n4. **API Patterns**:\n   - Authentication request format\n   - Standard GET/POST/PUT/DELETE patterns\n   - Error handling (401, 403, 404, 429)\n   - Common query parameters\n\n5. **Workflows**:\n   - Initial authentication\n   - Token refresh\n   - Handling rate limits\n   - Pagination through large result sets\n\n6. **Error Handling**:\n   - Common error codes and their meanings\n   - Strategies for handling API failures\n\n7. **Best Practices**:\n   - Caching strategies\n   - Efficient API usage\n   - Security considerations\n\n8. **Related Skills**:\n   - Links to all other skills that build on these patterns\n\nInclude appropriate frontmatter with description and triggers (\"datto api\", \"rmm api\", \"datto authentication\", \"rmm query\").",
        "testStrategy": "Review the SKILL.md file to ensure it contains all required sections. Validate that the API patterns described match the Datto RMM API documentation. Check that all 6 platforms are correctly documented with their base URLs. Verify that the authentication flow, rate limiting, and pagination are accurately described.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Devices Skill",
        "description": "Create the Devices skill documentation for managing devices in Datto RMM.",
        "details": "Create `skills/devices/SKILL.md` with comprehensive documentation on Datto RMM device management including:\n\n1. **Overview** - Introduction to device management in Datto RMM\n2. **Key Concepts**:\n   - Device identifiers (deviceUid, deviceId, hostname, MAC address)\n   - Device types (Workstation, Server, ESXi Host, Network Device)\n   - Device statuses (Online, Offline, Rebooting)\n   - Operating system information\n\n3. **Field Reference**:\n   - Complete device object structure\n   - Last seen / last reboot timestamps\n   - User-defined fields (UDF1-UDF30)\n   - Warranty information\n   - Site assignment\n\n4. **API Patterns**:\n   - Retrieving device information\n   - Searching for devices\n   - Updating device properties\n   - Device operations (reboot, shutdown)\n\n5. **Workflows**:\n   - Finding devices by various identifiers\n   - Managing device properties\n   - Device lifecycle management\n\n6. **Error Handling**:\n   - Common device-related errors\n   - Handling missing devices\n\n7. **Best Practices**:\n   - Efficient device lookup\n   - Device naming conventions\n   - UDF usage recommendations\n\n8. **Related Skills**:\n   - Links to alerts, sites, jobs, and audit skills\n\nInclude appropriate frontmatter with description and triggers (\"datto device\", \"rmm device\", \"device status\", \"device lookup\", \"managed device\").",
        "testStrategy": "Review the SKILL.md file to ensure it contains all required sections. Validate that the device management concepts and API patterns match the Datto RMM documentation. Check that all device types, statuses, and fields are accurately described. Verify that the workflows cover common device management scenarios.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Alerts Skill with Context Types",
        "description": "Create the Alerts skill documentation for managing and responding to RMM alerts, including all 25+ alert context types.",
        "details": "Create `skills/alerts/SKILL.md` with comprehensive documentation on Datto RMM alerts including:\n\n1. **Overview** - Introduction to alerts in Datto RMM\n2. **Key Concepts**:\n   - Alert structure (alertUid, priority, timestamp, context)\n   - Alert priorities and severity mapping\n   - Open vs resolved alerts\n   - Alert resolution workflow\n   - Muting alerts (deprecated)\n\n3. **Field Reference**:\n   - Complete alert object structure\n   - Detailed documentation of all 25+ alert context types with TypeScript-style definitions:\n\n```typescript\n// Document all context types including but not limited to:\ntype AntivirusContext = {\n  '@class': 'antivirus_ctx',\n  status: string,\n  product: string,\n  lastScan: number // Unix timestamp\n}\n\ntype ComponentScriptContext = {\n  '@class': 'comp_script_ctx',\n  exitCode: number,\n  stdout: string,\n  stderr: string\n}\n\n// Continue with all 25+ context types from the PRD\n```\n\n4. **API Patterns**:\n   - Retrieving alerts\n   - Filtering alerts\n   - Resolving alerts\n   - Alert notifications\n\n5. **Workflows**:\n   - Alert triage process\n   - Alert resolution\n   - Alert reporting\n\n6. **Error Handling**:\n   - Common alert-related errors\n   - Handling missing alerts\n\n7. **Best Practices**:\n   - Alert prioritization\n   - Resolution documentation\n   - Alert automation\n\n8. **Related Skills**:\n   - Links to devices, sites, jobs skills\n\nInclude appropriate frontmatter with description and triggers (\"datto alert\", \"rmm alert\", \"device alert\", \"alert resolution\", \"monitoring alert\").\n\nEnsure all 25+ alert context types from the PRD are fully documented with their structure and key fields.",
        "testStrategy": "Review the SKILL.md file to ensure it contains all required sections. Validate that all 25+ alert context types are documented with TypeScript-style definitions. Check that the alert management concepts and API patterns match the Datto RMM documentation. Verify that the workflows cover common alert management scenarios.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Sites, Jobs, Audit, and Variables Skills",
        "description": "Create the remaining core skills documentation for Sites, Jobs, Audit, and Variables in Datto RMM.",
        "details": "Create the following skill documentation files:\n\n1. **Sites Skill** (`skills/sites/SKILL.md`):\n   - Overview of site management in Datto RMM\n   - Key concepts: site structure, settings, proxy settings, site variables\n   - Field reference for site objects\n   - API patterns for site management\n   - Workflows for site operations\n   - Error handling and best practices\n   - Triggers: \"datto site\", \"rmm site\", \"client site\", \"site management\", \"location management\"\n\n2. **Jobs Skill** (`skills/jobs/SKILL.md`):\n   - Overview of job management in Datto RMM\n   - Key concepts: job types, structure, statuses, component scripts\n   - Field reference for job objects\n   - API patterns for job operations\n   - Workflows for running and monitoring jobs\n   - Error handling and best practices\n   - Triggers: \"datto job\", \"rmm job\", \"quick job\", \"run script\", \"component job\"\n\n3. **Audit Skill** (`skills/audit/SKILL.md`):\n   - Overview of device audit information in Datto RMM\n   - Key concepts: hardware/software inventory, network interfaces\n   - Field reference for audit data objects\n   - API patterns for audit data retrieval\n   - Workflows for accessing audit information\n   - Error handling and best practices\n   - Triggers: \"datto audit\", \"device audit\", \"software inventory\", \"hardware inventory\", \"system audit\"\n\n4. **Variables Skill** (`skills/variables/SKILL.md`):\n   - Overview of variable management in Datto RMM\n   - Key concepts: account-level vs site-level variables\n   - Field reference for variable objects\n   - API patterns for variable operations\n   - Workflows for using variables in jobs/scripts\n   - Error handling and best practices\n   - Triggers: \"datto variable\", \"rmm variable\", \"account variable\", \"site variable\", \"script variable\"\n\nEnsure each skill document follows the standard structure with Overview, Key Concepts, Field Reference, API Patterns, Workflows, Error Handling, Best Practices, and Related Skills sections.",
        "testStrategy": "Review each SKILL.md file to ensure it contains all required sections. Validate that the concepts and API patterns match the Datto RMM documentation. Check that the field references are complete and accurate. Verify that the workflows cover common scenarios for each skill area.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement device-lookup Command",
        "description": "Create the device-lookup command documentation for finding devices by hostname, IP, or MAC address.",
        "details": "Create `commands/device-lookup.md` with comprehensive documentation on the device-lookup command including:\n\n1. **Command Name**: device-lookup\n2. **Description**: Find a device by hostname, IP address, or MAC address\n3. **Prerequisites**:\n   - Authenticated Datto RMM API connection\n   - Appropriate permissions to view devices\n\n4. **Arguments**:\n\n| Argument | Required | Description |\n|----------|----------|-------------|\n| identifier | Yes | Hostname, IP address, or MAC address |\n| site | No | Filter by site name |\n\n5. **Steps**:\n   - Detailed algorithm for how the command searches for devices\n   - Logic for handling different identifier types\n   - Site filtering process\n\n6. **Examples**:\n```\n/device-lookup \"ACME-DC01\"\n/device-lookup \"192.168.1.100\"\n/device-lookup \"00:1A:2B:3C:4D:5E\"\n/device-lookup \"ACME-DC01\" --site \"Acme Corp HQ\"\n```\n\n7. **Output**:\n   - Format and structure of the command output\n   - Device details included (status, OS, last seen, site, alerts)\n   - Sample output JSON/text\n\n8. **Error Handling**:\n   - Common error scenarios\n   - Error messages and troubleshooting\n\nEnsure the command documentation includes proper frontmatter and follows the standard structure for Claude plugin commands.",
        "testStrategy": "Review the command documentation to ensure it contains all required sections. Validate that the arguments, examples, and output descriptions match the PRD specifications. Check that the error handling covers common failure scenarios. Test the command syntax examples for correctness.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement resolve-alert Command",
        "description": "Create the resolve-alert command documentation for resolving open alerts in Datto RMM.",
        "details": "Create `commands/resolve-alert.md` with comprehensive documentation on the resolve-alert command including:\n\n1. **Command Name**: resolve-alert\n2. **Description**: Resolve an open alert in Datto RMM\n3. **Prerequisites**:\n   - Authenticated Datto RMM API connection\n   - Appropriate permissions to resolve alerts\n\n4. **Arguments**:\n\n| Argument | Required | Description |\n|----------|----------|-------------|\n| alert-id | Yes | Alert UID or partial match from device name |\n| note | No | Resolution note |\n\n5. **Steps**:\n   - Detailed algorithm for how the command identifies the alert\n   - Process for resolving the alert\n   - Note handling\n\n6. **Examples**:\n```\n/resolve-alert \"alert-uid-12345\"\n/resolve-alert \"ACME-DC01\" --note \"Disk space cleared\"\n```\n\n7. **Output**:\n   - Format and structure of the command output\n   - Confirmation details\n   - Sample output JSON/text\n\n8. **Error Handling**:\n   - Common error scenarios\n   - Error messages and troubleshooting\n\nEnsure the command documentation includes proper frontmatter and follows the standard structure for Claude plugin commands.",
        "testStrategy": "Review the command documentation to ensure it contains all required sections. Validate that the arguments, examples, and output descriptions match the PRD specifications. Check that the error handling covers common failure scenarios. Test the command syntax examples for correctness.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement run-job and site-devices Commands",
        "description": "Create the run-job and site-devices command documentation for running quick jobs and listing devices at a site.",
        "details": "Create the following command documentation files:\n\n1. **run-job Command** (`commands/run-job.md`):\n   - Command Name: run-job\n   - Description: Run a quick job on a device\n   - Prerequisites: API connection and permissions\n   - Arguments:\n\n   | Argument | Required | Description |\n   |----------|----------|-------------|\n   | device | Yes | Device hostname or UID |\n   | component | Yes | Component script UID or name |\n   | variables | No | Job variables as key=value pairs |\n\n   - Steps for job execution\n   - Examples:\n   ```\n   /run-job \"ACME-DC01\" \"Clear Temp Files\" --variables \"days=30,path=C:\\\\Temp\"\n   ```\n   - Output format and sample\n   - Error handling\n\n2. **site-devices Command** (`commands/site-devices.md`):\n   - Command Name: site-devices\n   - Description: List devices at a site\n   - Prerequisites: API connection and permissions\n   - Arguments:\n\n   | Argument | Required | Description |\n   |----------|----------|-------------|\n   | site | Yes | Site name or UID |\n   | status | No | Filter by status (online, offline, all) |\n   | type | No | Filter by device type |\n\n   - Steps for retrieving and filtering devices\n   - Examples:\n   ```\n   /site-devices \"Acme Corp\" --status online\n   /site-devices \"Acme Corp\" --type server\n   ```\n   - Output format and sample\n   - Error handling\n\nEnsure both command documentation files include proper frontmatter and follow the standard structure for Claude plugin commands.",
        "testStrategy": "Review both command documentation files to ensure they contain all required sections. Validate that the arguments, examples, and output descriptions match the PRD specifications. Check that the error handling covers common failure scenarios. Test the command syntax examples for correctness.",
        "priority": "medium",
        "dependencies": [
          4,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Create README and Update Marketplace Entry",
        "description": "Create a comprehensive README.md for the plugin and update the marketplace.json with the new plugin entry.",
        "details": "1. Create `README.md` with the following sections:\n   - Plugin Name and Description\n   - Installation Instructions\n   - Configuration Requirements\n   - Available Skills (with brief descriptions)\n   - Available Commands (with brief syntax)\n   - Authentication Setup\n   - Platform Support (all 6 Datto RMM platforms)\n   - Troubleshooting\n   - Examples\n   - Contributing Guidelines\n   - License Information\n\n2. Update the marketplace.json file to include the Datto RMM plugin entry:\n```json\n{\n  \"plugins\": [\n    // ... existing plugins ...\n    {\n      \"name\": \"kaseya-datto-rmm\",\n      \"displayName\": \"Datto RMM\",\n      \"description\": \"Claude plugins for Datto RMM - devices, alerts, sites, jobs, remote monitoring\",\n      \"vendor\": \"kaseya\",\n      \"repository\": \"kaseya/datto-rmm\",\n      \"version\": \"1.0.0\",\n      \"icon\": \"https://path-to-icon/datto-rmm-icon.png\",\n      \"tags\": [\"rmm\", \"monitoring\", \"msp\", \"datto\", \"kaseya\"],\n      \"skills\": 7,\n      \"commands\": 4\n    }\n  ]\n}\n```\n\nEnsure the README provides clear instructions for installation and configuration. Include examples of how to use the plugin's skills and commands effectively.",
        "testStrategy": "Review the README.md to ensure it contains all required sections and provides comprehensive information about the plugin. Validate that the marketplace.json entry contains all required fields and matches the plugin information. Check that the installation and configuration instructions are clear and accurate.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Validate Plugin Against Acceptance Criteria",
        "description": "Perform a comprehensive validation of the plugin against all acceptance criteria specified in the PRD.",
        "details": "Validate the plugin against the following acceptance criteria:\n\n1. All 7 skills exist with proper frontmatter (description, triggers)\n2. All 4 commands exist with proper frontmatter (name, description, arguments)\n3. Each skill contains: Overview, Key Concepts, Field Reference, API Patterns, Workflows, Error Handling, Best Practices, Related Skills\n4. Each command contains: Prerequisites, Steps, Parameters, Examples, Output, Error Handling\n5. Alerts skill documents all 25+ alert context types with TypeScript-style definitions\n6. plugin.json correctly references all skills and commands\n7. .mcp.json is configured for datto-rmm-mcp server with platform support\n8. No hardcoded credentials in any file\n9. API examples validated against Datto RMM documentation\n10. Marketplace.json updated with datto-rmm plugin entry\n\nCreate a validation report documenting compliance with each criterion. For any issues found, document the specific problem and recommended fix.",
        "testStrategy": "Create a checklist based on the acceptance criteria and systematically verify each item. Use automated tools where possible to validate JSON files and check for hardcoded credentials. Have multiple reviewers independently validate the plugin against the criteria to ensure thoroughness.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-02-05T01:27:04.013Z",
      "updated": "2026-02-05T01:27:04.013Z",
      "description": "Tasks for datto-rmm-plugin context"
    }
  },
  "node-syncro": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up project structure and core configuration",
        "description": "Create the initial project structure, package.json, tsconfig.json, and core configuration files according to the PRD specifications.",
        "details": "1. Initialize a new TypeScript project with `npm init -y`\n2. Install required dependencies:\n   ```bash\n   npm install typescript tsup vitest @types/node\n   ```\n3. Create tsconfig.json with ESM and CJS compatibility:\n   ```json\n   {\n     \"compilerOptions\": {\n       \"target\": \"ES2020\",\n       \"module\": \"ESNext\",\n       \"moduleResolution\": \"node\",\n       \"esModuleInterop\": true,\n       \"strict\": true,\n       \"declaration\": true,\n       \"outDir\": \"./dist\",\n       \"rootDir\": \"./src\"\n     },\n     \"include\": [\"src/**/*\"],\n     \"exclude\": [\"node_modules\", \"dist\"]\n   }\n   ```\n4. Set up the project structure according to the PRD:\n   - Create src/ directory with index.ts, client.ts, config.ts, errors.ts, http.ts, pagination.ts, rate-limiter.ts\n   - Create src/types/ directory with index.ts and common.ts\n   - Create src/resources/ directory\n   - Create tests/ directory with setup.ts and subdirectories for fixtures, mocks, unit, and integration\n5. Configure tsup for building:\n   ```javascript\n   // tsup.config.js\n   export default {\n     entry: ['src/index.ts'],\n     format: ['cjs', 'esm'],\n     dts: true,\n     clean: true,\n     sourcemap: true\n   };\n   ```\n6. Set up package.json scripts:\n   ```json\n   \"scripts\": {\n     \"build\": \"tsup\",\n     \"test\": \"vitest run\",\n     \"test:watch\": \"vitest\",\n     \"test:coverage\": \"vitest run --coverage\"\n   }\n   ```",
        "testStrategy": "1. Verify project structure matches PRD requirements\n2. Ensure all directories and initial files are created\n3. Validate package.json has correct dependencies and scripts\n4. Confirm tsconfig.json has proper settings for ESM/CJS compatibility\n5. Test build process produces both ESM and CJS outputs with type definitions",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement error handling classes",
        "description": "Create custom error classes for handling different types of API errors as specified in the PRD.",
        "details": "Create src/errors.ts with the following error classes:\n\n```typescript\nexport class SyncroError extends Error {\n  statusCode: number;\n  response: any;\n\n  constructor(message: string, statusCode: number, response?: any) {\n    super(message);\n    this.name = 'SyncroError';\n    this.statusCode = statusCode;\n    this.response = response;\n    Object.setPrototypeOf(this, SyncroError.prototype);\n  }\n}\n\nexport class SyncroAuthenticationError extends SyncroError {\n  constructor(message: string, statusCode: number, response?: any) {\n    super(message, statusCode, response);\n    this.name = 'SyncroAuthenticationError';\n    Object.setPrototypeOf(this, SyncroAuthenticationError.prototype);\n  }\n}\n\nexport class SyncroNotFoundError extends SyncroError {\n  constructor(message: string, response?: any) {\n    super(message, 404, response);\n    this.name = 'SyncroNotFoundError';\n    Object.setPrototypeOf(this, SyncroNotFoundError.prototype);\n  }\n}\n\nexport class SyncroValidationError extends SyncroError {\n  errors: Array<{ field: string; message: string }>;\n\n  constructor(message: string, errors: Array<{ field: string; message: string }>, response?: any) {\n    super(message, 422, response);\n    this.name = 'SyncroValidationError';\n    this.errors = errors;\n    Object.setPrototypeOf(this, SyncroValidationError.prototype);\n  }\n}\n\nexport class SyncroRateLimitError extends SyncroError {\n  constructor(message: string, response?: any) {\n    super(message, 429, response);\n    this.name = 'SyncroRateLimitError';\n    Object.setPrototypeOf(this, SyncroRateLimitError.prototype);\n  }\n}\n\nexport class SyncroServerError extends SyncroError {\n  constructor(message: string, statusCode: number, response?: any) {\n    super(message, statusCode, response);\n    this.name = 'SyncroServerError';\n    Object.setPrototypeOf(this, SyncroServerError.prototype);\n  }\n}\n\nexport function handleApiError(error: any): never {\n  if (error.response) {\n    const { status, data } = error.response;\n    \n    if (status === 401 || status === 403) {\n      throw new SyncroAuthenticationError(\n        status === 401 ? 'Invalid API key' : 'Insufficient permissions',\n        status,\n        data\n      );\n    }\n    \n    if (status === 404) {\n      throw new SyncroNotFoundError('Resource not found', data);\n    }\n    \n    if (status === 422) {\n      const validationErrors = Array.isArray(data.errors) \n        ? data.errors \n        : Object.entries(data.errors || {}).map(([field, message]) => ({ field, message: String(message) }));\n      \n      throw new SyncroValidationError('Validation failed', validationErrors, data);\n    }\n    \n    if (status === 429) {\n      throw new SyncroRateLimitError('Rate limit exceeded', data);\n    }\n    \n    if (status >= 500) {\n      throw new SyncroServerError('Server error', status, data);\n    }\n    \n    throw new SyncroError(`API error: ${status}`, status, data);\n  }\n  \n  throw error;\n}\n```\n\nExport all error classes in src/index.ts.",
        "testStrategy": "1. Create unit tests for each error class in tests/unit/errors.test.ts\n2. Test error instantiation with different parameters\n3. Test error inheritance hierarchy\n4. Test handleApiError function with various response scenarios:\n   - 401/403 responses should throw SyncroAuthenticationError\n   - 404 responses should throw SyncroNotFoundError\n   - 422 responses should throw SyncroValidationError with parsed errors\n   - 429 responses should throw SyncroRateLimitError\n   - 500+ responses should throw SyncroServerError\n   - Other status codes should throw generic SyncroError",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement configuration and client initialization",
        "description": "Create configuration types and the SyncroClient class with initialization logic for API key authentication and base URL construction.",
        "details": "1. Create src/config.ts with configuration types:\n\n```typescript\nexport interface SyncroClientConfig {\n  apiKey: string;\n  subdomain?: string;\n  baseUrl?: string;\n  rateLimiting?: RateLimitConfig;\n}\n\nexport interface RateLimitConfig {\n  enabled: boolean;\n  maxRequests: number;\n  windowMs: number;\n  throttleThreshold: number;\n  retryAfterMs: number;\n  maxRetries: number;\n}\n\nexport const DEFAULT_RATE_LIMIT_CONFIG: RateLimitConfig = {\n  enabled: true,\n  maxRequests: 180,\n  windowMs: 60000, // 1 minute\n  throttleThreshold: 0.8, // 80%\n  retryAfterMs: 5000,\n  maxRetries: 3\n};\n```\n\n2. Create src/client.ts with the SyncroClient class:\n\n```typescript\nimport { SyncroClientConfig, DEFAULT_RATE_LIMIT_CONFIG } from './config';\nimport { SyncroAuthenticationError } from './errors';\n\nexport class SyncroClient {\n  private readonly apiKey: string;\n  private readonly baseUrl: string;\n  private readonly config: SyncroClientConfig;\n\n  constructor(config: SyncroClientConfig) {\n    if (!config.apiKey) {\n      throw new SyncroAuthenticationError('API key is required', 401);\n    }\n\n    this.apiKey = config.apiKey;\n    this.config = {\n      ...config,\n      rateLimiting: {\n        ...DEFAULT_RATE_LIMIT_CONFIG,\n        ...config.rateLimiting\n      }\n    };\n\n    // Determine base URL\n    if (config.baseUrl) {\n      this.baseUrl = config.baseUrl.endsWith('/') \n        ? config.baseUrl.slice(0, -1) \n        : config.baseUrl;\n    } else if (config.subdomain) {\n      this.baseUrl = `https://${config.subdomain}.syncromsp.com`;\n    } else {\n      throw new Error('Either baseUrl or subdomain must be provided');\n    }\n\n    // Initialize resource classes\n    // These will be added in subsequent tasks\n  }\n\n  // Helper method to get API URL with path\n  getApiUrl(path: string): string {\n    const normalizedPath = path.startsWith('/') ? path : `/${path}`;\n    return `${this.baseUrl}/api/v1${normalizedPath}`;\n  }\n\n  // Helper method to add API key to query parameters\n  addApiKey(url: URL): URL {\n    url.searchParams.append('api_key', this.apiKey);\n    return url;\n  }\n}\n```\n\n3. Export the client and configuration types in src/index.ts:\n\n```typescript\nexport { SyncroClient } from './client';\nexport { SyncroClientConfig, RateLimitConfig } from './config';\nexport * from './errors';\n```",
        "testStrategy": "1. Create unit tests in tests/unit/client.test.ts\n2. Test client initialization with various configuration options:\n   - With apiKey and subdomain\n   - With apiKey and baseUrl\n   - With missing apiKey (should throw)\n   - With neither subdomain nor baseUrl (should throw)\n3. Test URL construction methods:\n   - getApiUrl should correctly format API paths\n   - addApiKey should append the API key as a query parameter\n4. Test default rate limiting configuration is applied correctly",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement HTTP layer with fetch wrapper",
        "description": "Create a HTTP client wrapper that handles API requests, authentication, and response parsing.",
        "details": "Create src/http.ts with the following implementation:\n\n```typescript\nimport { SyncroClientConfig } from './config';\nimport { handleApiError } from './errors';\n\nexport interface RequestOptions {\n  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  params?: Record<string, string | number | boolean | undefined>;\n  data?: any;\n  headers?: Record<string, string>;\n}\n\nexport class HttpClient {\n  private readonly apiKey: string;\n  private readonly baseUrl: string;\n\n  constructor(config: SyncroClientConfig) {\n    this.apiKey = config.apiKey;\n    this.baseUrl = config.baseUrl || `https://${config.subdomain}.syncromsp.com`;\n  }\n\n  async request<T>(path: string, options: RequestOptions = {}): Promise<T> {\n    const url = new URL(`${this.baseUrl}/api/v1${path.startsWith('/') ? path : `/${path}`}`);\n    \n    // Add API key to query parameters\n    url.searchParams.append('api_key', this.apiKey);\n    \n    // Add other query parameters\n    if (options.params) {\n      for (const [key, value] of Object.entries(options.params)) {\n        if (value !== undefined) {\n          url.searchParams.append(key, String(value));\n        }\n      }\n    }\n    \n    // Prepare request options\n    const fetchOptions: RequestInit = {\n      method: options.method || 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n        ...options.headers\n      }\n    };\n    \n    // Add request body for POST/PUT requests\n    if (options.data && (options.method === 'POST' || options.method === 'PUT')) {\n      fetchOptions.body = JSON.stringify(options.data);\n    }\n    \n    try {\n      const response = await fetch(url.toString(), fetchOptions);\n      \n      // Handle non-JSON responses\n      const contentType = response.headers.get('content-type');\n      if (contentType && !contentType.includes('application/json')) {\n        if (!response.ok) {\n          throw {\n            response: {\n              status: response.status,\n              data: await response.text()\n            }\n          };\n        }\n        return await response.text() as unknown as T;\n      }\n      \n      // Parse JSON response\n      const data = await response.json();\n      \n      // Handle error responses\n      if (!response.ok) {\n        throw {\n          response: {\n            status: response.status,\n            data\n          }\n        };\n      }\n      \n      return data as T;\n    } catch (error) {\n      if (error && typeof error === 'object' && 'response' in error) {\n        return handleApiError(error);\n      }\n      throw error;\n    }\n  }\n  \n  // Convenience methods\n  async get<T>(path: string, params?: Record<string, string | number | boolean | undefined>): Promise<T> {\n    return this.request<T>(path, { method: 'GET', params });\n  }\n  \n  async post<T>(path: string, data?: any, params?: Record<string, string | number | boolean | undefined>): Promise<T> {\n    return this.request<T>(path, { method: 'POST', data, params });\n  }\n  \n  async put<T>(path: string, data?: any, params?: Record<string, string | number | boolean | undefined>): Promise<T> {\n    return this.request<T>(path, { method: 'PUT', data, params });\n  }\n  \n  async delete<T>(path: string, params?: Record<string, string | number | boolean | undefined>): Promise<T> {\n    return this.request<T>(path, { method: 'DELETE', params });\n  }\n}\n```\n\nUpdate the SyncroClient class in src/client.ts to use the HttpClient:\n\n```typescript\nimport { HttpClient } from './http';\n\nexport class SyncroClient {\n  private readonly http: HttpClient;\n  // ... existing code ...\n\n  constructor(config: SyncroClientConfig) {\n    // ... existing initialization code ...\n    \n    // Initialize HTTP client\n    this.http = new HttpClient(this.config);\n  }\n  \n  // ... existing methods ...\n}\n```",
        "testStrategy": "1. Create unit tests in tests/unit/http.test.ts\n2. Test request method with various options:\n   - GET requests with different query parameters\n   - POST/PUT requests with request bodies\n   - DELETE requests\n3. Test API key is correctly added to all requests\n4. Test error handling for different HTTP status codes\n5. Test convenience methods (get, post, put, delete)\n6. Mock fetch responses using vitest's mocking capabilities",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement rate limiting functionality",
        "description": "Create a rate limiter that prevents exceeding Syncro's 180 requests per minute limit with throttling and backoff capabilities.",
        "details": "Create src/rate-limiter.ts with the following implementation:\n\n```typescript\nimport { RateLimitConfig, DEFAULT_RATE_LIMIT_CONFIG } from './config';\n\nexport class RateLimiter {\n  private readonly config: RateLimitConfig;\n  private requestTimestamps: number[] = [];\n  private isThrottled = false;\n\n  constructor(config?: Partial<RateLimitConfig>) {\n    this.config = {\n      ...DEFAULT_RATE_LIMIT_CONFIG,\n      ...config\n    };\n  }\n\n  /**\n   * Check if we should throttle the next request\n   */\n  shouldThrottle(): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n\n    this.cleanupOldRequests();\n    return this.requestTimestamps.length >= this.config.maxRequests * this.config.throttleThreshold;\n  }\n\n  /**\n   * Record a request and check if we're over the limit\n   */\n  recordRequest(): boolean {\n    if (!this.config.enabled) {\n      return false;\n    }\n\n    const now = Date.now();\n    this.requestTimestamps.push(now);\n    this.cleanupOldRequests();\n\n    return this.requestTimestamps.length > this.config.maxRequests;\n  }\n\n  /**\n   * Wait before making the next request if needed\n   */\n  async throttle(): Promise<void> {\n    if (!this.config.enabled || !this.shouldThrottle()) {\n      return;\n    }\n\n    this.isThrottled = true;\n    \n    // Calculate delay based on how close we are to the limit\n    const requestCount = this.requestTimestamps.length;\n    const ratio = requestCount / this.config.maxRequests;\n    const delay = Math.ceil(this.config.retryAfterMs * ratio);\n    \n    await new Promise(resolve => setTimeout(resolve, delay));\n    this.isThrottled = false;\n  }\n\n  /**\n   * Calculate backoff time for retries\n   */\n  getBackoffTime(retryCount: number): number {\n    return Math.min(\n      this.config.retryAfterMs * Math.pow(2, retryCount),\n      30000 // Max 30 seconds\n    );\n  }\n\n  /**\n   * Remove timestamps older than the window\n   */\n  private cleanupOldRequests(): void {\n    const cutoff = Date.now() - this.config.windowMs;\n    this.requestTimestamps = this.requestTimestamps.filter(timestamp => timestamp >= cutoff);\n  }\n\n  /**\n   * Get current request count in the window\n   */\n  getRequestCount(): number {\n    this.cleanupOldRequests();\n    return this.requestTimestamps.length;\n  }\n\n  /**\n   * Check if currently throttled\n   */\n  isCurrentlyThrottled(): boolean {\n    return this.isThrottled;\n  }\n}\n```\n\nUpdate the HttpClient class in src/http.ts to use the RateLimiter:\n\n```typescript\nimport { RateLimiter } from './rate-limiter';\n\nexport class HttpClient {\n  private readonly rateLimiter: RateLimiter;\n  // ... existing properties ...\n\n  constructor(config: SyncroClientConfig) {\n    // ... existing initialization ...\n    this.rateLimiter = new RateLimiter(config.rateLimiting);\n  }\n\n  async request<T>(path: string, options: RequestOptions = {}): Promise<T> {\n    // Wait if we're approaching the rate limit\n    await this.rateLimiter.throttle();\n    \n    let retries = 0;\n    const maxRetries = this.config.rateLimiting?.maxRetries || DEFAULT_RATE_LIMIT_CONFIG.maxRetries;\n    \n    while (true) {\n      try {\n        // ... existing request code ...\n        \n        // Record the request after it's made\n        this.rateLimiter.recordRequest();\n        \n        // ... existing response handling ...\n      } catch (error) {\n        // Handle rate limit errors with retry\n        if (error && typeof error === 'object' && 'response' in error && \n            error.response?.status === 429 && retries < maxRetries) {\n          \n          retries++;\n          const backoffTime = this.rateLimiter.getBackoffTime(retries);\n          await new Promise(resolve => setTimeout(resolve, backoffTime));\n          continue;\n        }\n        \n        // Handle other errors\n        return handleApiError(error);\n      }\n    }\n  }\n  \n  // ... existing methods ...\n}\n```",
        "testStrategy": "1. Create unit tests in tests/unit/rate-limiter.test.ts\n2. Test rate limiter initialization with different configurations\n3. Test request counting and window cleanup\n4. Test throttling behavior when approaching limits\n5. Test backoff time calculation for different retry counts\n6. Test integration with HttpClient:\n   - Verify requests are delayed when approaching the limit\n   - Verify 429 responses trigger retries with exponential backoff\n   - Test disabling rate limiting works correctly",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement pagination utilities",
        "description": "Create pagination utilities that handle Syncro's page-based pagination with automatic iteration through all pages.",
        "details": "Create src/pagination.ts with the following implementation:\n\n```typescript\nimport { HttpClient } from './http';\n\nexport interface PaginationParams {\n  page?: number;\n  perPage?: number;\n  [key: string]: any;\n}\n\nexport interface PaginationMeta {\n  total_pages: number;\n  total_entries: number;\n  per_page: number;\n  page: number;\n}\n\nexport interface PaginatedResponse<T> {\n  [key: string]: T[] | PaginationMeta;\n  meta: PaginationMeta;\n}\n\nexport class PaginatedResults<T> implements AsyncIterable<T> {\n  private http: HttpClient;\n  private path: string;\n  private params: PaginationParams;\n  private resourceName: string;\n  private fetchedPages: Set<number> = new Set();\n  private allItems: T[] = [];\n  private meta?: PaginationMeta;\n\n  constructor(\n    http: HttpClient,\n    path: string,\n    params: PaginationParams = {},\n    resourceName: string\n  ) {\n    this.http = http;\n    this.path = path;\n    this.params = {\n      ...params,\n      page: params.page || 1,\n      perPage: params.perPage || 25\n    };\n    this.resourceName = resourceName;\n  }\n\n  /**\n   * Fetch a specific page of results\n   */\n  async getPage(page: number): Promise<PaginatedResponse<T>> {\n    const params = { ...this.params, page };\n    \n    // Convert perPage to per_page for API compatibility\n    if (params.perPage) {\n      params.per_page = params.perPage;\n      delete params.perPage;\n    }\n    \n    const response = await this.http.get<PaginatedResponse<T>>(this.path, params);\n    this.meta = response.meta;\n    this.fetchedPages.add(page);\n    \n    // Store items from this page\n    const items = response[this.resourceName] as T[];\n    if (items) {\n      this.allItems.push(...items);\n    }\n    \n    return response;\n  }\n\n  /**\n   * Get total number of pages (fetches first page if needed)\n   */\n  async getTotalPages(): Promise<number> {\n    if (!this.meta) {\n      await this.getPage(1);\n    }\n    return this.meta?.total_pages || 0;\n  }\n\n  /**\n   * Get total number of items (fetches first page if needed)\n   */\n  async getTotalItems(): Promise<number> {\n    if (!this.meta) {\n      await this.getPage(1);\n    }\n    return this.meta?.total_entries || 0;\n  }\n\n  /**\n   * Implement AsyncIterator to allow for-await-of loops\n   */\n  async *[Symbol.asyncIterator](): AsyncIterator<T> {\n    // Fetch first page if not already fetched\n    if (!this.fetchedPages.has(1)) {\n      await this.getPage(1);\n    }\n    \n    // Get total pages\n    const totalPages = await this.getTotalPages();\n    \n    // Yield items from first page\n    let yieldedCount = 0;\n    const firstPageItems = this.allItems.slice(0, this.meta?.per_page || 0);\n    for (const item of firstPageItems) {\n      yield item;\n      yieldedCount++;\n    }\n    \n    // Fetch and yield remaining pages\n    for (let page = 2; page <= totalPages; page++) {\n      // Skip if we've already fetched this page\n      if (this.fetchedPages.has(page)) {\n        const pageItems = this.allItems.slice(\n          (page - 1) * (this.meta?.per_page || 0),\n          page * (this.meta?.per_page || 0)\n        );\n        for (const item of pageItems) {\n          yield item;\n          yieldedCount++;\n        }\n        continue;\n      }\n      \n      // Fetch the next page\n      const response = await this.getPage(page);\n      const items = response[this.resourceName] as T[];\n      \n      // Yield items from this page\n      for (const item of items) {\n        yield item;\n        yieldedCount++;\n      }\n    }\n  }\n\n  /**\n   * Collect all items into an array\n   */\n  async toArray(): Promise<T[]> {\n    const items: T[] = [];\n    for await (const item of this) {\n      items.push(item);\n    }\n    return items;\n  }\n}\n```\n\nAdd a helper method to the HttpClient class in src/http.ts:\n\n```typescript\nexport class HttpClient {\n  // ... existing code ...\n  \n  /**\n   * Create a paginated results iterator\n   */\n  paginate<T>(\n    path: string,\n    params: PaginationParams = {},\n    resourceName: string\n  ): PaginatedResults<T> {\n    return new PaginatedResults<T>(this, path, params, resourceName);\n  }\n}\n```",
        "testStrategy": "1. Create unit tests in tests/unit/pagination.test.ts\n2. Test PaginatedResults class with mocked HTTP responses:\n   - Test single page results\n   - Test multi-page traversal\n   - Test AsyncIterator implementation with for-await-of loops\n   - Test toArray() method\n3. Test edge cases:\n   - Empty results\n   - Single item results\n   - Last page with fewer items\n4. Test parameter handling:\n   - perPage is correctly converted to per_page\n   - Additional filter parameters are preserved",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement core entity types",
        "description": "Create TypeScript interfaces for all Syncro API entity types as specified in the PRD.",
        "details": "Create the following type definition files in the src/types/ directory:\n\n1. src/types/common.ts:\n```typescript\nexport interface PaginationParams {\n  page?: number;\n  perPage?: number;\n  [key: string]: any;\n}\n\nexport interface PaginationMeta {\n  total_pages: number;\n  total_entries: number;\n  per_page: number;\n  page: number;\n}\n\nexport interface PaginatedResponse<T> {\n  [key: string]: T[] | PaginationMeta;\n  meta: PaginationMeta;\n}\n```\n\n2. src/types/customers.ts:\n```typescript\nexport interface Customer {\n  id: number;\n  businessName: string;\n  businessAndFullName: string;\n  firstName: string;\n  lastName: string;\n  email: string;\n  phone: string;\n  mobile: string;\n  address: string;\n  address2: string;\n  city: string;\n  state: string;\n  zip: string;\n  latitude: number;\n  longitude: number;\n  notes: string;\n  referredBy: string;\n  taxable: boolean;\n  disabled: boolean;\n  noEmail: boolean;\n  invoiceTermId: number;\n  invoiceCcEmails: string;\n  createdAt: string;\n  updatedAt: string;\n  properties: Record<string, string>;\n}\n\nexport interface CustomerCreateParams {\n  businessName?: string;\n  firstName?: string;\n  lastName?: string;\n  email?: string;\n  phone?: string;\n  mobile?: string;\n  address?: string;\n  address2?: string;\n  city?: string;\n  state?: string;\n  zip?: string;\n  notes?: string;\n  referredBy?: string;\n  taxable?: boolean;\n  disabled?: boolean;\n  noEmail?: boolean;\n  invoiceTermId?: number;\n  invoiceCcEmails?: string;\n  properties?: Record<string, string>;\n}\n\nexport interface CustomerUpdateParams extends CustomerCreateParams {}\n\nexport interface CustomerListParams extends PaginationParams {\n  query?: string;\n  includeDisabled?: boolean;\n}\n\nexport interface CustomerResponse {\n  customer: Customer;\n}\n\nexport interface CustomersResponse extends PaginatedResponse<Customer> {\n  customers: Customer[];\n}\n```\n\nCreate similar type definition files for all other entity types mentioned in the PRD:\n- src/types/contacts.ts\n- src/types/tickets.ts\n- src/types/assets.ts\n- src/types/invoices.ts\n- src/types/estimates.ts\n- src/types/contracts.ts\n- src/types/appointments.ts\n- src/types/products.ts\n- src/types/payments.ts\n- src/types/line-items.ts\n- src/types/ticket-timers.ts\n- src/types/rmm-alerts.ts\n- src/types/leads.ts\n- src/types/canned-responses.ts\n- src/types/ticket-problem-types.ts\n- src/types/wiki-pages.ts\n\nEach file should follow the same pattern with interfaces for:\n- The main entity type\n- Create/update parameter types\n- List parameter types\n- Response types\n\nFinally, create src/types/index.ts to re-export all types:\n\n```typescript\nexport * from './common';\nexport * from './customers';\nexport * from './contacts';\nexport * from './tickets';\nexport * from './assets';\nexport * from './invoices';\nexport * from './estimates';\nexport * from './contracts';\nexport * from './appointments';\nexport * from './products';\nexport * from './payments';\nexport * from './line-items';\nexport * from './ticket-timers';\nexport * from './rmm-alerts';\nexport * from './leads';\nexport * from './canned-responses';\nexport * from './ticket-problem-types';\nexport * from './wiki-pages';\n```",
        "testStrategy": "1. Verify type definitions compile without errors\n2. Create sample objects of each type to ensure type compatibility\n3. Test type exports are correctly re-exported from index.ts\n4. Ensure all required fields from the PRD are included in each type\n5. Test type compatibility with sample API responses in fixtures",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement resource base class and customers resource",
        "description": "Create a base resource class and implement the customers resource as a reference implementation.",
        "details": "1. Create src/resources/base.ts with a base resource class:\n\n```typescript\nimport { HttpClient } from '../http';\nimport { PaginatedResults, PaginationParams } from '../pagination';\n\nexport abstract class Resource {\n  protected http: HttpClient;\n  protected basePath: string;\n  protected resourceName: string;\n  protected pluralResourceName: string;\n\n  constructor(\n    http: HttpClient,\n    basePath: string,\n    resourceName: string,\n    pluralResourceName: string\n  ) {\n    this.http = http;\n    this.basePath = basePath;\n    this.resourceName = resourceName;\n    this.pluralResourceName = pluralResourceName;\n  }\n\n  protected getResourcePath(id?: number | string): string {\n    return id ? `${this.basePath}/${id}` : this.basePath;\n  }\n}\n```\n\n2. Create src/resources/customers.ts with the customers resource implementation:\n\n```typescript\nimport { Resource } from './base';\nimport { HttpClient } from '../http';\nimport { PaginatedResults } from '../pagination';\nimport {\n  Customer,\n  CustomerCreateParams,\n  CustomerUpdateParams,\n  CustomerListParams,\n  CustomerResponse,\n  CustomersResponse\n} from '../types/customers';\n\nexport class CustomersResource extends Resource {\n  constructor(http: HttpClient) {\n    super(http, '/customers', 'customer', 'customers');\n  }\n\n  /**\n   * List customers with pagination\n   */\n  async list(params: CustomerListParams = {}): Promise<CustomersResponse> {\n    return this.http.get<CustomersResponse>(this.basePath, params);\n  }\n\n  /**\n   * Get all customers (auto-paginated)\n   */\n  listAll(params: Omit<CustomerListParams, 'page' | 'perPage'> = {}): PaginatedResults<Customer> {\n    return new PaginatedResults<Customer>(\n      this.http,\n      this.basePath,\n      params,\n      this.pluralResourceName\n    );\n  }\n\n  /**\n   * Get a single customer by ID\n   */\n  async get(id: number): Promise<Customer> {\n    const response = await this.http.get<CustomerResponse>(this.getResourcePath(id));\n    return response.customer;\n  }\n\n  /**\n   * Create a new customer\n   */\n  async create(data: CustomerCreateParams): Promise<Customer> {\n    const response = await this.http.post<CustomerResponse>(this.basePath, data);\n    return response.customer;\n  }\n\n  /**\n   * Update an existing customer\n   */\n  async update(id: number, data: CustomerUpdateParams): Promise<Customer> {\n    const response = await this.http.put<CustomerResponse>(this.getResourcePath(id), data);\n    return response.customer;\n  }\n\n  /**\n   * Delete a customer\n   */\n  async delete(id: number): Promise<void> {\n    await this.http.delete(this.getResourcePath(id));\n  }\n}\n```\n\n3. Update the SyncroClient class in src/client.ts to include the customers resource:\n\n```typescript\nimport { CustomersResource } from './resources/customers';\n\nexport class SyncroClient {\n  // ... existing properties ...\n  readonly customers: CustomersResource;\n\n  constructor(config: SyncroClientConfig) {\n    // ... existing initialization ...\n    \n    // Initialize resources\n    this.customers = new CustomersResource(this.http);\n  }\n  \n  // ... existing methods ...\n}\n```\n\n4. Export the customers resource in src/index.ts:\n\n```typescript\nexport { CustomersResource } from './resources/customers';\n```",
        "testStrategy": "1. Create unit tests for the base Resource class\n2. Create integration tests for the CustomersResource in tests/integration/customers.test.ts\n3. Test all CRUD operations:\n   - list() with various filter parameters\n   - listAll() with auto-pagination\n   - get() with valid and invalid IDs\n   - create() with valid and invalid data\n   - update() with valid and invalid data\n   - delete() with valid and invalid IDs\n4. Test error handling for each method\n5. Create mock fixtures for customer responses in tests/fixtures/customers/",
        "priority": "high",
        "dependencies": [
          4,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Set up test infrastructure with mock server",
        "description": "Create the test infrastructure with mock server for API response fixtures to enable zero-live-API testing.",
        "details": "1. Install testing dependencies:\n```bash\nnpm install -D vitest msw @vitest/coverage-v8\n```\n\n2. Create tests/setup.ts for test environment setup:\n```typescript\nimport { beforeAll, afterAll, afterEach, vi } from 'vitest';\nimport { setupServer } from 'msw/node';\nimport { handlers } from './mocks/handlers';\n\n// Setup MSW server with handlers\nexport const server = setupServer(...handlers);\n\n// Setup before tests run\nbeforeAll(() => {\n  server.listen({ onUnhandledRequest: 'error' });\n});\n\n// Clean up after each test\nafterEach(() => {\n  server.resetHandlers();\n  vi.clearAllMocks();\n});\n\n// Clean up after all tests\nafterAll(() => {\n  server.close();\n});\n```\n\n3. Create tests/mocks/handlers.ts for API mocking:\n```typescript\nimport { http, HttpResponse } from 'msw';\nimport customerListPage1 from '../fixtures/customers/list-page1.json';\nimport customerListPage2 from '../fixtures/customers/list-page2.json';\nimport customerSingle from '../fixtures/customers/get-single.json';\nimport customerCreated from '../fixtures/customers/created.json';\nimport customerUpdated from '../fixtures/customers/updated.json';\nimport notFoundError from '../fixtures/errors/not-found.json';\nimport validationError from '../fixtures/errors/validation.json';\n\nconst BASE_URL = 'https://test-company.syncromsp.com/api/v1';\n\nexport const handlers = [\n  // Auth check\n  http.all('*', ({ request }) => {\n    const url = new URL(request.url);\n    if (!url.searchParams.get('api_key')) {\n      return new HttpResponse(null, { status: 401 });\n    }\n    return HttpResponse.next();\n  }),\n\n  // Customers endpoints\n  http.get(`${BASE_URL}/customers`, ({ request }) => {\n    const url = new URL(request.url);\n    const page = url.searchParams.get('page') || '1';\n    \n    if (page === '1') {\n      return HttpResponse.json(customerListPage1);\n    } else if (page === '2') {\n      return HttpResponse.json(customerListPage2);\n    } else {\n      return HttpResponse.json({\n        customers: [],\n        meta: {\n          total_pages: 2,\n          total_entries: 30,\n          per_page: 25,\n          page: parseInt(page)\n        }\n      });\n    }\n  }),\n\n  http.get(`${BASE_URL}/customers/:id`, ({ params }) => {\n    const id = params.id;\n    if (id === '404') {\n      return new HttpResponse(JSON.stringify(notFoundError), {\n        status: 404,\n        headers: { 'Content-Type': 'application/json' }\n      });\n    }\n    return HttpResponse.json(customerSingle);\n  }),\n\n  http.post(`${BASE_URL}/customers`, async ({ request }) => {\n    const body = await request.json();\n    \n    // Validation error simulation\n    if (body.email === 'invalid') {\n      return new HttpResponse(JSON.stringify(validationError), {\n        status: 422,\n        headers: { 'Content-Type': 'application/json' }\n      });\n    }\n    \n    return HttpResponse.json(customerCreated, { status: 201 });\n  }),\n\n  http.put(`${BASE_URL}/customers/:id`, ({ params }) => {\n    const id = params.id;\n    if (id === '404') {\n      return new HttpResponse(JSON.stringify(notFoundError), {\n        status: 404,\n        headers: { 'Content-Type': 'application/json' }\n      });\n    }\n    return HttpResponse.json(customerUpdated);\n  }),\n\n  http.delete(`${BASE_URL}/customers/:id`, ({ params }) => {\n    const id = params.id;\n    if (id === '404') {\n      return new HttpResponse(JSON.stringify(notFoundError), {\n        status: 404,\n        headers: { 'Content-Type': 'application/json' }\n      });\n    }\n    return new HttpResponse(null, { status: 204 });\n  }),\n\n  // Rate limit simulation\n  http.get(`${BASE_URL}/rate-limited`, () => {\n    return new HttpResponse(null, { status: 429 });\n  }),\n\n  // Server error simulation\n  http.get(`${BASE_URL}/server-error`, () => {\n    return new HttpResponse(null, { status: 500 });\n  }),\n];\n```\n\n4. Create fixture files in tests/fixtures/ directory:\n\n- tests/fixtures/customers/list-page1.json\n- tests/fixtures/customers/list-page2.json\n- tests/fixtures/customers/get-single.json\n- tests/fixtures/customers/created.json\n- tests/fixtures/customers/updated.json\n- tests/fixtures/errors/not-found.json\n- tests/fixtures/errors/validation.json\n\n5. Create vitest.config.ts:\n```typescript\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    setupFiles: ['./tests/setup.ts'],\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html'],\n      exclude: ['**/node_modules/**', '**/dist/**', '**/tests/**']\n    }\n  }\n});\n```\n\n6. Create a sample test in tests/integration/customers.test.ts:\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { SyncroClient } from '../../src';\nimport { SyncroNotFoundError, SyncroValidationError } from '../../src/errors';\n\ndescribe('Customers Resource', () => {\n  const client = new SyncroClient({\n    apiKey: 'test-api-key',\n    subdomain: 'test-company'\n  });\n\n  it('should list customers', async () => {\n    const response = await client.customers.list();\n    expect(response.customers).toHaveLength(25);\n    expect(response.meta.total_pages).toBe(2);\n  });\n\n  it('should get a customer by ID', async () => {\n    const customer = await client.customers.get(123);\n    expect(customer.id).toBe(123);\n    expect(customer.businessName).toBe('Acme Inc');\n  });\n\n  it('should throw NotFoundError for non-existent customer', async () => {\n    await expect(client.customers.get(404)).rejects.toThrow(SyncroNotFoundError);\n  });\n\n  it('should create a customer', async () => {\n    const customer = await client.customers.create({\n      businessName: 'New Customer',\n      email: 'contact@newcustomer.com'\n    });\n    expect(customer.id).toBeDefined();\n    expect(customer.businessName).toBe('New Customer');\n  });\n\n  it('should throw ValidationError for invalid customer data', async () => {\n    await expect(\n      client.customers.create({\n        businessName: 'Invalid Customer',\n        email: 'invalid'\n      })\n    ).rejects.toThrow(SyncroValidationError);\n  });\n});\n```",
        "testStrategy": "1. Verify MSW server setup works correctly\n2. Test fixture loading and response mocking\n3. Ensure authentication checks are working\n4. Test error response handling\n5. Verify test coverage reporting is configured correctly\n6. Run sample tests to confirm the infrastructure is working",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement remaining resource classes",
        "description": "Implement all remaining resource classes for the Syncro API endpoints specified in the PRD.",
        "details": "Create resource classes for all remaining endpoints following the pattern established with the CustomersResource. Each resource should extend the base Resource class and implement the appropriate CRUD methods.\n\nFor each resource, create a file in src/resources/ with the implementation:\n\n1. src/resources/contacts.ts\n2. src/resources/tickets.ts\n3. src/resources/assets.ts\n4. src/resources/invoices.ts\n5. src/resources/estimates.ts\n6. src/resources/contracts.ts\n7. src/resources/appointments.ts\n8. src/resources/products.ts\n9. src/resources/payments.ts\n10. src/resources/line-items.ts\n11. src/resources/ticket-timers.ts\n12. src/resources/rmm-alerts.ts\n13. src/resources/leads.ts\n14. src/resources/canned-responses.ts\n15. src/resources/ticket-problem-types.ts\n16. src/resources/wiki-pages.ts\n\nEach resource should implement the appropriate methods as specified in the PRD's endpoint inventory. For example, the TicketsResource should include methods for adding comments and managing timers.\n\nUpdate the SyncroClient class in src/client.ts to include all resources:\n\n```typescript\nimport { CustomersResource } from './resources/customers';\nimport { ContactsResource } from './resources/contacts';\nimport { TicketsResource } from './resources/tickets';\nimport { AssetsResource } from './resources/assets';\nimport { InvoicesResource } from './resources/invoices';\nimport { EstimatesResource } from './resources/estimates';\nimport { ContractsResource } from './resources/contracts';\nimport { AppointmentsResource } from './resources/appointments';\nimport { ProductsResource } from './resources/products';\nimport { PaymentsResource } from './resources/payments';\nimport { LineItemsResource } from './resources/line-items';\nimport { TicketTimersResource } from './resources/ticket-timers';\nimport { RmmAlertsResource } from './resources/rmm-alerts';\nimport { LeadsResource } from './resources/leads';\nimport { CannedResponsesResource } from './resources/canned-responses';\nimport { TicketProblemTypesResource } from './resources/ticket-problem-types';\nimport { WikiPagesResource } from './resources/wiki-pages';\n\nexport class SyncroClient {\n  // ... existing properties ...\n  readonly customers: CustomersResource;\n  readonly contacts: ContactsResource;\n  readonly tickets: TicketsResource;\n  readonly assets: AssetsResource;\n  readonly invoices: InvoicesResource;\n  readonly estimates: EstimatesResource;\n  readonly contracts: ContractsResource;\n  readonly appointments: AppointmentsResource;\n  readonly products: ProductsResource;\n  readonly payments: PaymentsResource;\n  readonly lineItems: LineItemsResource;\n  readonly ticketTimers: TicketTimersResource;\n  readonly rmmAlerts: RmmAlertsResource;\n  readonly leads: LeadsResource;\n  readonly cannedResponses: CannedResponsesResource;\n  readonly ticketProblemTypes: TicketProblemTypesResource;\n  readonly wikiPages: WikiPagesResource;\n\n  constructor(config: SyncroClientConfig) {\n    // ... existing initialization ...\n    \n    // Initialize resources\n    this.customers = new CustomersResource(this.http);\n    this.contacts = new ContactsResource(this.http);\n    this.tickets = new TicketsResource(this.http);\n    this.assets = new AssetsResource(this.http);\n    this.invoices = new InvoicesResource(this.http);\n    this.estimates = new EstimatesResource(this.http);\n    this.contracts = new ContractsResource(this.http);\n    this.appointments = new AppointmentsResource(this.http);\n    this.products = new ProductsResource(this.http);\n    this.payments = new PaymentsResource(this.http);\n    this.lineItems = new LineItemsResource(this.http);\n    this.ticketTimers = new TicketTimersResource(this.http);\n    this.rmmAlerts = new RmmAlertsResource(this.http);\n    this.leads = new LeadsResource(this.http);\n    this.cannedResponses = new CannedResponsesResource(this.http);\n    this.ticketProblemTypes = new TicketProblemTypesResource(this.http);\n    this.wikiPages = new WikiPagesResource(this.http);\n  }\n  \n  // ... existing methods ...\n  \n  /**\n   * Get current user information\n   */\n  async me() {\n    return this.http.get('/me');\n  }\n  \n  /**\n   * Get system settings\n   */\n  async settings() {\n    return this.http.get('/settings');\n  }\n}\n```\n\nExport all resource classes in src/index.ts:\n\n```typescript\nexport { SyncroClient } from './client';\nexport { SyncroClientConfig, RateLimitConfig } from './config';\nexport * from './errors';\nexport * from './types';\n\n// Resources\nexport { CustomersResource } from './resources/customers';\nexport { ContactsResource } from './resources/contacts';\nexport { TicketsResource } from './resources/tickets';\nexport { AssetsResource } from './resources/assets';\nexport { InvoicesResource } from './resources/invoices';\nexport { EstimatesResource } from './resources/estimates';\nexport { ContractsResource } from './resources/contracts';\nexport { AppointmentsResource } from './resources/appointments';\nexport { ProductsResource } from './resources/products';\nexport { PaymentsResource } from './resources/payments';\nexport { LineItemsResource } from './resources/line-items';\nexport { TicketTimersResource } from './resources/ticket-timers';\nexport { RmmAlertsResource } from './resources/rmm-alerts';\nexport { LeadsResource } from './resources/leads';\nexport { CannedResponsesResource } from './resources/canned-responses';\nexport { TicketProblemTypesResource } from './resources/ticket-problem-types';\nexport { WikiPagesResource } from './resources/wiki-pages';\n```",
        "testStrategy": "1. Create integration tests for each resource class in tests/integration/\n2. Create fixture files for each resource in tests/fixtures/\n3. Update mock handlers in tests/mocks/handlers.ts to handle all endpoints\n4. Test CRUD operations for each resource\n5. Test special methods (e.g., email, convert, mute) for resources that have them\n6. Verify error handling for each resource\n7. Ensure all resources are properly exported and accessible from the client",
        "priority": "medium",
        "dependencies": [
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Create documentation and usage examples",
        "description": "Create comprehensive documentation including README, usage examples, and API reference.",
        "details": "1. Create README.md with comprehensive documentation:\n\n```markdown\n# node-syncro\n\nA comprehensive, fully-typed Node.js/TypeScript library providing complete coverage of the Syncro MSP API.\n\n## Installation\n\n```bash\nnpm install node-syncro\n```\n\n## Features\n\n- **Complete API coverage**  Every documented Syncro API endpoint is implemented\n- **Strong TypeScript types**  Full type definitions for all request/response payloads\n- **Simple authentication**  API key passed as query parameter with automatic injection\n- **Automatic pagination**  Iterator/generator patterns for seamless multi-page retrieval\n- **Rate limit handling**  Built-in request throttling (180 req/min) with backoff\n- **Zero live API testing**  Full test suite with mocked HTTP responses\n\n## Quick Start\n\n```typescript\nimport { SyncroClient } from 'node-syncro';\n\n// Initialize client\nconst client = new SyncroClient({\n  apiKey: 'YOUR_API_KEY',\n  subdomain: 'your-company',    // Results in: https://your-company.syncromsp.com\n});\n\n// List customers\nconst customers = await client.customers.list({\n  query: 'Acme',\n  perPage: 50,\n});\n\n// Get single customer\nconst customer = await client.customers.get(12345);\n\n// Create a ticket\nconst ticket = await client.tickets.create({\n  customerId: 12345,\n  subject: 'Network issue',\n  problemType: 'Network',\n  status: 'New',\n});\n\n// Update a ticket\nawait client.tickets.update(ticket.id, {\n  status: 'In Progress',\n  userId: 789,\n});\n\n// Auto-paginate all tickets for a customer\nfor await (const ticket of client.tickets.listAll({\n  customerId: 12345,\n})) {\n  console.log(ticket.number, ticket.subject);\n}\n```\n\n## API Documentation\n\n### Client Configuration\n\n```typescript\nconst client = new SyncroClient({\n  apiKey: 'YOUR_API_KEY',       // Required\n  subdomain: 'your-company',    // Either subdomain or baseUrl is required\n  // OR explicit base URL:\n  // baseUrl: 'https://your-company.syncromsp.com',\n  rateLimiting: {               // Optional\n    enabled: true,              // default: true\n    maxRequests: 180,           // default: 180\n    windowMs: 60000,            // default: 60000 (1 minute)\n    throttleThreshold: 0.8,     // default: 0.8 (80%)\n    retryAfterMs: 5000,         // default: 5000\n    maxRetries: 3               // default: 3\n  }\n});\n```\n\n### Available Resources\n\n- `client.customers` - Customer management\n- `client.contacts` - Contact management\n- `client.tickets` - Ticket management\n- `client.assets` - Asset management\n- `client.invoices` - Invoice management\n- `client.estimates` - Estimate management\n- `client.contracts` - Contract management\n- `client.appointments` - Appointment management\n- `client.products` - Product management\n- `client.payments` - Payment management\n- `client.lineItems` - Line item management\n- `client.ticketTimers` - Ticket timer management\n- `client.rmmAlerts` - RMM alert management\n- `client.leads` - Lead management\n- `client.cannedResponses` - Canned response management\n- `client.ticketProblemTypes` - Ticket problem type management\n- `client.wikiPages` - Wiki page management\n\n### Common Methods\n\nMost resources support these common methods:\n\n- `list(params?)` - List resources with pagination\n- `listAll(params?)` - Auto-paginate all resources\n- `get(id)` - Get a single resource by ID\n- `create(data)` - Create a new resource\n- `update(id, data)` - Update an existing resource\n- `delete(id)` - Delete a resource\n\n### Pagination\n\n```typescript\n// Get a single page\nconst page1 = await client.customers.list({ page: 1, perPage: 50 });\n\n// Auto-paginate all results (async generator)\nfor await (const customer of client.customers.listAll()) {\n  console.log(customer.businessName);\n}\n\n// Collect all into an array\nconst allCustomers = await client.customers.listAll().toArray();\n```\n\n### Error Handling\n\n```typescript\nimport { SyncroNotFoundError, SyncroValidationError } from 'node-syncro';\n\ntry {\n  await client.customers.get(999999);\n} catch (error) {\n  if (error instanceof SyncroNotFoundError) {\n    console.log('Customer not found');\n  } else if (error instanceof SyncroValidationError) {\n    console.log('Validation errors:', error.errors);\n  } else {\n    console.error('Unexpected error:', error);\n  }\n}\n```\n\n## Usage Examples\n\n### Ticket Workflow\n\n```typescript\n// Create ticket\nconst ticket = await client.tickets.create({\n  customerId: 12345,\n  subject: 'Printer not working',\n  problemType: 'Hardware',\n});\n\n// Add comment\nawait client.tickets.addComment(ticket.id, {\n  body: 'Checked the printer, needs new toner cartridge.',\n  hidden: false,\n});\n\n// Start timer\nawait client.tickets.startTimer(ticket.id, {\n  notes: 'On-site visit',\n});\n\n// ... do work ...\n\n// Stop timer and log time\nawait client.tickets.deleteTimer(ticket.id);\n\n// Create time entry (via ticket timer)\nawait client.ticketTimers.create({\n  ticketId: ticket.id,\n  startTime: '2026-02-04T10:00:00Z',\n  endTime: '2026-02-04T11:30:00Z',\n  notes: 'Replaced toner cartridge, tested printing',\n});\n```\n\n### Invoice Operations\n\n```typescript\n// Create an invoice\nconst invoice = await client.invoices.create({\n  customerId: 12345,\n  date: '2026-02-04',\n  dueDate: '2026-03-04',\n});\n\n// Add line item\nawait client.lineItems.create({\n  invoiceId: invoice.id,\n  name: 'IT Support - 2 hours',\n  quantity: 2,\n  price: 150.00,\n});\n\n// Send invoice via email\nawait client.invoices.email(invoice.id, {\n  ccEmails: 'accounting@example.com',\n});\n```\n\n### RMM Alert Management\n\n```typescript\n// List active RMM alerts\nconst alerts = await client.rmmAlerts.list({\n  status: 'active',\n});\n\n// Process alerts\nfor (const alert of alerts.rmmAlerts) {\n  if (alert.alertType === 'disk_space') {\n    // Investigate...\n    await client.rmmAlerts.resolve(alert.id);\n  } else {\n    // Mute non-critical alert\n    await client.rmmAlerts.mute(alert.id);\n  }\n}\n```\n\n## API Reference\n\nFor complete API reference, see the [TypeScript definitions](./src/types) or the [Syncro API Documentation](https://api-docs.syncromsp.com/).\n\n## License\n\nMIT\n```\n\n2. Create CHANGELOG.md:\n\n```markdown\n# Changelog\n\n## 1.0.0 (Initial Release)\n\n- Complete implementation of all Syncro API endpoints\n- Strong TypeScript typing for all entities\n- Automatic pagination support\n- Rate limiting with configurable thresholds\n- Comprehensive error handling\n- Full test coverage\n```\n\n3. Create examples directory with usage examples:\n\n- examples/basic-usage.ts\n- examples/pagination.ts\n- examples/ticket-workflow.ts\n- examples/invoice-operations.ts\n- examples/rmm-alerts.ts\n\n4. Update package.json with metadata:\n\n```json\n{\n  \"name\": \"node-syncro\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A comprehensive, fully-typed Node.js/TypeScript library for the Syncro MSP API\",\n  \"main\": \"dist/index.js\",\n  \"module\": \"dist/index.mjs\",\n  \"types\": \"dist/index.d.ts\",\n  \"files\": [\n    \"dist\",\n    \"LICENSE\",\n    \"README.md\",\n    \"CHANGELOG.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"test\": \"vitest run\",\n    \"test:watch\": \"vitest\",\n    \"test:coverage\": \"vitest run --coverage\",\n    \"prepublishOnly\": \"npm run build\"\n  },\n  \"keywords\": [\n    \"syncro\",\n    \"syncromsp\",\n    \"msp\",\n    \"api\",\n    \"client\",\n    \"sdk\",\n    \"typescript\"\n  ],\n  \"author\": \"WYRE Technology\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/syncro/node-syncro\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}\n```",
        "testStrategy": "1. Verify README.md contains all required sections:\n   - Installation instructions\n   - Quick start guide\n   - API documentation\n   - Usage examples\n   - Error handling\n2. Ensure examples are complete and functional\n3. Validate package.json metadata is correct\n4. Check CHANGELOG.md follows standard format",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-02-05T01:48:13.231Z",
      "updated": "2026-02-05T01:48:13.231Z",
      "description": "Tasks for node-syncro context"
    }
  },
  "node-atera": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up project structure and core dependencies",
        "description": "Initialize the project with the required folder structure, TypeScript configuration, and core dependencies as specified in the PRD.",
        "details": "1. Create the project directory structure as outlined in the PRD\n2. Initialize npm project with `npm init -y`\n3. Install core dependencies:\n   - TypeScript (>= 5.0)\n   - tsup (for building)\n   - Vitest (for testing)\n   - MSW or nock (for API mocking)\n   - undici or axios (for HTTP client)\n4. Configure TypeScript with `tsconfig.json`:\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"outDir\": \"dist\",\n    \"declaration\": true,\n    \"skipLibCheck\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n5. Set up build configuration with tsup in `package.json`:\n```json\n\"scripts\": {\n  \"build\": \"tsup src/index.ts --format esm,cjs --dts\",\n  \"test\": \"vitest run\",\n  \"test:watch\": \"vitest\",\n  \"test:coverage\": \"vitest run --coverage\"\n}\n```\n6. Create Vitest configuration file `vitest.config.ts`\n7. Set up basic README.md, CHANGELOG.md, and LICENSE files",
        "testStrategy": "1. Verify project structure matches PRD requirements\n2. Ensure all dependencies are correctly installed\n3. Validate TypeScript configuration with `tsc --noEmit`\n4. Run a basic build to confirm tsup configuration works\n5. Execute a simple test to verify Vitest setup",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement core client and HTTP layer",
        "description": "Create the AteraClient class with configuration options and implement the HTTP layer with API key authentication.",
        "details": "1. Create `src/config.ts` with configuration types and defaults:\n```typescript\nexport interface AteraClientConfig {\n  apiKey: string;\n  baseUrl?: string;\n  rateLimiting?: RateLimitConfig;\n}\n\nexport interface RateLimitConfig {\n  enabled: boolean;\n  maxRequests: number;\n  windowMs: number;\n  throttleThreshold: number;\n  retryAfterMs: number;\n  maxRetries: number;\n}\n\nexport const DEFAULT_BASE_URL = 'https://app.atera.com/api/v3';\n\nexport const DEFAULT_RATE_LIMIT_CONFIG: RateLimitConfig = {\n  enabled: true,\n  maxRequests: 700,\n  windowMs: 60000, // 1 minute\n  throttleThreshold: 0.8, // 80%\n  retryAfterMs: 5000,\n  maxRetries: 3\n};\n```\n\n2. Create `src/errors.ts` with custom error classes:\n```typescript\nexport class AteraError extends Error {\n  statusCode: number;\n  response: any;\n\n  constructor(message: string, statusCode: number, response?: any) {\n    super(message);\n    this.name = 'AteraError';\n    this.statusCode = statusCode;\n    this.response = response;\n  }\n}\n\nexport class AteraAuthenticationError extends AteraError {\n  constructor(message: string, response?: any) {\n    super(message, 401, response);\n    this.name = 'AteraAuthenticationError';\n  }\n}\n\nexport class AteraNotFoundError extends AteraError {\n  constructor(message: string, response?: any) {\n    super(message, 404, response);\n    this.name = 'AteraNotFoundError';\n  }\n}\n\nexport class AteraValidationError extends AteraError {\n  errors: Array<{ message: string; field?: string }>;\n\n  constructor(message: string, errors: Array<{ message: string; field?: string }>, response?: any) {\n    super(message, 400, response);\n    this.name = 'AteraValidationError';\n    this.errors = errors;\n  }\n}\n\nexport class AteraRateLimitError extends AteraError {\n  constructor(message: string, response?: any) {\n    super(message, 429, response);\n    this.name = 'AteraRateLimitError';\n  }\n}\n\nexport class AteraServerError extends AteraError {\n  constructor(message: string, statusCode: number = 500, response?: any) {\n    super(message, statusCode, response);\n    this.name = 'AteraServerError';\n  }\n}\n```\n\n3. Create `src/http.ts` with fetch wrapper:\n```typescript\nimport { AteraClientConfig, DEFAULT_BASE_URL } from './config';\nimport {\n  AteraAuthenticationError,\n  AteraNotFoundError,\n  AteraRateLimitError,\n  AteraServerError,\n  AteraValidationError\n} from './errors';\n\nexport interface RequestOptions {\n  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  params?: Record<string, any>;\n  body?: any;\n}\n\nexport class HttpClient {\n  private apiKey: string;\n  private baseUrl: string;\n\n  constructor(config: AteraClientConfig) {\n    this.apiKey = config.apiKey;\n    this.baseUrl = config.baseUrl || DEFAULT_BASE_URL;\n  }\n\n  async request<T>(path: string, options: RequestOptions = {}): Promise<T> {\n    const { method = 'GET', params = {}, body } = options;\n    \n    // Build URL with query parameters\n    const url = new URL(`${this.baseUrl}${path}`);\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined && value !== null) {\n        url.searchParams.append(key, String(value));\n      }\n    });\n\n    // Build request options\n    const requestOptions: RequestInit = {\n      method,\n      headers: {\n        'X-API-KEY': this.apiKey,\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n      }\n    };\n\n    if (body) {\n      requestOptions.body = JSON.stringify(body);\n    }\n\n    // Make request\n    const response = await fetch(url.toString(), requestOptions);\n    \n    // Handle response\n    if (!response.ok) {\n      await this.handleErrorResponse(response);\n    }\n\n    // Parse JSON response\n    if (response.status === 204) {\n      return {} as T;\n    }\n\n    return response.json() as Promise<T>;\n  }\n\n  private async handleErrorResponse(response: Response): Promise<never> {\n    let errorData: any;\n    try {\n      errorData = await response.json();\n    } catch (e) {\n      errorData = { message: response.statusText };\n    }\n\n    const message = errorData.message || `HTTP Error ${response.status}`;\n\n    switch (response.status) {\n      case 400:\n        throw new AteraValidationError(\n          message,\n          Array.isArray(errorData.errors) ? errorData.errors : [{ message }],\n          errorData\n        );\n      case 401:\n        throw new AteraAuthenticationError(message, errorData);\n      case 404:\n        throw new AteraNotFoundError(message, errorData);\n      case 429:\n        throw new AteraRateLimitError(message, errorData);\n      default:\n        throw new AteraServerError(message, response.status, errorData);\n    }\n  }\n}\n```\n\n4. Create `src/client.ts` with the main client class:\n```typescript\nimport { AteraClientConfig, DEFAULT_RATE_LIMIT_CONFIG } from './config';\nimport { HttpClient } from './http';\n\nexport class AteraClient {\n  private http: HttpClient;\n  private config: AteraClientConfig;\n\n  constructor(config: AteraClientConfig) {\n    if (!config.apiKey) {\n      throw new Error('API key is required');\n    }\n\n    this.config = {\n      ...config,\n      rateLimiting: {\n        ...DEFAULT_RATE_LIMIT_CONFIG,\n        ...config.rateLimiting\n      }\n    };\n\n    this.http = new HttpClient(this.config);\n  }\n}\n```\n\n5. Create `src/index.ts` to export public API:\n```typescript\nexport { AteraClient } from './client';\nexport { AteraClientConfig, RateLimitConfig } from './config';\nexport {\n  AteraError,\n  AteraAuthenticationError,\n  AteraNotFoundError,\n  AteraValidationError,\n  AteraRateLimitError,\n  AteraServerError\n} from './errors';\n```",
        "testStrategy": "1. Unit test client initialization with valid and invalid configs\n2. Test HTTP client with mocked fetch responses\n3. Verify error handling for different HTTP status codes\n4. Test authentication header injection\n5. Test URL construction with query parameters\n6. Test request/response body handling",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement rate limiting and pagination utilities",
        "description": "Create rate limiting logic to prevent exceeding 700 req/min and pagination utilities for handling multi-page responses.",
        "details": "1. Create `src/rate-limiter.ts`:\n```typescript\nimport { RateLimitConfig } from './config';\n\nexport class RateLimiter {\n  private config: RateLimitConfig;\n  private requestTimestamps: number[] = [];\n  private isThrottled = false;\n\n  constructor(config: RateLimitConfig) {\n    this.config = config;\n  }\n\n  async acquirePermit(): Promise<void> {\n    if (!this.config.enabled) {\n      return;\n    }\n\n    // Clean up old timestamps outside the window\n    const now = Date.now();\n    const windowStart = now - this.config.windowMs;\n    this.requestTimestamps = this.requestTimestamps.filter(ts => ts >= windowStart);\n\n    // Check if we're over the throttle threshold\n    const requestCount = this.requestTimestamps.length;\n    const throttleLimit = Math.floor(this.config.maxRequests * this.config.throttleThreshold);\n\n    if (requestCount >= this.config.maxRequests) {\n      // We're at the limit, wait until oldest request exits the window\n      const oldestTimestamp = this.requestTimestamps[0];\n      const waitTime = oldestTimestamp + this.config.windowMs - now;\n      await this.delay(waitTime);\n      return this.acquirePermit(); // Try again after waiting\n    }\n\n    if (requestCount >= throttleLimit && !this.isThrottled) {\n      // We're approaching the limit, start throttling\n      this.isThrottled = true;\n      const delayMs = this.config.windowMs / (this.config.maxRequests - throttleLimit);\n      await this.delay(delayMs);\n    } else if (requestCount < throttleLimit && this.isThrottled) {\n      // We're back below the threshold, stop throttling\n      this.isThrottled = false;\n    }\n\n    // Record this request\n    this.requestTimestamps.push(now);\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, Math.max(0, ms)));\n  }\n\n  async executeWithRetry<T>(fn: () => Promise<T>): Promise<T> {\n    let retries = 0;\n\n    while (true) {\n      try {\n        await this.acquirePermit();\n        return await fn();\n      } catch (error) {\n        if (error.name === 'AteraRateLimitError' && retries < this.config.maxRetries) {\n          retries++;\n          const backoffMs = this.config.retryAfterMs * Math.pow(2, retries - 1);\n          await this.delay(backoffMs);\n          continue;\n        }\n        throw error;\n      }\n    }\n  }\n}\n```\n\n2. Update `src/http.ts` to use the rate limiter:\n```typescript\nimport { RateLimiter } from './rate-limiter';\n\nexport class HttpClient {\n  private apiKey: string;\n  private baseUrl: string;\n  private rateLimiter: RateLimiter;\n\n  constructor(config: AteraClientConfig) {\n    this.apiKey = config.apiKey;\n    this.baseUrl = config.baseUrl || DEFAULT_BASE_URL;\n    this.rateLimiter = new RateLimiter(config.rateLimiting || DEFAULT_RATE_LIMIT_CONFIG);\n  }\n\n  async request<T>(path: string, options: RequestOptions = {}): Promise<T> {\n    return this.rateLimiter.executeWithRetry(async () => {\n      // Existing request implementation\n    });\n  }\n}\n```\n\n3. Create `src/pagination.ts` with pagination utilities:\n```typescript\nexport interface PaginatedResponse<T> {\n  items: T[];\n  totalItemCount: number;\n  page: number;\n  itemsInPage: number;\n  totalPages: number;\n  prevLink: string | null;\n  nextLink: string | null;\n}\n\nexport interface PaginationParams {\n  page?: number;\n  itemsInPage?: number;\n  [key: string]: any;\n}\n\nexport class PaginatedResults<T> implements AsyncIterable<T> {\n  private fetchPage: (params: PaginationParams) => Promise<PaginatedResponse<T>>;\n  private params: PaginationParams;\n  private fetchedItems: T[] = [];\n\n  constructor(\n    fetchPage: (params: PaginationParams) => Promise<PaginatedResponse<T>>,\n    params: PaginationParams = {}\n  ) {\n    this.fetchPage = fetchPage;\n    this.params = { ...params, page: params.page || 1, itemsInPage: params.itemsInPage || 50 };\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<T> {\n    let currentPage = this.params.page;\n    let hasNextPage = true;\n\n    while (hasNextPage) {\n      const response = await this.fetchPage({ ...this.params, page: currentPage });\n      \n      for (const item of response.items) {\n        yield item;\n        this.fetchedItems.push(item);\n      }\n\n      hasNextPage = response.nextLink !== null;\n      currentPage++;\n    }\n  }\n\n  async toArray(): Promise<T[]> {\n    if (this.fetchedItems.length > 0) {\n      return this.fetchedItems;\n    }\n\n    const items: T[] = [];\n    for await (const item of this) {\n      items.push(item);\n    }\n    return items;\n  }\n}\n```\n\n4. Update `src/client.ts` to expose the pagination utilities:\n```typescript\nimport { PaginatedResults, PaginationParams } from './pagination';\n\nexport class AteraClient {\n  // ... existing code\n\n  protected createPaginatedResults<T>(\n    fetchFn: (params: PaginationParams) => Promise<PaginatedResponse<T>>,\n    params: PaginationParams = {}\n  ): PaginatedResults<T> {\n    return new PaginatedResults<T>(fetchFn, params);\n  }\n}\n```",
        "testStrategy": "1. Unit test rate limiter with simulated requests\n2. Test throttling behavior when approaching limits\n3. Test backoff and retry logic for 429 responses\n4. Test pagination with mock multi-page responses\n5. Verify AsyncIterator implementation works correctly\n6. Test toArray() method for collecting all paginated results",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement core entity types and common interfaces",
        "description": "Define TypeScript interfaces for all core entity types (Agent, Ticket, Customer, Alert, Device, Contact, Contract) and common request/response structures.",
        "details": "1. Create `src/types/common.ts` with shared types:\n```typescript\nexport interface PaginationParams {\n  page?: number;\n  itemsInPage?: number;\n  [key: string]: any;\n}\n\nexport interface PaginatedResponse<T> {\n  items: T[];\n  totalItemCount: number;\n  page: number;\n  itemsInPage: number;\n  totalPages: number;\n  prevLink: string | null;\n  nextLink: string | null;\n}\n```\n\n2. Create `src/types/agents.ts`:\n```typescript\nexport interface Agent {\n  AgentID: number;\n  AgentName: string;\n  MachineName: string;\n  CustomerID: number;\n  CustomerName: string;\n  FolderID: number;\n  FolderName: string;\n  AgentType: string;\n  LastSeenDate: string;\n  Online: boolean;\n  OS: string;\n  OSVersion: string;\n  OSType: string;\n  Domain: string;\n  CurrentUser: string;\n  IPAddresses: string[];\n  ReportedFromIP: string;\n  Processor: string;\n  TotalMemory: number;\n  LastReboot: string;\n  AgentVersion: string;\n  HardwareSerialNumber: string;\n  Vendor: string;\n  Model: string;\n  Office: string;\n  OfficeVersion: string;\n  AntivirusDefinitionUpdateDate: string;\n  HasAntivirusConflicts: boolean;\n}\n\nexport interface AgentListParams extends PaginationParams {\n  customerId?: number;\n  folderId?: number;\n  online?: boolean;\n}\n\nexport interface PowerShellRunParams {\n  Script: string;\n  ScriptName: string;\n  Timeout?: number;\n}\n```\n\n3. Create `src/types/tickets.ts`:\n```typescript\nexport interface Ticket {\n  TicketID: number;\n  TicketTitle: string;\n  TicketNumber: string;\n  TicketPriority: string;\n  TicketImpact: string;\n  TicketStatus: string;\n  TicketType: string;\n  TicketSource: string;\n  CustomerID: number;\n  CustomerName: string;\n  CustomerBusinessNumber: string;\n  ContactID: number;\n  ContactFullName: string;\n  ContactEmail: string;\n  ContractID: number;\n  ContractName: string;\n  TechnicianContactID: number;\n  TechnicianFullName: string;\n  FirstComment: string;\n  LastEndUserComment: string;\n  OnSiteVisits: number;\n  SLAName: string;\n  SLAStatus: string;\n  DueDate: string;\n  FirstResponseDueDate: string;\n  FirstResponseDate: string;\n  ResolvedDate: string;\n  ClosedDate: string;\n  CreatedDate: string;\n  LastUpdatedDate: string;\n  Tags: string[];\n}\n\nexport interface TicketListParams extends PaginationParams {\n  ticketStatus?: string;\n  customerId?: number;\n  technicianId?: number;\n  dateFrom?: string;\n  dateTo?: string;\n}\n\nexport interface TicketCreateParams {\n  TicketTitle: string;\n  CustomerID: number;\n  ContactID?: number;\n  TicketType: string;\n  TicketPriority: string;\n  TicketStatus?: string;\n  TechnicianContactID?: number;\n  FirstComment?: string;\n  ContractID?: number;\n  DueDate?: string;\n  Tags?: string[];\n}\n\nexport interface TicketUpdateParams {\n  TicketTitle?: string;\n  TicketStatus?: string;\n  TicketPriority?: string;\n  TechnicianContactID?: number;\n  ContactID?: number;\n  ContractID?: number;\n  DueDate?: string;\n  Tags?: string[];\n}\n\nexport interface TicketComment {\n  CommentID: number;\n  Comment: string;\n  CreatedDate: string;\n  CreatedBy: string;\n  IsInternal: boolean;\n}\n\nexport interface TicketCommentCreateParams {\n  Comment: string;\n  IsInternal: boolean;\n}\n\nexport interface TicketWorkHour {\n  WorkHourID: number;\n  StartDate: string;\n  EndDate: string;\n  Duration: number;\n  TechnicianContactID: number;\n  TechnicianFullName: string;\n  Description: string;\n  BillableDuration: number;\n}\n\nexport interface TicketWorkHourCreateParams {\n  StartDate: string;\n  EndDate: string;\n  TechnicianContactID: number;\n  Description: string;\n  BillableDuration?: number;\n}\n\nexport interface TicketTimesheet {\n  TimesheetID: number;\n  Date: string;\n  Duration: number;\n  TechnicianContactID: number;\n  TechnicianFullName: string;\n  Description: string;\n  BillableDuration: number;\n}\n\nexport interface TicketTimesheetCreateParams {\n  Date: string;\n  Duration: number;\n  TechnicianContactID: number;\n  Description: string;\n  BillableDuration?: number;\n}\n```\n\n4. Create similar type files for other entities:\n   - `src/types/customers.ts`\n   - `src/types/contacts.ts`\n   - `src/types/alerts.ts`\n   - `src/types/devices.ts`\n   - `src/types/custom-values.ts`\n   - `src/types/contracts.ts`\n   - `src/types/billing.ts`\n   - `src/types/rates.ts`\n   - `src/types/knowledge-base.ts`\n\n5. Create `src/types/index.ts` to re-export all types:\n```typescript\nexport * from './common';\nexport * from './agents';\nexport * from './tickets';\nexport * from './customers';\nexport * from './contacts';\nexport * from './alerts';\nexport * from './devices';\nexport * from './custom-values';\nexport * from './contracts';\nexport * from './billing';\nexport * from './rates';\nexport * from './knowledge-base';\n```\n\n6. Update `src/index.ts` to export types:\n```typescript\nexport { AteraClient } from './client';\nexport { AteraClientConfig, RateLimitConfig } from './config';\nexport {\n  AteraError,\n  AteraAuthenticationError,\n  AteraNotFoundError,\n  AteraValidationError,\n  AteraRateLimitError,\n  AteraServerError\n} from './errors';\nexport * from './types';\n```",
        "testStrategy": "1. Verify type definitions with TypeScript compiler\n2. Test type compatibility with sample API responses\n3. Ensure all required fields are present in each interface\n4. Test optional fields handling\n5. Validate nested object structures",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Agents resource",
        "description": "Create the Agents resource with methods for listing, retrieving, deleting agents, and running PowerShell scripts.",
        "details": "1. Create `src/resources/agents.ts`:\n```typescript\nimport { HttpClient } from '../http';\nimport { Agent, AgentListParams, PowerShellRunParams, PaginatedResponse } from '../types';\nimport { PaginatedResults } from '../pagination';\n\nexport class AgentsResource {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * List agents with pagination\n   */\n  async list(params: AgentListParams = {}): Promise<PaginatedResponse<Agent>> {\n    const queryParams: Record<string, any> = {\n      Page: params.page || 1,\n      ItemsInPage: params.itemsInPage || 50,\n    };\n\n    if (params.customerId) queryParams.CustomerID = params.customerId;\n    if (params.folderId) queryParams.FolderID = params.folderId;\n    if (params.online !== undefined) queryParams.Online = params.online;\n\n    return this.http.request<PaginatedResponse<Agent>>('/agents', {\n      params: queryParams,\n    });\n  }\n\n  /**\n   * Get all agents (auto-paginated)\n   */\n  listAll(params: Omit<AgentListParams, 'page' | 'itemsInPage'> = {}): PaginatedResults<Agent> {\n    return new PaginatedResults<Agent>(\n      (pageParams) => this.list({ ...params, ...pageParams }),\n      { itemsInPage: 50 }\n    );\n  }\n\n  /**\n   * Get agent by ID\n   */\n  async get(agentId: number): Promise<Agent> {\n    return this.http.request<Agent>(`/agents/${agentId}`);\n  }\n\n  /**\n   * Get agent by machine name\n   */\n  async getByMachineName(machineName: string): Promise<Agent> {\n    return this.http.request<Agent>(`/agents/machine/${encodeURIComponent(machineName)}`);\n  }\n\n  /**\n   * Delete agent\n   */\n  async delete(agentId: number): Promise<void> {\n    await this.http.request<void>(`/agents/${agentId}`, { method: 'DELETE' });\n  }\n\n  /**\n   * Run PowerShell script on agent\n   */\n  async runPowerShell(agentId: number, runtimeId: number, data: PowerShellRunParams): Promise<any> {\n    return this.http.request<any>(`/agents/${agentId}/powershell/runtime/${runtimeId}`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n}\n```\n\n2. Update `src/client.ts` to include the Agents resource:\n```typescript\nimport { AteraClientConfig, DEFAULT_RATE_LIMIT_CONFIG } from './config';\nimport { HttpClient } from './http';\nimport { AgentsResource } from './resources/agents';\n\nexport class AteraClient {\n  private http: HttpClient;\n  private config: AteraClientConfig;\n\n  // Resources\n  public readonly agents: AgentsResource;\n\n  constructor(config: AteraClientConfig) {\n    if (!config.apiKey) {\n      throw new Error('API key is required');\n    }\n\n    this.config = {\n      ...config,\n      rateLimiting: {\n        ...DEFAULT_RATE_LIMIT_CONFIG,\n        ...config.rateLimiting\n      }\n    };\n\n    this.http = new HttpClient(this.config);\n    \n    // Initialize resources\n    this.agents = new AgentsResource(this.http);\n  }\n}\n```\n\n3. Create test fixtures for agents in `tests/fixtures/agents/`:\n   - `list-page1.json`\n   - `list-page2.json`\n   - `get-single.json`\n   - `get-by-machine-name.json`\n   - `powershell-response.json`\n\n4. Create mock handlers for agent endpoints in `tests/mocks/handlers.ts`:\n```typescript\nimport { http, HttpResponse } from 'msw';\nimport agentListPage1 from '../fixtures/agents/list-page1.json';\nimport agentListPage2 from '../fixtures/agents/list-page2.json';\nimport agentSingle from '../fixtures/agents/get-single.json';\nimport agentByMachineName from '../fixtures/agents/get-by-machine-name.json';\nimport powershellResponse from '../fixtures/agents/powershell-response.json';\n\nconst BASE_URL = 'https://app.atera.com/api/v3';\n\nexport const handlers = [\n  // List agents - page 1\n  http.get(`${BASE_URL}/agents`, ({ request }) => {\n    const url = new URL(request.url);\n    const page = url.searchParams.get('Page') || '1';\n    \n    if (page === '1') {\n      return HttpResponse.json(agentListPage1);\n    } else if (page === '2') {\n      return HttpResponse.json(agentListPage2);\n    }\n    \n    return HttpResponse.json({ items: [], totalItemCount: 0, page: 1, itemsInPage: 50, totalPages: 0, prevLink: null, nextLink: null });\n  }),\n  \n  // Get agent by ID\n  http.get(`${BASE_URL}/agents/:agentId`, ({ params }) => {\n    return HttpResponse.json(agentSingle);\n  }),\n  \n  // Get agent by machine name\n  http.get(`${BASE_URL}/agents/machine/:machineName`, ({ params }) => {\n    return HttpResponse.json(agentByMachineName);\n  }),\n  \n  // Delete agent\n  http.delete(`${BASE_URL}/agents/:agentId`, () => {\n    return new HttpResponse(null, { status: 204 });\n  }),\n  \n  // Run PowerShell\n  http.post(`${BASE_URL}/agents/:agentId/powershell/runtime/:runtimeId`, async ({ request }) => {\n    const body = await request.json();\n    return HttpResponse.json(powershellResponse);\n  }),\n];\n```\n\n5. Create integration tests for agents in `tests/integration/agents.test.ts`:\n```typescript\nimport { describe, it, expect, beforeAll } from 'vitest';\nimport { AteraClient } from '../../src';\nimport { setupServer } from '../mocks/server';\n\ndescribe('Agents Resource', () => {\n  const client = new AteraClient({\n    apiKey: 'test-api-key',\n  });\n\n  beforeAll(() => {\n    setupServer();\n  });\n\n  it('should list agents', async () => {\n    const response = await client.agents.list();\n    expect(response.items).toHaveLength(2);\n    expect(response.totalItemCount).toBe(5);\n    expect(response.page).toBe(1);\n    expect(response.nextLink).not.toBeNull();\n  });\n\n  it('should get agent by ID', async () => {\n    const agent = await client.agents.get(12345);\n    expect(agent.AgentID).toBe(12345);\n    expect(agent.MachineName).toBe('DESKTOP-ABC123');\n  });\n\n  it('should get agent by machine name', async () => {\n    const agent = await client.agents.getByMachineName('DESKTOP-ABC123');\n    expect(agent.AgentID).toBe(12345);\n    expect(agent.MachineName).toBe('DESKTOP-ABC123');\n  });\n\n  it('should delete an agent', async () => {\n    await expect(client.agents.delete(12345)).resolves.not.toThrow();\n  });\n\n  it('should run PowerShell script', async () => {\n    const result = await client.agents.runPowerShell(12345, 1, {\n      Script: 'Get-Process',\n      ScriptName: 'List Processes',\n      Timeout: 60\n    });\n    expect(result).toBeDefined();\n  });\n\n  it('should auto-paginate through all agents', async () => {\n    const allAgents = await client.agents.listAll().toArray();\n    expect(allAgents.length).toBeGreaterThan(2);\n  });\n});\n```",
        "testStrategy": "1. Test listing agents with pagination\n2. Test retrieving a single agent by ID\n3. Test retrieving an agent by machine name\n4. Test deleting an agent\n5. Test running PowerShell scripts\n6. Test auto-pagination with listAll()\n7. Test filtering parameters (customerId, folderId, online)\n8. Test error handling for non-existent agents",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Tickets resource",
        "description": "Create the Tickets resource with methods for CRUD operations, comments, work hours, timesheets, filters, and statuses.",
        "details": "1. Create `src/resources/tickets.ts`:\n```typescript\nimport { HttpClient } from '../http';\nimport {\n  Ticket,\n  TicketListParams,\n  TicketCreateParams,\n  TicketUpdateParams,\n  TicketComment,\n  TicketCommentCreateParams,\n  TicketWorkHour,\n  TicketWorkHourCreateParams,\n  TicketTimesheet,\n  TicketTimesheetCreateParams,\n  PaginatedResponse\n} from '../types';\nimport { PaginatedResults } from '../pagination';\n\nexport class TicketsResource {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * List tickets with pagination\n   */\n  async list(params: TicketListParams = {}): Promise<PaginatedResponse<Ticket>> {\n    const queryParams: Record<string, any> = {\n      Page: params.page || 1,\n      ItemsInPage: params.itemsInPage || 50,\n    };\n\n    if (params.ticketStatus) queryParams.TicketStatus = params.ticketStatus;\n    if (params.customerId) queryParams.CustomerID = params.customerId;\n    if (params.technicianId) queryParams.TechnicianID = params.technicianId;\n    if (params.dateFrom) queryParams.DateFrom = params.dateFrom;\n    if (params.dateTo) queryParams.DateTo = params.dateTo;\n\n    return this.http.request<PaginatedResponse<Ticket>>('/tickets', {\n      params: queryParams,\n    });\n  }\n\n  /**\n   * Get all tickets (auto-paginated)\n   */\n  listAll(params: Omit<TicketListParams, 'page' | 'itemsInPage'> = {}): PaginatedResults<Ticket> {\n    return new PaginatedResults<Ticket>(\n      (pageParams) => this.list({ ...params, ...pageParams }),\n      { itemsInPage: 50 }\n    );\n  }\n\n  /**\n   * Get ticket by ID\n   */\n  async get(ticketId: number): Promise<Ticket> {\n    return this.http.request<Ticket>(`/tickets/${ticketId}`);\n  }\n\n  /**\n   * Create a new ticket\n   */\n  async create(data: TicketCreateParams): Promise<Ticket> {\n    return this.http.request<Ticket>('/tickets', {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * Update an existing ticket\n   */\n  async update(ticketId: number, data: TicketUpdateParams): Promise<Ticket> {\n    return this.http.request<Ticket>(`/tickets/${ticketId}`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * Delete a ticket\n   */\n  async delete(ticketId: number): Promise<void> {\n    await this.http.request<void>(`/tickets/${ticketId}`, { method: 'DELETE' });\n  }\n\n  /**\n   * List ticket comments\n   */\n  async listComments(ticketId: number, params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<TicketComment>> {\n    return this.http.request<PaginatedResponse<TicketComment>>(`/tickets/${ticketId}/comments`, {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * Create a ticket comment\n   */\n  async createComment(ticketId: number, data: TicketCommentCreateParams): Promise<TicketComment> {\n    return this.http.request<TicketComment>(`/tickets/${ticketId}/comments`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * List ticket work hours\n   */\n  async listWorkHours(ticketId: number, params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<TicketWorkHour>> {\n    return this.http.request<PaginatedResponse<TicketWorkHour>>(`/tickets/${ticketId}/workhours`, {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * Create ticket work hours\n   */\n  async createWorkHours(ticketId: number, data: TicketWorkHourCreateParams): Promise<TicketWorkHour> {\n    return this.http.request<TicketWorkHour>(`/tickets/${ticketId}/workhours`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * List ticket billable durations\n   */\n  async listBillableDurations(ticketId: number, params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<any>> {\n    return this.http.request<PaginatedResponse<any>>(`/tickets/${ticketId}/billabledurations`, {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * List ticket timesheets\n   */\n  async listTimesheets(ticketId: number, params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<TicketTimesheet>> {\n    return this.http.request<PaginatedResponse<TicketTimesheet>>(`/tickets/${ticketId}/timesheets`, {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * Create ticket timesheet\n   */\n  async createTimesheet(ticketId: number, data: TicketTimesheetCreateParams): Promise<TicketTimesheet> {\n    return this.http.request<TicketTimesheet>(`/tickets/${ticketId}/timesheets`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * List ticket filters\n   */\n  async listFilters(): Promise<any[]> {\n    return this.http.request<any[]>('/tickets/filters');\n  }\n\n  /**\n   * List ticket statuses\n   */\n  async listStatuses(): Promise<string[]> {\n    return this.http.request<string[]>('/tickets/statuses');\n  }\n}\n```\n\n2. Update `src/client.ts` to include the Tickets resource:\n```typescript\nimport { TicketsResource } from './resources/tickets';\n\nexport class AteraClient {\n  // ... existing code\n\n  // Resources\n  public readonly agents: AgentsResource;\n  public readonly tickets: TicketsResource;\n\n  constructor(config: AteraClientConfig) {\n    // ... existing code\n    \n    // Initialize resources\n    this.agents = new AgentsResource(this.http);\n    this.tickets = new TicketsResource(this.http);\n  }\n}\n```\n\n3. Create test fixtures for tickets in `tests/fixtures/tickets/`\n4. Create mock handlers for ticket endpoints in `tests/mocks/handlers.ts`\n5. Create integration tests for tickets in `tests/integration/tickets.test.ts`",
        "testStrategy": "1. Test listing tickets with pagination\n2. Test retrieving a single ticket by ID\n3. Test creating a new ticket\n4. Test updating an existing ticket\n5. Test deleting a ticket\n6. Test listing and creating comments\n7. Test listing and creating work hours\n8. Test listing billable durations\n9. Test listing and creating timesheets\n10. Test listing filters and statuses\n11. Test auto-pagination with listAll()\n12. Test filtering parameters (ticketStatus, customerId, technicianId, dateRange)",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Devices resources (Generic, HTTP, SNMP, TCP)",
        "description": "Create the Devices resources with methods for managing generic devices, HTTP monitors, SNMP devices, and TCP monitors.",
        "details": "1. Create `src/resources/devices.ts` for generic devices:\n```typescript\nimport { HttpClient } from '../http';\nimport { Device, PaginatedResponse } from '../types';\nimport { PaginatedResults } from '../pagination';\n\nexport class DevicesResource {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * List devices with pagination\n   */\n  async list(params: { page?: number; itemsInPage?: number; customerId?: number } = {}): Promise<PaginatedResponse<Device>> {\n    const queryParams: Record<string, any> = {\n      Page: params.page || 1,\n      ItemsInPage: params.itemsInPage || 50,\n    };\n\n    if (params.customerId) queryParams.CustomerID = params.customerId;\n\n    return this.http.request<PaginatedResponse<Device>>('/devices', {\n      params: queryParams,\n    });\n  }\n\n  /**\n   * Get all devices (auto-paginated)\n   */\n  listAll(params: { customerId?: number } = {}): PaginatedResults<Device> {\n    return new PaginatedResults<Device>(\n      (pageParams) => this.list({ ...params, ...pageParams }),\n      { itemsInPage: 50 }\n    );\n  }\n\n  /**\n   * Get device by ID\n   */\n  async get(deviceId: number): Promise<Device> {\n    return this.http.request<Device>(`/devices/${deviceId}`);\n  }\n\n  /**\n   * Create a new device\n   */\n  async create(data: Partial<Device>): Promise<Device> {\n    return this.http.request<Device>('/devices', {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * Update an existing device\n   */\n  async update(deviceId: number, data: Partial<Device>): Promise<Device> {\n    return this.http.request<Device>(`/devices/${deviceId}`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * Delete a device\n   */\n  async delete(deviceId: number): Promise<void> {\n    await this.http.request<void>(`/devices/${deviceId}`, { method: 'DELETE' });\n  }\n}\n```\n\n2. Create `src/resources/devices-http.ts` for HTTP monitors:\n```typescript\nimport { HttpClient } from '../http';\nimport { Device, PaginatedResponse } from '../types';\nimport { PaginatedResults } from '../pagination';\n\nexport interface HttpDevice extends Device {\n  URL: string;\n  CheckIntervalMinutes: number;\n  Timeout: number;\n}\n\nexport class DevicesHttpResource {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * List HTTP devices with pagination\n   */\n  async list(params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<HttpDevice>> {\n    return this.http.request<PaginatedResponse<HttpDevice>>('/devices/httpdevices', {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * Get all HTTP devices (auto-paginated)\n   */\n  listAll(): PaginatedResults<HttpDevice> {\n    return new PaginatedResults<HttpDevice>(\n      (params) => this.list(params),\n      { itemsInPage: 50 }\n    );\n  }\n\n  /**\n   * Create a new HTTP device\n   */\n  async create(data: Partial<HttpDevice>): Promise<HttpDevice> {\n    return this.http.request<HttpDevice>('/devices/httpdevices', {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * Delete an HTTP device\n   */\n  async delete(deviceId: number): Promise<void> {\n    await this.http.request<void>(`/devices/httpdevices/${deviceId}`, { method: 'DELETE' });\n  }\n}\n```\n\n3. Create similar resources for SNMP and TCP devices:\n   - `src/resources/devices-snmp.ts`\n   - `src/resources/devices-tcp.ts`\n\n4. Update `src/client.ts` to include all device resources:\n```typescript\nimport { DevicesResource } from './resources/devices';\nimport { DevicesHttpResource } from './resources/devices-http';\nimport { DevicesSnmpResource } from './resources/devices-snmp';\nimport { DevicesTcpResource } from './resources/devices-tcp';\n\nexport class AteraClient {\n  // ... existing code\n\n  // Resources\n  public readonly agents: AgentsResource;\n  public readonly tickets: TicketsResource;\n  public readonly devices: DevicesResource;\n  public readonly devicesHttp: DevicesHttpResource;\n  public readonly devicesSnmp: DevicesSnmpResource;\n  public readonly devicesTcp: DevicesTcpResource;\n\n  constructor(config: AteraClientConfig) {\n    // ... existing code\n    \n    // Initialize resources\n    this.agents = new AgentsResource(this.http);\n    this.tickets = new TicketsResource(this.http);\n    this.devices = new DevicesResource(this.http);\n    this.devicesHttp = new DevicesHttpResource(this.http);\n    this.devicesSnmp = new DevicesSnmpResource(this.http);\n    this.devicesTcp = new DevicesTcpResource(this.http);\n  }\n}\n```\n\n5. Create test fixtures for devices in `tests/fixtures/devices/`\n6. Create mock handlers for device endpoints in `tests/mocks/handlers.ts`\n7. Create integration tests for devices in `tests/integration/devices.test.ts`",
        "testStrategy": "1. Test listing generic devices with pagination\n2. Test retrieving a single device by ID\n3. Test creating, updating, and deleting generic devices\n4. Test listing, creating, and deleting HTTP devices\n5. Test listing, creating, and deleting SNMP devices\n6. Test listing, creating, and deleting TCP devices\n7. Test auto-pagination with listAll() for all device types\n8. Test filtering by customerId for generic devices",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Customers and Contacts resources",
        "description": "Create the Customers and Contacts resources with methods for CRUD operations and related data retrieval.",
        "details": "1. Create `src/resources/customers.ts`:\n```typescript\nimport { HttpClient } from '../http';\nimport { Customer, Agent, Alert, PaginatedResponse } from '../types';\nimport { PaginatedResults } from '../pagination';\n\nexport class CustomersResource {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * List customers with pagination\n   */\n  async list(params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<Customer>> {\n    return this.http.request<PaginatedResponse<Customer>>('/customers', {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * Get all customers (auto-paginated)\n   */\n  listAll(): PaginatedResults<Customer> {\n    return new PaginatedResults<Customer>(\n      (params) => this.list(params),\n      { itemsInPage: 50 }\n    );\n  }\n\n  /**\n   * Get customer by ID\n   */\n  async get(customerId: number): Promise<Customer> {\n    return this.http.request<Customer>(`/customers/${customerId}`);\n  }\n\n  /**\n   * Create a new customer\n   */\n  async create(data: Partial<Customer>): Promise<Customer> {\n    return this.http.request<Customer>('/customers', {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * Update an existing customer\n   */\n  async update(customerId: number, data: Partial<Customer>): Promise<Customer> {\n    return this.http.request<Customer>(`/customers/${customerId}`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * Delete a customer\n   */\n  async delete(customerId: number): Promise<void> {\n    await this.http.request<void>(`/customers/${customerId}`, { method: 'DELETE' });\n  }\n\n  /**\n   * List agents for a customer\n   */\n  async listAgents(customerId: number, params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<Agent>> {\n    return this.http.request<PaginatedResponse<Agent>>(`/customers/${customerId}/agents`, {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * List alerts for a customer\n   */\n  async listAlerts(customerId: number, params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<Alert>> {\n    return this.http.request<PaginatedResponse<Alert>>(`/customers/${customerId}/alerts`, {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n}\n```\n\n2. Create `src/resources/contacts.ts`:\n```typescript\nimport { HttpClient } from '../http';\nimport { Contact, PaginatedResponse } from '../types';\nimport { PaginatedResults } from '../pagination';\n\nexport class ContactsResource {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * List contacts with pagination\n   */\n  async list(params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<Contact>> {\n    return this.http.request<PaginatedResponse<Contact>>('/contacts', {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * Get all contacts (auto-paginated)\n   */\n  listAll(): PaginatedResults<Contact> {\n    return new PaginatedResults<Contact>(\n      (params) => this.list(params),\n      { itemsInPage: 50 }\n    );\n  }\n\n  /**\n   * Get contact by ID\n   */\n  async get(contactId: number): Promise<Contact> {\n    return this.http.request<Contact>(`/contacts/${contactId}`);\n  }\n\n  /**\n   * Create a new contact\n   */\n  async create(data: Partial<Contact>): Promise<Contact> {\n    return this.http.request<Contact>('/contacts', {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * Update an existing contact\n   */\n  async update(contactId: number, data: Partial<Contact>): Promise<Contact> {\n    return this.http.request<Contact>(`/contacts/${contactId}`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * Delete a contact\n   */\n  async delete(contactId: number): Promise<void> {\n    await this.http.request<void>(`/contacts/${contactId}`, { method: 'DELETE' });\n  }\n\n  /**\n   * List contacts for a customer\n   */\n  async listByCustomer(customerId: number, params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<Contact>> {\n    return this.http.request<PaginatedResponse<Contact>>(`/contacts/customer/${customerId}`, {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n}\n```\n\n3. Update `src/client.ts` to include the Customers and Contacts resources:\n```typescript\nimport { CustomersResource } from './resources/customers';\nimport { ContactsResource } from './resources/contacts';\n\nexport class AteraClient {\n  // ... existing code\n\n  // Resources\n  public readonly agents: AgentsResource;\n  public readonly tickets: TicketsResource;\n  public readonly devices: DevicesResource;\n  public readonly devicesHttp: DevicesHttpResource;\n  public readonly devicesSnmp: DevicesSnmpResource;\n  public readonly devicesTcp: DevicesTcpResource;\n  public readonly customers: CustomersResource;\n  public readonly contacts: ContactsResource;\n\n  constructor(config: AteraClientConfig) {\n    // ... existing code\n    \n    // Initialize resources\n    this.agents = new AgentsResource(this.http);\n    this.tickets = new TicketsResource(this.http);\n    this.devices = new DevicesResource(this.http);\n    this.devicesHttp = new DevicesHttpResource(this.http);\n    this.devicesSnmp = new DevicesSnmpResource(this.http);\n    this.devicesTcp = new DevicesTcpResource(this.http);\n    this.customers = new CustomersResource(this.http);\n    this.contacts = new ContactsResource(this.http);\n  }\n}\n```\n\n4. Create test fixtures for customers and contacts in `tests/fixtures/`\n5. Create mock handlers for customer and contact endpoints in `tests/mocks/handlers.ts`\n6. Create integration tests for customers and contacts in `tests/integration/`",
        "testStrategy": "1. Test listing customers with pagination\n2. Test retrieving a single customer by ID\n3. Test creating, updating, and deleting customers\n4. Test listing agents for a customer\n5. Test listing alerts for a customer\n6. Test listing contacts with pagination\n7. Test retrieving a single contact by ID\n8. Test creating, updating, and deleting contacts\n9. Test listing contacts for a specific customer\n10. Test auto-pagination with listAll() for both resources",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Alerts, Contracts, Billing, Rates, and Knowledge Base resources",
        "description": "Create the remaining core resources for alerts, contracts, billing, rates, and knowledge base data.",
        "details": "1. Create `src/resources/alerts.ts`:\n```typescript\nimport { HttpClient } from '../http';\nimport { Alert, PaginatedResponse } from '../types';\nimport { PaginatedResults } from '../pagination';\n\nexport class AlertsResource {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * List alerts with pagination\n   */\n  async list(params: { page?: number; itemsInPage?: number; alertSeverity?: string; customerId?: number; archived?: boolean } = {}): Promise<PaginatedResponse<Alert>> {\n    const queryParams: Record<string, any> = {\n      Page: params.page || 1,\n      ItemsInPage: params.itemsInPage || 50,\n    };\n\n    if (params.alertSeverity) queryParams.AlertSeverity = params.alertSeverity;\n    if (params.customerId) queryParams.CustomerID = params.customerId;\n    if (params.archived !== undefined) queryParams.Archived = params.archived;\n\n    return this.http.request<PaginatedResponse<Alert>>('/alerts', {\n      params: queryParams,\n    });\n  }\n\n  /**\n   * Get all alerts (auto-paginated)\n   */\n  listAll(params: { alertSeverity?: string; customerId?: number; archived?: boolean } = {}): PaginatedResults<Alert> {\n    return new PaginatedResults<Alert>(\n      (pageParams) => this.list({ ...params, ...pageParams }),\n      { itemsInPage: 50 }\n    );\n  }\n\n  /**\n   * Get alert by ID\n   */\n  async get(alertId: number): Promise<Alert> {\n    return this.http.request<Alert>(`/alerts/${alertId}`);\n  }\n\n  /**\n   * List alerts for an agent\n   */\n  async listByAgent(agentId: number, params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<Alert>> {\n    return this.http.request<PaginatedResponse<Alert>>(`/alerts/agent/${agentId}`, {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * List alerts for a device\n   */\n  async listByDevice(deviceId: number, params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<Alert>> {\n    return this.http.request<PaginatedResponse<Alert>>(`/alerts/device/${deviceId}`, {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n}\n```\n\n2. Create `src/resources/contracts.ts`:\n```typescript\nimport { HttpClient } from '../http';\nimport { Contract, PaginatedResponse } from '../types';\nimport { PaginatedResults } from '../pagination';\n\nexport class ContractsResource {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * List contracts with pagination\n   */\n  async list(params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<Contract>> {\n    return this.http.request<PaginatedResponse<Contract>>('/contracts', {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * Get all contracts (auto-paginated)\n   */\n  listAll(): PaginatedResults<Contract> {\n    return new PaginatedResults<Contract>(\n      (params) => this.list(params),\n      { itemsInPage: 50 }\n    );\n  }\n\n  /**\n   * Get contract by ID\n   */\n  async get(contractId: number): Promise<Contract> {\n    return this.http.request<Contract>(`/contracts/${contractId}`);\n  }\n\n  /**\n   * List contracts for a customer\n   */\n  async listByCustomer(customerId: number, params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<Contract>> {\n    return this.http.request<PaginatedResponse<Contract>>(`/contracts/customer/${customerId}`, {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n}\n```\n\n3. Create `src/resources/billing.ts`:\n```typescript\nimport { HttpClient } from '../http';\nimport { PaginatedResponse } from '../types';\nimport { PaginatedResults } from '../pagination';\n\nexport interface Invoice {\n  InvoiceID: number;\n  InvoiceNumber: string;\n  CustomerID: number;\n  CustomerName: string;\n  Status: string;\n  IssueDate: string;\n  DueDate: string;\n  Total: number;\n  Currency: string;\n  CreatedDate: string;\n}\n\nexport class BillingResource {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * List invoices with pagination\n   */\n  async listInvoices(params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<Invoice>> {\n    return this.http.request<PaginatedResponse<Invoice>>('/billing/invoices', {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * Get invoice by ID\n   */\n  async getInvoice(invoiceId: number): Promise<Invoice> {\n    return this.http.request<Invoice>(`/billing/invoices/${invoiceId}`);\n  }\n}\n```\n\n4. Create `src/resources/rates.ts`:\n```typescript\nimport { HttpClient } from '../http';\nimport { PaginatedResponse } from '../types';\nimport { PaginatedResults } from '../pagination';\n\nexport interface Rate {\n  RateID: number;\n  RateName: string;\n  RateType: string;\n  Price: number;\n  Currency: string;\n  CreatedDate: string;\n}\n\nexport interface Product {\n  ProductID: number;\n  ProductName: string;\n  Price: number;\n  Currency: string;\n  CreatedDate: string;\n}\n\nexport interface Expense {\n  ExpenseID: number;\n  ExpenseName: string;\n  Price: number;\n  Currency: string;\n  CreatedDate: string;\n}\n\nexport class RatesResource {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * List rates with pagination\n   */\n  async list(params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<Rate>> {\n    return this.http.request<PaginatedResponse<Rate>>('/rates', {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * Get rate by ID\n   */\n  async get(rateId: number): Promise<Rate> {\n    return this.http.request<Rate>(`/rates/${rateId}`);\n  }\n\n  /**\n   * Create a new rate\n   */\n  async create(data: Partial<Rate>): Promise<Rate> {\n    return this.http.request<Rate>('/rates', {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * Update an existing rate\n   */\n  async update(rateId: number, data: Partial<Rate>): Promise<Rate> {\n    return this.http.request<Rate>(`/rates/${rateId}`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  /**\n   * Delete a rate\n   */\n  async delete(rateId: number): Promise<void> {\n    await this.http.request<void>(`/rates/${rateId}`, { method: 'DELETE' });\n  }\n\n  /**\n   * List products with pagination\n   */\n  async listProducts(params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<Product>> {\n    return this.http.request<PaginatedResponse<Product>>('/rates/products', {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * Get product by ID\n   */\n  async getProduct(productId: number): Promise<Product> {\n    return this.http.request<Product>(`/rates/products/${productId}`);\n  }\n\n  /**\n   * List expenses with pagination\n   */\n  async listExpenses(params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<Expense>> {\n    return this.http.request<PaginatedResponse<Expense>>('/rates/expenses', {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * Get expense by ID\n   */\n  async getExpense(expenseId: number): Promise<Expense> {\n    return this.http.request<Expense>(`/rates/expenses/${expenseId}`);\n  }\n}\n```\n\n5. Create `src/resources/knowledge-base.ts`:\n```typescript\nimport { HttpClient } from '../http';\nimport { PaginatedResponse } from '../types';\nimport { PaginatedResults } from '../pagination';\n\nexport interface KnowledgeBaseArticle {\n  ArticleID: number;\n  Title: string;\n  Content: string;\n  CreatedDate: string;\n  LastModifiedDate: string;\n  Author: string;\n  Tags: string[];\n}\n\nexport class KnowledgeBaseResource {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * List knowledge base articles with pagination\n   */\n  async list(params: { page?: number; itemsInPage?: number } = {}): Promise<PaginatedResponse<KnowledgeBaseArticle>> {\n    return this.http.request<PaginatedResponse<KnowledgeBaseArticle>>('/knowledgebase', {\n      params: {\n        Page: params.page || 1,\n        ItemsInPage: params.itemsInPage || 50,\n      },\n    });\n  }\n\n  /**\n   * Get all knowledge base articles (auto-paginated)\n   */\n  listAll(): PaginatedResults<KnowledgeBaseArticle> {\n    return new PaginatedResults<KnowledgeBaseArticle>(\n      (params) => this.list(params),\n      { itemsInPage: 50 }\n    );\n  }\n}\n```\n\n6. Update `src/client.ts` to include these resources:\n```typescript\nimport { AlertsResource } from './resources/alerts';\nimport { ContractsResource } from './resources/contracts';\nimport { BillingResource } from './resources/billing';\nimport { RatesResource } from './resources/rates';\nimport { KnowledgeBaseResource } from './resources/knowledge-base';\n\nexport class AteraClient {\n  // ... existing code\n\n  // Resources\n  public readonly agents: AgentsResource;\n  public readonly tickets: TicketsResource;\n  public readonly devices: DevicesResource;\n  public readonly devicesHttp: DevicesHttpResource;\n  public readonly devicesSnmp: DevicesSnmpResource;\n  public readonly devicesTcp: DevicesTcpResource;\n  public readonly customers: CustomersResource;\n  public readonly contacts: ContactsResource;\n  public readonly alerts: AlertsResource;\n  public readonly contracts: ContractsResource;\n  public readonly billing: BillingResource;\n  public readonly rates: RatesResource;\n  public readonly knowledgeBase: KnowledgeBaseResource;\n\n  constructor(config: AteraClientConfig) {\n    // ... existing code\n    \n    // Initialize resources\n    this.agents = new AgentsResource(this.http);\n    this.tickets = new TicketsResource(this.http);\n    this.devices = new DevicesResource(this.http);\n    this.devicesHttp = new DevicesHttpResource(this.http);\n    this.devicesSnmp = new DevicesSnmpResource(this.http);\n    this.devicesTcp = new DevicesTcpResource(this.http);\n    this.customers = new CustomersResource(this.http);\n    this.contacts = new ContactsResource(this.http);\n    this.alerts = new AlertsResource(this.http);\n    this.contracts = new ContractsResource(this.http);\n    this.billing = new BillingResource(this.http);\n    this.rates = new RatesResource(this.http);\n    this.knowledgeBase = new KnowledgeBaseResource(this.http);\n  }\n}\n```\n\n7. Create test fixtures for these resources in `tests/fixtures/`\n8. Create mock handlers for these endpoints in `tests/mocks/handlers.ts`\n9. Create integration tests for these resources in `tests/integration/`",
        "testStrategy": "1. Test listing alerts with pagination and filters\n2. Test retrieving a single alert by ID\n3. Test listing alerts by agent and device\n4. Test listing contracts with pagination\n5. Test retrieving a single contract by ID\n6. Test listing contracts by customer\n7. Test listing invoices with pagination\n8. Test retrieving a single invoice by ID\n9. Test listing, creating, updating, and deleting rates\n10. Test listing products and expenses\n11. Test retrieving single products and expenses\n12. Test listing knowledge base articles\n13. Test auto-pagination with listAll() for applicable resources",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Custom Values resources",
        "description": "Create the Custom Values resources for managing custom fields and values for agents, tickets, customers, contacts, and contracts.",
        "details": "1. Create `src/resources/custom-values.ts`:\n```typescript\nimport { HttpClient } from '../http';\nimport { PaginatedResponse } from '../types';\n\nexport interface CustomField {\n  FieldID: number;\n  FieldName: string;\n  FieldType: string;\n  IsRequired: boolean;\n  DefaultValue: string;\n  CreatedDate: string;\n}\n\nexport interface CustomValue {\n  FieldID: number;\n  FieldName: string;\n  Value: string;\n}\n\nexport interface CustomValueSetParams {\n  FieldID?: number;\n  FieldName?: string;\n  Value: string;\n}\n\nexport class CustomValuesResource {\n  constructor(private http: HttpClient) {}\n\n  // Agent Custom Values\n  async listAgentFields(): Promise<CustomField[]> {\n    return this.http.request<CustomField[]>('/customvalues/agentfield');\n  }\n\n  async listByAgent(agentId: number): Promise<CustomValue[]> {\n    return this.http.request<CustomValue[]>(`/customvalues/agent/${agentId}`);\n  }\n\n  async getAgentFieldByName(fieldName: string): Promise<CustomField> {\n    return this.http.request<CustomField>(`/customvalues/agentfieldname/${encodeURIComponent(fieldName)}`);\n  }\n\n  async setAgentValue(agentId: number, data: CustomValueSetParams): Promise<CustomValue> {\n    return this.http.request<CustomValue>(`/customvalues/agent/${agentId}`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  async deleteAgentValue(agentId: number, fieldId: number): Promise<void> {\n    await this.http.request<void>(`/customvalues/agent/${agentId}/field/${fieldId}`, {\n      method: 'DELETE',\n    });\n  }\n\n  // Ticket Custom Values\n  async listTicketFields(): Promise<CustomField[]> {\n    return this.http.request<CustomField[]>('/customvalues/ticketfield');\n  }\n\n  async listByTicket(ticketId: number): Promise<CustomValue[]> {\n    return this.http.request<CustomValue[]>(`/customvalues/ticket/${ticketId}`);\n  }\n\n  async getTicketFieldByName(fieldName: string): Promise<CustomField> {\n    return this.http.request<CustomField>(`/customvalues/ticketfieldname/${encodeURIComponent(fieldName)}`);\n  }\n\n  async setTicketValue(ticketId: number, data: CustomValueSetParams): Promise<CustomValue> {\n    return this.http.request<CustomValue>(`/customvalues/ticket/${ticketId}`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  async deleteTicketValue(ticketId: number, fieldId: number): Promise<void> {\n    await this.http.request<void>(`/customvalues/ticket/${ticketId}/field/${fieldId}`, {\n      method: 'DELETE',\n    });\n  }\n\n  // Customer Custom Values\n  async listCustomerFields(): Promise<CustomField[]> {\n    return this.http.request<CustomField[]>('/customvalues/customerfield');\n  }\n\n  async listByCustomer(customerId: number): Promise<CustomValue[]> {\n    return this.http.request<CustomValue[]>(`/customvalues/customer/${customerId}`);\n  }\n\n  async getCustomerFieldByName(fieldName: string): Promise<CustomField> {\n    return this.http.request<CustomField>(`/customvalues/customerfieldname/${encodeURIComponent(fieldName)}`);\n  }\n\n  async setCustomerValue(customerId: number, data: CustomValueSetParams): Promise<CustomValue> {\n    return this.http.request<CustomValue>(`/customvalues/customer/${customerId}`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  async deleteCustomerValue(customerId: number, fieldId: number): Promise<void> {\n    await this.http.request<void>(`/customvalues/customer/${customerId}/field/${fieldId}`, {\n      method: 'DELETE',\n    });\n  }\n\n  // Contact Custom Values\n  async listContactFields(): Promise<CustomField[]> {\n    return this.http.request<CustomField[]>('/customvalues/contactfield');\n  }\n\n  async listByContact(contactId: number): Promise<CustomValue[]> {\n    return this.http.request<CustomValue[]>(`/customvalues/contact/${contactId}`);\n  }\n\n  async getContactFieldByName(fieldName: string): Promise<CustomField> {\n    return this.http.request<CustomField>(`/customvalues/contactfieldname/${encodeURIComponent(fieldName)}`);\n  }\n\n  async setContactValue(contactId: number, data: CustomValueSetParams): Promise<CustomValue> {\n    return this.http.request<CustomValue>(`/customvalues/contact/${contactId}`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  async deleteContactValue(contactId: number, fieldId: number): Promise<void> {\n    await this.http.request<void>(`/customvalues/contact/${contactId}/field/${fieldId}`, {\n      method: 'DELETE',\n    });\n  }\n\n  // Contract Custom Values\n  async listContractFields(): Promise<CustomField[]> {\n    return this.http.request<CustomField[]>('/customvalues/contractfield');\n  }\n\n  async listByContract(contractId: number): Promise<CustomValue[]> {\n    return this.http.request<CustomValue[]>(`/customvalues/contract/${contractId}`);\n  }\n\n  async getContractFieldByName(fieldName: string): Promise<CustomField> {\n    return this.http.request<CustomField>(`/customvalues/contractfieldname/${encodeURIComponent(fieldName)}`);\n  }\n\n  async createContractField(data: Partial<CustomField>): Promise<CustomField> {\n    return this.http.request<CustomField>('/customvalues/contractfield', {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  async setContractValue(contractId: number, data: CustomValueSetParams): Promise<CustomValue> {\n    return this.http.request<CustomValue>(`/customvalues/contract/${contractId}`, {\n      method: 'POST',\n      body: data,\n    });\n  }\n\n  async deleteContractValue(contractId: number, fieldId: number): Promise<void> {\n    await this.http.request<void>(`/customvalues/contract/${contractId}/field/${fieldId}`, {\n      method: 'DELETE',\n    });\n  }\n}\n```\n\n2. Update `src/client.ts` to include the Custom Values resource:\n```typescript\nimport { CustomValuesResource } from './resources/custom-values';\n\nexport class AteraClient {\n  // ... existing code\n\n  // Resources\n  public readonly agents: AgentsResource;\n  public readonly tickets: TicketsResource;\n  public readonly devices: DevicesResource;\n  public readonly devicesHttp: DevicesHttpResource;\n  public readonly devicesSnmp: DevicesSnmpResource;\n  public readonly devicesTcp: DevicesTcpResource;\n  public readonly customers: CustomersResource;\n  public readonly contacts: ContactsResource;\n  public readonly alerts: AlertsResource;\n  public readonly contracts: ContractsResource;\n  public readonly billing: BillingResource;\n  public readonly rates: RatesResource;\n  public readonly knowledgeBase: KnowledgeBaseResource;\n  public readonly customValues: CustomValuesResource;\n\n  constructor(config: AteraClientConfig) {\n    // ... existing code\n    \n    // Initialize resources\n    this.agents = new AgentsResource(this.http);\n    this.tickets = new TicketsResource(this.http);\n    this.devices = new DevicesResource(this.http);\n    this.devicesHttp = new DevicesHttpResource(this.http);\n    this.devicesSnmp = new DevicesSnmpResource(this.http);\n    this.devicesTcp = new DevicesTcpResource(this.http);\n    this.customers = new CustomersResource(this.http);\n    this.contacts = new ContactsResource(this.http);\n    this.alerts = new AlertsResource(this.http);\n    this.contracts = new ContractsResource(this.http);\n    this.billing = new BillingResource(this.http);\n    this.rates = new RatesResource(this.http);\n    this.knowledgeBase = new KnowledgeBaseResource(this.http);\n    this.customValues = new CustomValuesResource(this.http);\n  }\n}\n```\n\n3. Create test fixtures for custom values in `tests/fixtures/custom-values/`\n4. Create mock handlers for custom values endpoints in `tests/mocks/handlers.ts`\n5. Create integration tests for custom values in `tests/integration/custom-values.test.ts`",
        "testStrategy": "1. Test listing agent custom fields\n2. Test getting agent custom values\n3. Test setting and deleting agent custom values\n4. Test listing ticket custom fields\n5. Test getting ticket custom values\n6. Test setting and deleting ticket custom values\n7. Test listing customer custom fields\n8. Test getting customer custom values\n9. Test setting and deleting customer custom values\n10. Test listing contact custom fields\n11. Test getting contact custom values\n12. Test setting and deleting contact custom values\n13. Test listing contract custom fields\n14. Test getting contract custom values\n15. Test creating contract custom fields\n16. Test setting and deleting contract custom values",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Create comprehensive test suite and documentation",
        "description": "Set up a complete test suite with mocked API responses and create comprehensive documentation for the library.",
        "details": "1. Set up test infrastructure in `tests/setup.ts`:\n```typescript\nimport { beforeAll, afterAll, afterEach } from 'vitest';\nimport { setupServer } from 'msw/node';\nimport { handlers } from './mocks/handlers';\n\nconst server = setupServer(...handlers);\n\nbeforeAll(() => server.listen({ onUnhandledRequest: 'error' }));\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n```\n\n2. Create `tests/mocks/server.ts`:\n```typescript\nimport { setupServer as setupMswServer } from 'msw/node';\nimport { handlers } from './handlers';\n\nexport function setupServer() {\n  const server = setupMswServer(...handlers);\n  server.listen({ onUnhandledRequest: 'error' });\n  return server;\n}\n```\n\n3. Create unit tests for core functionality:\n   - `tests/unit/client.test.ts`\n   - `tests/unit/pagination.test.ts`\n   - `tests/unit/rate-limiter.test.ts`\n   - `tests/unit/http.test.ts`\n   - `tests/unit/errors.test.ts`\n\n4. Create integration tests for all resources:\n   - `tests/integration/agents.test.ts`\n   - `tests/integration/tickets.test.ts`\n   - `tests/integration/devices.test.ts`\n   - `tests/integration/customers.test.ts`\n   - `tests/integration/contacts.test.ts`\n   - `tests/integration/alerts.test.ts`\n   - `tests/integration/custom-values.test.ts`\n   - `tests/integration/contracts.test.ts`\n   - `tests/integration/billing.test.ts`\n   - `tests/integration/rates.test.ts`\n   - `tests/integration/knowledge-base.test.ts`\n\n5. Create comprehensive README.md with usage examples:\n```markdown\n# node-atera\n\nA comprehensive, fully-typed Node.js/TypeScript library providing complete coverage of the Atera REST API v3.\n\n## Installation\n\n```bash\nnpm install node-atera\n```\n\n## Requirements\n\n- Node.js >= 18.0.0\n- TypeScript >= 5.0 (for TypeScript users)\n\n## Quick Start\n\n```typescript\nimport { AteraClient } from 'node-atera';\n\n// Initialize the client\nconst client = new AteraClient({\n  apiKey: 'your-api-key',\n});\n\n// List agents\nconst agents = await client.agents.list();\nconsole.log(`Found ${agents.totalItemCount} agents`);\n\n// Auto-paginate through all agents\nfor await (const agent of client.agents.listAll()) {\n  console.log(agent.MachineName, agent.CustomerName);\n}\n\n// Create a ticket\nconst ticket = await client.tickets.create({\n  TicketTitle: 'Email not working',\n  CustomerID: 123,\n  ContactID: 456,\n  TicketType: 'Problem',\n  TicketPriority: 'High',\n});\n\n// Add a comment to the ticket\nawait client.tickets.createComment(ticket.TicketID, {\n  Comment: 'Working on this issue now.',\n  IsInternal: true,\n});\n```\n\n## Features\n\n- Complete API coverage (90+ endpoints)\n- Strong TypeScript types\n- Simple API key authentication\n- Automatic pagination\n- Rate limit handling (700 req/min)\n- Zero live API testing\n\n## Documentation\n\n### Authentication\n\n```typescript\nconst client = new AteraClient({\n  apiKey: 'your-api-key',\n  // Optional configuration\n  baseUrl: 'https://app.atera.com/api/v3', // Default\n  rateLimiting: {\n    enabled: true,                // Default\n    maxRequests: 700,             // Default\n    windowMs: 60000,              // Default (1 minute)\n    throttleThreshold: 0.8,       // Default (80%)\n    retryAfterMs: 5000,           // Default\n    maxRetries: 3,                // Default\n  },\n});\n```\n\n### Pagination\n\n```typescript\n// Get a single page\nconst page1 = await client.agents.list({ page: 1, itemsInPage: 50 });\n\n// Auto-paginate all results (async generator)\nfor await (const agent of client.agents.listAll()) {\n  console.log(agent.MachineName);\n}\n\n// Collect all into an array\nconst allAgents = await client.agents.listAll().toArray();\n```\n\n### Error Handling\n\n```typescript\nimport { AteraClient, AteraError, AteraAuthenticationError } from 'node-atera';\n\ntry {\n  const agent = await client.agents.get(12345);\n} catch (error) {\n  if (error instanceof AteraAuthenticationError) {\n    console.error('Authentication failed. Check your API key.');\n  } else if (error instanceof AteraError) {\n    console.error(`API error: ${error.message} (${error.statusCode})`);\n    console.error(error.response); // Raw response data\n  } else {\n    console.error('Unexpected error:', error);\n  }\n}\n```\n\n## API Reference\n\n[Include detailed API reference here]\n\n## License\n\nMIT\n```\n\n6. Create CHANGELOG.md:\n```markdown\n# Changelog\n\n## 1.0.0 (YYYY-MM-DD)\n\n- Initial release\n- Complete coverage of Atera API v3\n- Full TypeScript support\n- Automatic pagination\n- Rate limiting\n```\n\n7. Configure package.json for publishing:\n```json\n{\n  \"name\": \"node-atera\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A comprehensive, fully-typed Node.js/TypeScript library for the Atera REST API v3\",\n  \"main\": \"dist/index.js\",\n  \"module\": \"dist/index.mjs\",\n  \"types\": \"dist/index.d.ts\",\n  \"files\": [\n    \"dist\",\n    \"LICENSE\",\n    \"README.md\",\n    \"CHANGELOG.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup src/index.ts --format esm,cjs --dts\",\n    \"test\": \"vitest run\",\n    \"test:watch\": \"vitest\",\n    \"test:coverage\": \"vitest run --coverage\",\n    \"prepublishOnly\": \"npm run build && npm run test\"\n  },\n  \"keywords\": [\n    \"atera\",\n    \"api\",\n    \"rest\",\n    \"client\",\n    \"msp\",\n    \"rmm\",\n    \"psa\"\n  ],\n  \"author\": \"WYRE Technology\",\n  \"license\": \"MIT\",\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/atera/node-atera.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/atera/node-atera/issues\"\n  },\n  \"homepage\": \"https://github.com/atera/node-atera#readme\"\n}\n```",
        "testStrategy": "1. Verify all unit tests pass\n2. Verify all integration tests pass\n3. Check test coverage (target: 90%+)\n4. Validate documentation examples\n5. Test package build process\n6. Verify TypeScript declarations are generated correctly\n7. Ensure README examples are accurate and working",
        "priority": "high",
        "dependencies": [
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-02-05T01:51:13.965Z",
      "updated": "2026-02-05T01:51:13.965Z",
      "description": "Tasks for node-atera context"
    }
  },
  "node-halopsa": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up project structure and core configuration",
        "description": "Initialize the project with the required directory structure, package.json, TypeScript configuration, and build tools as specified in the PRD.",
        "details": "1. Initialize a new Node.js project with `npm init -y`\n2. Install TypeScript and tsup as dev dependencies: `npm i -D typescript tsup @types/node`\n3. Configure tsconfig.json for strict mode and ESM with CJS compatibility:\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"declaration\": true,\n    \"outDir\": \"./dist\"\n  },\n  \"include\": [\"src/**/*\"]\n}\n```\n4. Set up the directory structure as specified in the PRD\n5. Configure package.json with appropriate scripts:\n```json\n{\n  \"scripts\": {\n    \"build\": \"tsup src/index.ts --format cjs,esm --dts\",\n    \"test\": \"vitest run\",\n    \"test:watch\": \"vitest\",\n    \"test:coverage\": \"vitest run --coverage\"\n  }\n}\n```\n6. Create initial README.md with project description\n7. Set up .gitignore for node_modules, dist, coverage, etc.",
        "testStrategy": "Verify project structure matches PRD specifications. Ensure TypeScript compiles without errors. Confirm build process generates both ESM and CJS outputs with type definitions.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement OAuth 2.0 Client Credentials authentication",
        "description": "Create the authentication module that handles OAuth 2.0 Client Credentials flow, including token acquisition, caching, and automatic refresh.",
        "details": "1. Create `src/auth.ts` module\n2. Implement TokenInfo interface:\n```typescript\ninterface TokenInfo {\n  accessToken: string;\n  tokenType: string;       // 'Bearer'\n  expiresAt: number;       // Unix timestamp (seconds)\n  expiresIn: number;       // Seconds until expiry\n  scope: string;\n}\n```\n3. Implement AuthManager class with methods:\n   - constructor(config): Initialize with client credentials\n   - getToken(): Get current token or acquire new one\n   - refreshToken(): Force token refresh\n   - isTokenExpired(): Check if token is expired or near expiry (within 2 minutes)\n4. Implement token caching in memory\n5. Add thread safety to prevent concurrent token refresh requests\n6. Handle token response parsing and error handling\n7. Implement token expiry tracking with automatic refresh\n8. Add proper error handling for authentication failures",
        "testStrategy": "Unit test token acquisition, caching, and refresh flows. Test error handling for invalid credentials. Mock HTTP responses for token endpoint. Verify token expiry detection and automatic refresh logic.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement HTTP client with rate limiting",
        "description": "Create the HTTP client layer that handles requests to the HaloPSA API, including authentication header injection, rate limiting, and error handling.",
        "details": "1. Create `src/http.ts` module\n2. Implement HttpClient class using Node.js built-in fetch (undici)\n3. Integrate with AuthManager for token injection\n4. Create `src/rate-limiter.ts` with RateLimiter class:\n```typescript\ninterface RateLimitConfig {\n  enabled: boolean;              // default: true\n  maxRequests: number;           // default: 500\n  windowMs: number;              // default: 180000 (3 minutes)\n  throttleThreshold: number;     // default: 0.8 (80% = 400 requests)\n  retryAfterMs: number;          // default: 5000\n  maxRetries: number;            // default: 3\n}\n```\n5. Implement sliding window algorithm for tracking requests in the 3-minute window\n6. Add throttling logic that activates at 80% capacity (400 requests)\n7. Implement exponential backoff for HTTP 429 responses\n8. Parse and respect Retry-After header when present\n9. Add request tracking and monitoring capabilities\n10. Integrate rate limiter with HTTP client",
        "testStrategy": "Unit test rate limiter with simulated request patterns. Test throttling behavior at threshold. Test HTTP 429 handling with retry logic. Verify Retry-After header parsing. Test request tracking accuracy over time windows.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement error handling system",
        "description": "Create custom error classes for different API error scenarios and implement consistent error handling throughout the library.",
        "details": "1. Create `src/errors.ts` module\n2. Implement error class hierarchy:\n```typescript\nclass HaloPsaError extends Error {\n  statusCode: number;\n  response: any;\n}\n\nclass HaloPsaAuthenticationError extends HaloPsaError {}   // 400, 401\nclass HaloPsaForbiddenError extends HaloPsaError {}         // 403\nclass HaloPsaNotFoundError extends HaloPsaError {}          // 404\nclass HaloPsaValidationError extends HaloPsaError {         // 400 (validation)\n  errors: Array<{ field: string; message: string }>;\n}\nclass HaloPsaRateLimitError extends HaloPsaError {}         // 429\nclass HaloPsaServerError extends HaloPsaError {}            // 500+\n```\n3. Implement error factory function to create appropriate error instances based on API responses\n4. Add error parsing logic for validation errors (field/message extraction)\n5. Integrate error handling with HTTP client\n6. Implement retry logic for specific error types (e.g., retry once for 500+ errors)\n7. Add clear error messages with context information",
        "testStrategy": "Unit test error class instantiation and properties. Test error factory with various API response scenarios. Verify correct error type is thrown for each status code. Test validation error parsing. Verify retry behavior for server errors.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement pagination utilities",
        "description": "Create pagination utilities that handle automatic pagination for list endpoints, including record count tracking and page calculation.",
        "details": "1. Create `src/pagination.ts` module\n2. Implement PaginatedResponse interface:\n```typescript\ninterface PaginatedResponse<T> {\n  record_count: number;\n  [key: string]: T[] | number; // Dynamic property for the actual data array\n}\n```\n3. Create PaginationOptions interface for query parameters\n4. Implement PaginatedIterator class with AsyncIterator interface\n5. Add methods for automatic pagination:\n   - listAll(): Returns an async iterator for all pages\n   - toArray(): Collects all pages into a single array\n6. Implement page calculation logic based on record_count and page_size\n7. Handle empty results and single page scenarios\n8. Respect rate limits between page fetches\n9. Add proper error handling for pagination failures",
        "testStrategy": "Unit test pagination with mock responses containing record_count. Test iterator behavior with single and multiple pages. Test empty results handling. Verify page calculation logic. Test toArray() collection method.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement core client and configuration",
        "description": "Create the main HaloPsaClient class with configuration handling, tenant URL construction, and resource initialization.",
        "details": "1. Create `src/config.ts` with configuration interfaces:\n```typescript\ninterface HaloPsaConfig {\n  clientId: string;\n  clientSecret: string;\n  tenant?: string;\n  baseUrl?: string;\n  tenantId?: string;\n  scope?: string;\n  rateLimitConfig?: RateLimitConfig;\n}\n```\n2. Create `src/client.ts` with HaloPsaClient class\n3. Implement constructor with config validation\n4. Add tenant URL construction logic (https://{tenant}.halopsa.com)\n5. Initialize AuthManager, HttpClient, and RateLimiter\n6. Create resource property getters for lazy initialization\n7. Implement resource registration system\n8. Add helper methods for common operations\n9. Implement proper error handling for configuration issues",
        "testStrategy": "Unit test client initialization with various config combinations. Test tenant URL construction. Test config validation. Verify resource initialization. Test error handling for invalid configurations.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement tickets resource (reference implementation)",
        "description": "Create the tickets resource module as a reference implementation for CRUD operations, including list, get, create, update, delete, and related operations.",
        "details": "1. Create `src/types/tickets.ts` with Ticket interface and related types\n2. Create `src/resources/tickets.ts` with TicketsResource class\n3. Implement CRUD methods:\n   - list(params?): Get paginated tickets\n   - get(id): Get a single ticket\n   - create(data): Create a new ticket\n   - update(id, data): Update an existing ticket\n   - delete(id): Delete a ticket\n4. Implement related methods:\n   - actions(id, params?): Get ticket actions\n   - addAction(id, data): Add an action to a ticket\n   - attachments(id): Get ticket attachments\n   - addAttachment(id, data): Add an attachment to a ticket\n5. Integrate with pagination utilities for list method\n6. Add proper error handling\n7. Implement filtering via query parameters",
        "testStrategy": "Integration test all CRUD operations with mock responses. Test pagination for list method. Test filtering with various parameters. Test related methods (actions, attachments). Verify error handling for various scenarios.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement client management resources",
        "description": "Create resource modules for client management, including clients, sites, and contacts with CRUD operations and related functionality.",
        "details": "1. Create type definitions in `src/types/` for:\n   - clients.ts: Client interface\n   - sites.ts: Site interface\n   - contacts.ts: Contact interface\n2. Create resource classes in `src/resources/` for:\n   - clients.ts: ClientsResource\n   - sites.ts: SitesResource\n   - contacts.ts: ContactsResource\n3. Implement CRUD methods for each resource\n4. Add filtering and pagination support\n5. Implement related methods (e.g., client.sites(), site.contacts())\n6. Add proper error handling\n7. Register resources with the main client",
        "testStrategy": "Integration test all CRUD operations for clients, sites, and contacts. Test filtering and pagination. Test related methods and relationships between entities. Verify error handling for various scenarios.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement asset management resources",
        "description": "Create resource modules for asset management, including assets, asset types, and software licenses with CRUD operations.",
        "details": "1. Create type definitions in `src/types/` for:\n   - assets.ts: Asset interface\n   - asset-types.ts: AssetType interface\n   - software-licences.ts: SoftwareLicence interface\n2. Create resource classes in `src/resources/` for:\n   - assets.ts: AssetsResource\n   - asset-types.ts: AssetTypesResource\n   - software-licences.ts: SoftwareLicencesResource\n3. Implement CRUD methods for each resource\n4. Add filtering and pagination support\n5. Implement related methods\n6. Add proper error handling\n7. Register resources with the main client",
        "testStrategy": "Integration test all CRUD operations for assets, asset types, and software licenses. Test filtering and pagination. Test relationships between assets and other entities. Verify error handling for various scenarios.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Set up test infrastructure with mocks",
        "description": "Create the test infrastructure using Vitest and MSW (or nock) for mocking HTTP responses, including fixtures for all API endpoints.",
        "details": "1. Install test dependencies: `npm i -D vitest msw c8`\n2. Create `vitest.config.ts` with appropriate configuration\n3. Set up `tests/setup.ts` for global test setup\n4. Create mock server in `tests/mocks/server.ts`\n5. Implement request handlers in `tests/mocks/handlers.ts`\n6. Create fixture directory structure as specified in the PRD\n7. Add JSON fixtures for authentication, tickets, clients, sites, etc.\n8. Implement helper functions for testing\n9. Create initial unit tests for core modules\n10. Set up GitHub Actions workflow for CI/CD",
        "testStrategy": "Verify mock server correctly intercepts HTTP requests. Test fixture loading. Ensure no real HTTP requests are made during tests. Verify test coverage reporting works correctly.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement service delivery resources",
        "description": "Create resource modules for service delivery, including actions, appointments, projects, tasks, and knowledge base articles.",
        "details": "1. Create type definitions in `src/types/` for:\n   - actions.ts: Action interface\n   - appointments.ts: Appointment interface\n   - projects.ts: Project and Task interfaces\n   - knowledge-base.ts: KBArticle interface\n2. Create resource classes in `src/resources/` for:\n   - actions.ts: ActionsResource\n   - appointments.ts: AppointmentsResource\n   - projects.ts: ProjectsResource\n   - knowledge-base.ts: KnowledgeBaseResource\n3. Implement CRUD methods for each resource\n4. Add filtering and pagination support\n5. Implement related methods (e.g., projects.tasks())\n6. Add proper error handling\n7. Register resources with the main client",
        "testStrategy": "Integration test all CRUD operations for actions, appointments, projects, and knowledge base articles. Test filtering and pagination. Test related methods and relationships. Verify error handling for various scenarios.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement financial resources",
        "description": "Create resource modules for financial entities, including items, contracts, invoices, quotes, and recurring invoices.",
        "details": "1. Create type definitions in `src/types/` for:\n   - items.ts: Item interface\n   - contracts.ts: Contract interface\n   - invoices.ts: Invoice interface\n   - quotes.ts: Quote interface\n   - recurring-invoices.ts: RecurringInvoice interface\n2. Create resource classes in `src/resources/` for:\n   - items.ts: ItemsResource\n   - contracts.ts: ContractsResource\n   - invoices.ts: InvoicesResource\n   - quotes.ts: QuotesResource\n   - recurring-invoices.ts: RecurringInvoicesResource\n3. Implement CRUD methods for each resource\n4. Add specialized methods (e.g., invoices.send(), quotes.convertToInvoice())\n5. Add filtering and pagination support\n6. Add proper error handling\n7. Register resources with the main client",
        "testStrategy": "Integration test all CRUD operations for items, contracts, invoices, quotes, and recurring invoices. Test specialized methods like send and convert. Test filtering and pagination. Verify error handling for various scenarios.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement reference data resources",
        "description": "Create resource modules for reference data, including ticket types, statuses, priorities, categories, SLAs, and other reference entities.",
        "details": "1. Create type definitions in `src/types/` for:\n   - ticket-types.ts: TicketType interface\n   - statuses.ts: Status interface\n   - priorities.ts: Priority interface\n   - categories.ts: Category interface\n   - slas.ts: SLA interface\n   - user-roles.ts: UserRole interface\n   - custom-fields.ts: CustomField interface\n2. Create resource classes in `src/resources/` for each type\n3. Implement list and get methods for each resource\n4. Add filtering support\n5. Add proper error handling\n6. Register resources with the main client",
        "testStrategy": "Integration test list and get operations for all reference data resources. Test filtering. Verify error handling for various scenarios.",
        "priority": "low",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement administrative resources",
        "description": "Create resource modules for administrative entities, including agents, teams, user roles, and reports.",
        "details": "1. Create type definitions in `src/types/` for:\n   - agents.ts: Agent interface\n   - teams.ts: Team interface\n   - reports.ts: Report interface\n2. Create resource classes in `src/resources/` for:\n   - agents.ts: AgentsResource with me() method\n   - teams.ts: TeamsResource\n   - reports.ts: ReportsResource with run() method\n3. Implement CRUD methods for each resource\n4. Add specialized methods (e.g., reports.run())\n5. Add filtering and pagination support\n6. Add proper error handling\n7. Register resources with the main client",
        "testStrategy": "Integration test all CRUD operations for agents, teams, and reports. Test specialized methods like me() and run(). Test filtering and pagination. Verify error handling for various scenarios.",
        "priority": "low",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Create comprehensive documentation and examples",
        "description": "Create comprehensive documentation in the README.md with installation instructions, configuration options, and usage examples for all resources.",
        "details": "1. Update README.md with:\n   - Installation instructions\n   - Basic configuration\n   - Authentication setup\n   - Rate limiting explanation\n   - Pagination usage\n   - Error handling guidance\n   - Examples for all major resources\n2. Add JSDoc comments to all public methods and interfaces\n3. Create CHANGELOG.md with initial version\n4. Add LICENSE file\n5. Create examples directory with sample code\n6. Document all configuration options\n7. Add troubleshooting section",
        "testStrategy": "Verify documentation accuracy by testing all examples. Ensure JSDoc comments generate correct type hints in IDEs. Check for completeness of resource documentation.",
        "priority": "medium",
        "dependencies": [
          7,
          8,
          9,
          11,
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-02-05T01:52:01.067Z",
      "updated": "2026-02-05T01:52:01.067Z",
      "description": "Tasks for node-halopsa context"
    }
  },
  "node-superops": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up project structure and dependencies",
        "description": "Initialize the project with the required directory structure and install all necessary dependencies.",
        "details": "1. Create the project directory structure as specified in the PRD\n2. Initialize npm project with `npm init -y`\n3. Install core dependencies:\n   - graphql-request\n   - graphql\n   - @graphql-codegen/cli and related plugins\n   - vitest\n   - msw with graphql handlers\n   - tsup\n4. Configure TypeScript with tsconfig.json for ESM with CJS compatibility\n5. Set up build configuration with tsup\n6. Initialize Git repository\n7. Create basic README.md with installation instructions\n\nExample package.json:\n```json\n{\n  \"name\": \"node-superops\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Node.js/TypeScript library for SuperOps.ai GraphQL API\",\n  \"type\": \"module\",\n  \"exports\": {\n    \"import\": \"./dist/index.js\",\n    \"require\": \"./dist/index.cjs\"\n  },\n  \"types\": \"./dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"test\": \"vitest run\",\n    \"codegen\": \"graphql-codegen --config codegen.yml\"\n  },\n  \"dependencies\": {\n    \"graphql\": \"^16.8.0\",\n    \"graphql-request\": \"^6.1.0\"\n  },\n  \"devDependencies\": {\n    \"@graphql-codegen/cli\": \"^5.0.0\",\n    \"@graphql-codegen/typescript\": \"^4.0.0\",\n    \"@graphql-codegen/typescript-graphql-request\": \"^5.0.0\",\n    \"@graphql-codegen/typescript-operations\": \"^4.0.0\",\n    \"msw\": \"^2.0.0\",\n    \"tsup\": \"^8.0.0\",\n    \"typescript\": \"^5.0.0\",\n    \"vitest\": \"^1.0.0\"\n  }\n}\n```",
        "testStrategy": "Verify that the project structure is created correctly by checking that all directories exist. Ensure all dependencies can be installed without errors. Validate tsconfig.json and build configuration by running a simple build test.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement client configuration and authentication",
        "description": "Create the SuperOpsClient class with configuration options and authentication handling.",
        "details": "1. Create `src/config.ts` with configuration types and defaults:\n```typescript\nexport interface SuperOpsConfig {\n  apiToken: string;\n  customerSubDomain: string;\n  region?: 'us' | 'eu';\n  vertical?: 'msp' | 'it';\n  endpoint?: string;\n  dates?: 'date' | 'string';\n}\n\nexport const DEFAULT_CONFIG = {\n  region: 'us',\n  vertical: 'msp',\n  dates: 'date'\n};\n```\n\n2. Create `src/client.ts` with the SuperOpsClient class:\n```typescript\nimport { SuperOpsConfig, DEFAULT_CONFIG } from './config';\nimport { createGraphQLClient } from './graphql-client';\n\nexport class SuperOpsClient {\n  private config: Required<SuperOpsConfig>;\n  private graphqlClient: any; // Will be typed later\n\n  constructor(config: SuperOpsConfig) {\n    if (!config.apiToken) {\n      throw new Error('apiToken is required');\n    }\n    if (!config.customerSubDomain) {\n      throw new Error('customerSubDomain is required');\n    }\n\n    this.config = { ...DEFAULT_CONFIG, ...config } as Required<SuperOpsConfig>;\n    \n    // Determine endpoint if not explicitly provided\n    if (!this.config.endpoint) {\n      const { region, vertical } = this.config;\n      this.config.endpoint = `https://${region === 'eu' ? 'eu' : ''}api.superops.ai/${vertical}`;\n    }\n\n    this.graphqlClient = createGraphQLClient(this.config);\n  }\n}\n```\n\n3. Create `src/graphql-client.ts` for GraphQL request setup:\n```typescript\nimport { GraphQLClient } from 'graphql-request';\nimport type { SuperOpsConfig } from './config';\n\nexport function createGraphQLClient(config: Required<SuperOpsConfig>) {\n  const client = new GraphQLClient(config.endpoint, {\n    headers: {\n      Authorization: `Bearer ${config.apiToken}`,\n      CustomerSubDomain: config.customerSubDomain,\n      'Content-Type': 'application/json'\n    }\n  });\n  \n  return client;\n}\n```\n\n4. Create `src/index.ts` to export the public API:\n```typescript\nexport { SuperOpsClient } from './client';\nexport type { SuperOpsConfig } from './config';\n```",
        "testStrategy": "Write unit tests to verify:\n1. Client initialization with valid configuration\n2. Error thrown when apiToken is missing\n3. Error thrown when customerSubDomain is missing\n4. Correct endpoint URL construction for all region/vertical combinations\n5. Headers are correctly set in the GraphQL client",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement custom error handling",
        "description": "Create custom error classes for handling GraphQL errors and other API-related errors.",
        "details": "1. Create `src/errors.ts` with custom error classes:\n```typescript\nexport class SuperOpsError extends Error {\n  code: string;\n  response: any;\n  graphqlErrors?: Array<any>;\n\n  constructor(message: string, code: string, response?: any, graphqlErrors?: Array<any>) {\n    super(message);\n    this.name = 'SuperOpsError';\n    this.code = code;\n    this.response = response;\n    this.graphqlErrors = graphqlErrors;\n  }\n}\n\nexport class SuperOpsAuthenticationError extends SuperOpsError {\n  constructor(message: string, response?: any, graphqlErrors?: Array<any>) {\n    super(message, 'AUTHENTICATION_ERROR', response, graphqlErrors);\n    this.name = 'SuperOpsAuthenticationError';\n  }\n}\n\nexport class SuperOpsNotFoundError extends SuperOpsError {\n  constructor(message: string, response?: any, graphqlErrors?: Array<any>) {\n    super(message, 'NOT_FOUND', response, graphqlErrors);\n    this.name = 'SuperOpsNotFoundError';\n  }\n}\n\nexport class SuperOpsValidationError extends SuperOpsError {\n  validationErrors: Array<{ field: string; message: string }>;\n\n  constructor(message: string, validationErrors: Array<{ field: string; message: string }>, response?: any, graphqlErrors?: Array<any>) {\n    super(message, 'VALIDATION_ERROR', response, graphqlErrors);\n    this.name = 'SuperOpsValidationError';\n    this.validationErrors = validationErrors;\n  }\n}\n\nexport class SuperOpsRateLimitError extends SuperOpsError {\n  constructor(message: string, response?: any, graphqlErrors?: Array<any>) {\n    super(message, 'RATE_LIMIT_ERROR', response, graphqlErrors);\n    this.name = 'SuperOpsRateLimitError';\n  }\n}\n\nexport class SuperOpsServerError extends SuperOpsError {\n  constructor(message: string, response?: any, graphqlErrors?: Array<any>) {\n    super(message, 'SERVER_ERROR', response, graphqlErrors);\n    this.name = 'SuperOpsServerError';\n  }\n}\n\nexport function parseGraphQLErrors(errors: any[]): SuperOpsError {\n  if (!errors || !errors.length) {\n    return new SuperOpsError('Unknown error', 'UNKNOWN_ERROR');\n  }\n\n  const error = errors[0];\n  const extensions = error.extensions || {};\n  const code = extensions.code || 'UNKNOWN_ERROR';\n  const message = error.message || 'An error occurred';\n\n  switch (code) {\n    case 'UNAUTHENTICATED':\n      return new SuperOpsAuthenticationError(message, null, errors);\n    case 'NOT_FOUND':\n      return new SuperOpsNotFoundError(message, null, errors);\n    case 'BAD_USER_INPUT':\n      // Extract validation errors if available\n      const validationErrors = extensions.validationErrors || [];\n      return new SuperOpsValidationError(message, validationErrors, null, errors);\n    case 'RATE_LIMITED':\n      return new SuperOpsRateLimitError(message, null, errors);\n    case 'INTERNAL_SERVER_ERROR':\n      return new SuperOpsServerError(message, null, errors);\n    default:\n      return new SuperOpsError(message, code, null, errors);\n  }\n}\n```\n\n2. Update `src/graphql-client.ts` to handle errors:\n```typescript\nimport { GraphQLClient } from 'graphql-request';\nimport type { SuperOpsConfig } from './config';\nimport { parseGraphQLErrors } from './errors';\n\nexport function createGraphQLClient(config: Required<SuperOpsConfig>) {\n  const client = new GraphQLClient(config.endpoint, {\n    headers: {\n      Authorization: `Bearer ${config.apiToken}`,\n      CustomerSubDomain: config.customerSubDomain,\n      'Content-Type': 'application/json'\n    }\n  });\n  \n  // Wrap the request method to handle errors\n  const originalRequest = client.request.bind(client);\n  client.request = async (...args: any[]) => {\n    try {\n      return await originalRequest(...args);\n    } catch (error: any) {\n      if (error.response?.errors) {\n        throw parseGraphQLErrors(error.response.errors);\n      }\n      throw error;\n    }\n  };\n  \n  return client;\n}\n```",
        "testStrategy": "Write unit tests for each error class:\n1. Test error instantiation with various parameters\n2. Test the parseGraphQLErrors function with different error types\n3. Test the wrapped GraphQL client with mocked error responses\n4. Verify that each error type is correctly identified and thrown",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement rate limiting functionality",
        "description": "Create a rate limiter to handle SuperOps.ai's 800 requests per minute limit with preemptive throttling and retry logic.",
        "details": "1. Create `src/rate-limiter.ts`:\n```typescript\nexport interface RateLimitConfig {\n  enabled: boolean;\n  maxRequests: number;\n  windowMs: number;\n  throttleThreshold: number;\n  retryAfterMs: number;\n  maxRetries: number;\n}\n\nexport const DEFAULT_RATE_LIMIT_CONFIG: RateLimitConfig = {\n  enabled: true,\n  maxRequests: 800,\n  windowMs: 60000, // 1 minute\n  throttleThreshold: 0.8, // 80%\n  retryAfterMs: 5000,\n  maxRetries: 3\n};\n\nexport class RateLimiter {\n  private config: RateLimitConfig;\n  private requestTimestamps: number[] = [];\n  \n  constructor(config: Partial<RateLimitConfig> = {}) {\n    this.config = { ...DEFAULT_RATE_LIMIT_CONFIG, ...config };\n  }\n\n  async throttle(): Promise<void> {\n    if (!this.config.enabled) return;\n\n    // Clean up old timestamps outside the window\n    const now = Date.now();\n    const windowStart = now - this.config.windowMs;\n    this.requestTimestamps = this.requestTimestamps.filter(ts => ts >= windowStart);\n\n    // Check if we're above the threshold\n    const currentCount = this.requestTimestamps.length;\n    const thresholdCount = this.config.maxRequests * this.config.throttleThreshold;\n    \n    if (currentCount >= thresholdCount) {\n      // Calculate delay based on how close we are to the limit\n      const ratio = currentCount / this.config.maxRequests;\n      const delay = Math.min(\n        this.config.retryAfterMs * ratio,\n        this.config.retryAfterMs\n      );\n      \n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    \n    // Record this request\n    this.requestTimestamps.push(Date.now());\n  }\n\n  async executeWithRetry<T>(fn: () => Promise<T>): Promise<T> {\n    let retries = 0;\n    \n    while (true) {\n      try {\n        await this.throttle();\n        return await fn();\n      } catch (error: any) {\n        // Check if it's a rate limit error\n        if (error.name === 'SuperOpsRateLimitError' && retries < this.config.maxRetries) {\n          retries++;\n          const delay = this.config.retryAfterMs * Math.pow(2, retries - 1); // Exponential backoff\n          await new Promise(resolve => setTimeout(resolve, delay));\n          continue;\n        }\n        throw error;\n      }\n    }\n  }\n\n  getRemainingRequests(): number {\n    const now = Date.now();\n    const windowStart = now - this.config.windowMs;\n    this.requestTimestamps = this.requestTimestamps.filter(ts => ts >= windowStart);\n    return this.config.maxRequests - this.requestTimestamps.length;\n  }\n}\n```\n\n2. Update `src/client.ts` to use the rate limiter:\n```typescript\nimport { SuperOpsConfig, DEFAULT_CONFIG } from './config';\nimport { createGraphQLClient } from './graphql-client';\nimport { RateLimiter, RateLimitConfig, DEFAULT_RATE_LIMIT_CONFIG } from './rate-limiter';\n\nexport interface SuperOpsClientOptions extends SuperOpsConfig {\n  rateLimit?: Partial<RateLimitConfig>;\n}\n\nexport class SuperOpsClient {\n  private config: Required<SuperOpsConfig>;\n  private graphqlClient: any;\n  private rateLimiter: RateLimiter;\n\n  constructor(options: SuperOpsClientOptions) {\n    if (!options.apiToken) {\n      throw new Error('apiToken is required');\n    }\n    if (!options.customerSubDomain) {\n      throw new Error('customerSubDomain is required');\n    }\n\n    this.config = { ...DEFAULT_CONFIG, ...options } as Required<SuperOpsConfig>;\n    \n    // Determine endpoint if not explicitly provided\n    if (!this.config.endpoint) {\n      const { region, vertical } = this.config;\n      this.config.endpoint = `https://${region === 'eu' ? 'eu' : ''}api.superops.ai/${vertical}`;\n    }\n\n    this.rateLimiter = new RateLimiter(options.rateLimit);\n    this.graphqlClient = createGraphQLClient(this.config);\n  }\n\n  async request<T>(query: string, variables?: any): Promise<T> {\n    return this.rateLimiter.executeWithRetry(() => \n      this.graphqlClient.request<T>(query, variables)\n    );\n  }\n}\n```\n\n3. Update `src/index.ts` to export the rate limiter types:\n```typescript\nexport { SuperOpsClient } from './client';\nexport type { SuperOpsConfig } from './config';\nexport type { RateLimitConfig } from './rate-limiter';\n```",
        "testStrategy": "Write unit tests to verify:\n1. Rate limiter correctly tracks requests within the time window\n2. Throttling occurs when approaching the limit\n3. Exponential backoff works for retries\n4. Rate limiter can be disabled via configuration\n5. Integration test with mocked 429 responses to verify retry behavior",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement pagination utilities",
        "description": "Create utilities to handle SuperOps.ai's cursor-based pagination with async iterators for automatic pagination.",
        "details": "1. Create `src/pagination.ts`:\n```typescript\nexport interface PageInfo {\n  hasNextPage: boolean;\n  endCursor?: string | null;\n}\n\nexport interface Edge<T> {\n  node: T;\n  cursor: string;\n}\n\nexport interface Connection<T> {\n  edges: Edge<T>[];\n  pageInfo: PageInfo;\n  totalCount?: number;\n}\n\nexport interface PaginationParams {\n  first?: number;\n  after?: string;\n}\n\nexport class PaginatedResult<T> implements AsyncIterable<T> {\n  private fetchPage: (params: PaginationParams) => Promise<Connection<T>>;\n  private params: PaginationParams;\n  \n  constructor(\n    fetchPage: (params: PaginationParams) => Promise<Connection<T>>,\n    params: PaginationParams = {}\n  ) {\n    this.fetchPage = fetchPage;\n    this.params = { first: 50, ...params };\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<T> {\n    let hasNextPage = true;\n    let after: string | undefined = this.params.after;\n    \n    while (hasNextPage) {\n      const connection = await this.fetchPage({\n        ...this.params,\n        after\n      });\n      \n      for (const edge of connection.edges) {\n        yield edge.node;\n      }\n      \n      hasNextPage = connection.pageInfo.hasNextPage;\n      after = connection.pageInfo.endCursor || undefined;\n      \n      // If no more pages or no items in this page, exit\n      if (!hasNextPage || connection.edges.length === 0) {\n        break;\n      }\n    }\n  }\n\n  async toArray(): Promise<T[]> {\n    const results: T[] = [];\n    for await (const item of this) {\n      results.push(item);\n    }\n    return results;\n  }\n}\n```\n\n2. Update `src/client.ts` to include a base method for paginated queries:\n```typescript\n// Add this method to the SuperOpsClient class\npaginate<T>(fetchFn: (params: PaginationParams) => Promise<Connection<T>>, params: PaginationParams = {}): PaginatedResult<T> {\n  return new PaginatedResult<T>(fetchFn, params);\n}\n```\n\n3. Update `src/index.ts` to export pagination types:\n```typescript\nexport { SuperOpsClient } from './client';\nexport type { SuperOpsConfig } from './config';\nexport type { RateLimitConfig } from './rate-limiter';\nexport type { PaginationParams, Connection, Edge, PageInfo } from './pagination';\n```",
        "testStrategy": "Write unit tests to verify:\n1. PaginatedResult correctly follows hasNextPage/endCursor\n2. Empty result sets are handled properly\n3. Single page results work correctly\n4. toArray() collects all items\n5. Integration test with mock multi-page responses",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Set up GraphQL schema and code generation",
        "description": "Configure GraphQL code generation to create TypeScript types from the SuperOps.ai GraphQL schema.",
        "details": "1. Create `schema.graphql` with the SuperOps.ai schema (this would be obtained from SuperOps.ai documentation or API introspection)\n\n2. Create `codegen.yml` configuration:\n```yaml\nschema: schema.graphql\ngenerates:\n  src/generated/graphql.ts:\n    plugins:\n      - typescript\n  src/generated/operations.ts:\n    plugins:\n      - typescript-operations\n    config:\n      avoidOptionals: true\n      skipTypename: true\n  src/generated/sdk.ts:\n    plugins:\n      - typescript-graphql-request\n    config:\n      documentMode: string\n```\n\n3. Create sample GraphQL operations in the operations directory:\n\nCreate `src/operations/assets.graphql`:\n```graphql\nquery GetAsset($id: ID!) {\n  getAsset(id: $id) {\n    id\n    name\n    type\n    status\n    client {\n      id\n      name\n    }\n  }\n}\n\nquery GetAssetList($first: Int, $after: String, $filter: AssetFilterInput, $orderBy: AssetOrderInput) {\n  getAssetList(first: $first, after: $after, filter: $filter, orderBy: $orderBy) {\n    edges {\n      node {\n        id\n        name\n        type\n        status\n        client {\n          id\n          name\n        }\n      }\n      cursor\n    }\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    totalCount\n  }\n}\n\nmutation CreateAsset($input: AssetInput!) {\n  createAsset(input: $input) {\n    id\n    name\n    type\n    status\n  }\n}\n\nmutation UpdateAsset($id: ID!, $input: AssetInput!) {\n  updateAsset(id: $id, input: $input) {\n    id\n    name\n    type\n    status\n  }\n}\n\nmutation DeleteAsset($id: ID!) {\n  deleteAsset(id: $id) {\n    success\n  }\n}\n```\n\n4. Add a script to package.json to run the code generation:\n```json\n\"scripts\": {\n  \"codegen\": \"graphql-codegen --config codegen.yml\"\n}\n```\n\n5. Create a script to run the code generation and generate the SDK:\n```typescript\n// scripts/generate-sdk.ts\nimport { execSync } from 'child_process';\nimport fs from 'fs';\nimport path from 'path';\n\n// Run the codegen\nconsole.log('Running GraphQL code generation...');\nexecSync('npm run codegen', { stdio: 'inherit' });\n\n// Collect all GraphQL operations\nconst operationsDir = path.join(__dirname, '../src/operations');\nconst files = fs.readdirSync(operationsDir);\n\n// Generate index file that imports all operations\nconst imports = files.map(file => {\n  const name = path.basename(file, '.graphql');\n  return `import './${name}.graphql';\n`;\n});\n\nfs.writeFileSync(\n  path.join(operationsDir, 'index.ts'),\n  imports.join('')\n);\n\nconsole.log('SDK generation complete!');\n```",
        "testStrategy": "Verify that:\n1. Code generation runs without errors\n2. Generated TypeScript types match the GraphQL schema\n3. Generated SDK methods can be imported and used\n4. Type checking works for the generated code",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Asset resource operations",
        "description": "Create the Asset resource class with CRUD operations and pagination support as a reference implementation.",
        "details": "1. Create `src/types/assets.ts` with asset-specific types:\n```typescript\nimport { PaginationParams } from '../pagination';\n\nexport interface AssetFilter {\n  status?: string[];\n  type?: string[];\n  clientId?: string;\n  siteId?: string;\n  createdAfter?: string | Date;\n  createdBefore?: string | Date;\n}\n\nexport interface AssetOrderBy {\n  field: 'NAME' | 'CREATED_AT' | 'UPDATED_AT' | 'TYPE' | 'STATUS';\n  direction: 'ASC' | 'DESC';\n}\n\nexport interface AssetListParams extends PaginationParams {\n  filter?: AssetFilter;\n  orderBy?: AssetOrderBy;\n}\n\nexport interface AssetInput {\n  name: string;\n  type: string;\n  status?: string;\n  clientId: string;\n  siteId?: string;\n  description?: string;\n  [key: string]: any; // For additional fields\n}\n```\n\n2. Create `src/resources/assets.ts` with the Asset resource class:\n```typescript\nimport { SuperOpsClient } from '../client';\nimport { Connection, PaginatedResult } from '../pagination';\nimport { AssetFilter, AssetInput, AssetListParams, AssetOrderBy } from '../types/assets';\nimport { formatDate } from '../utils/date';\n\n// Import generated types and operations\nimport { GetAssetQuery, GetAssetListQuery, CreateAssetMutation, UpdateAssetMutation, DeleteAssetMutation } from '../generated/operations';\nimport { getSdk } from '../generated/sdk';\n\nexport class AssetResource {\n  private client: SuperOpsClient;\n  private sdk: ReturnType<typeof getSdk>;\n\n  constructor(client: SuperOpsClient) {\n    this.client = client;\n    this.sdk = getSdk(client);\n  }\n\n  async get(id: string): Promise<GetAssetQuery['getAsset']> {\n    const { getAsset } = await this.sdk.GetAsset({ id });\n    return getAsset;\n  }\n\n  async list(params: AssetListParams = {}): Promise<Connection<GetAssetListQuery['getAssetList']['edges'][0]['node']>> {\n    // Format dates in filter if present\n    if (params.filter) {\n      const { createdAfter, createdBefore, ...rest } = params.filter;\n      params.filter = {\n        ...rest,\n        ...(createdAfter && { createdAfter: formatDate(createdAfter, this.client.config.dates) }),\n        ...(createdBefore && { createdBefore: formatDate(createdBefore, this.client.config.dates) })\n      };\n    }\n\n    const { getAssetList } = await this.sdk.GetAssetList({\n      first: params.first || 50,\n      after: params.after,\n      filter: params.filter,\n      orderBy: params.orderBy\n    });\n\n    return getAssetList;\n  }\n\n  listAll(params: Omit<AssetListParams, 'after'> = {}): PaginatedResult<GetAssetListQuery['getAssetList']['edges'][0]['node']> {\n    return this.client.paginate(\n      (paginationParams) => this.list({ ...params, ...paginationParams }),\n      { first: params.first }\n    );\n  }\n\n  async listByClient(clientId: string, params: Omit<AssetListParams, 'filter'> = {}): Promise<Connection<GetAssetListQuery['getAssetList']['edges'][0]['node']>> {\n    return this.list({\n      ...params,\n      filter: { ...params.filter, clientId }\n    });\n  }\n\n  listByClientAll(clientId: string, params: Omit<AssetListParams, 'filter' | 'after'> = {}): PaginatedResult<GetAssetListQuery['getAssetList']['edges'][0]['node']> {\n    return this.listAll({\n      ...params,\n      filter: { ...params.filter, clientId }\n    });\n  }\n\n  async listBySite(siteId: string, params: Omit<AssetListParams, 'filter'> = {}): Promise<Connection<GetAssetListQuery['getAssetList']['edges'][0]['node']>> {\n    return this.list({\n      ...params,\n      filter: { ...params.filter, siteId }\n    });\n  }\n\n  listBySiteAll(siteId: string, params: Omit<AssetListParams, 'filter' | 'after'> = {}): PaginatedResult<GetAssetListQuery['getAssetList']['edges'][0]['node']> {\n    return this.listAll({\n      ...params,\n      filter: { ...params.filter, siteId }\n    });\n  }\n\n  async create(data: AssetInput): Promise<CreateAssetMutation['createAsset']> {\n    const { createAsset } = await this.sdk.CreateAsset({ input: data });\n    return createAsset;\n  }\n\n  async update(id: string, data: Partial<AssetInput>): Promise<UpdateAssetMutation['updateAsset']> {\n    const { updateAsset } = await this.sdk.UpdateAsset({ id, input: data });\n    return updateAsset;\n  }\n\n  async delete(id: string): Promise<boolean> {\n    const { deleteAsset } = await this.sdk.DeleteAsset({ id });\n    return deleteAsset.success;\n  }\n}\n```\n\n3. Create `src/utils/date.ts` for date formatting:\n```typescript\nexport function formatDate(date: Date | string, format: 'date' | 'string' = 'date'): string {\n  if (typeof date === 'string') {\n    // If already a string, ensure it's ISO format\n    const dateObj = new Date(date);\n    return dateObj.toISOString();\n  }\n  \n  // If it's a Date object, convert to ISO string\n  return date.toISOString();\n}\n\nexport function parseDate(dateString: string, format: 'date' | 'string' = 'date'): Date | string {\n  if (format === 'date') {\n    return new Date(dateString);\n  }\n  return dateString;\n}\n```\n\n4. Update `src/client.ts` to include the Asset resource:\n```typescript\nimport { AssetResource } from './resources/assets';\n\nexport class SuperOpsClient {\n  // ... existing code\n  \n  // Resources\n  public assets: AssetResource;\n  \n  constructor(options: SuperOpsClientOptions) {\n    // ... existing initialization code\n    \n    // Initialize resources\n    this.assets = new AssetResource(this);\n  }\n}\n```",
        "testStrategy": "Write integration tests to verify:\n1. Asset CRUD operations work correctly with mocked responses\n2. Pagination works for asset listing\n3. Filtering and sorting options are correctly passed to the API\n4. Date formatting works correctly\n5. Error handling for asset operations",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Set up test infrastructure with MSW",
        "description": "Create a test infrastructure using Mock Service Worker (MSW) to mock GraphQL responses for testing.",
        "details": "1. Create `tests/setup.ts` for Vitest setup:\n```typescript\nimport { beforeAll, afterAll, afterEach, vi } from 'vitest';\nimport { server } from './mocks/server';\n\n// Establish API mocking before all tests\nbeforeAll(() => server.listen());\n\n// Reset any request handlers that we may add during the tests\nafterEach(() => server.resetHandlers());\n\n// Clean up after the tests are finished\nafterAll(() => server.close());\n```\n\n2. Create `tests/mocks/server.ts` to set up the MSW server:\n```typescript\nimport { setupServer } from 'msw/node';\nimport { handlers } from './handlers';\n\n// This configures a request mocking server with the given request handlers.\nexport const server = setupServer(...handlers);\n```\n\n3. Create `tests/mocks/handlers.ts` with GraphQL handlers:\n```typescript\nimport { graphql, HttpResponse } from 'msw';\nimport { fixtures } from '../fixtures';\n\nconst superopsApi = graphql.link('https://api.superops.ai/msp');\nconst euSuperopsApi = graphql.link('https://euapi.superops.ai/msp');\n\nexport const handlers = [\n  // Asset handlers\n  superopsApi.query('GetAsset', ({ variables }) => {\n    const { id } = variables;\n    if (id === 'not-found') {\n      return HttpResponse.json({\n        errors: [{ message: 'Asset not found', extensions: { code: 'NOT_FOUND' } }]\n      });\n    }\n    return HttpResponse.json({ data: { getAsset: fixtures.assets.single } });\n  }),\n\n  superopsApi.query('GetAssetList', ({ variables }) => {\n    const { after } = variables;\n    if (!after) {\n      return HttpResponse.json({ data: { getAssetList: fixtures.assets.listPage1 } });\n    }\n    return HttpResponse.json({ data: { getAssetList: fixtures.assets.listPage2 } });\n  }),\n\n  superopsApi.mutation('CreateAsset', ({ variables }) => {\n    return HttpResponse.json({ data: { createAsset: fixtures.assets.created } });\n  }),\n\n  superopsApi.mutation('UpdateAsset', ({ variables }) => {\n    return HttpResponse.json({ data: { updateAsset: fixtures.assets.updated } });\n  }),\n\n  superopsApi.mutation('DeleteAsset', ({ variables }) => {\n    return HttpResponse.json({ data: { deleteAsset: { success: true } } });\n  }),\n\n  // Rate limit simulation\n  superopsApi.query('RateLimited', () => {\n    return HttpResponse.json({\n      errors: [{\n        message: 'Rate limit exceeded',\n        extensions: { code: 'RATE_LIMITED' }\n      }]\n    });\n  }),\n\n  // EU region handlers (same patterns, different endpoint)\n  euSuperopsApi.query('GetAsset', ({ variables }) => {\n    return HttpResponse.json({ data: { getAsset: fixtures.assets.single } });\n  }),\n];\n```\n\n4. Create test fixtures in `tests/fixtures/index.ts`:\n```typescript\nexport const fixtures = {\n  assets: {\n    single: {\n      id: 'asset-123',\n      name: 'Test Server',\n      type: 'SERVER',\n      status: 'ACTIVE',\n      client: {\n        id: 'client-456',\n        name: 'Test Client'\n      }\n    },\n    listPage1: {\n      edges: [\n        {\n          node: {\n            id: 'asset-123',\n            name: 'Test Server 1',\n            type: 'SERVER',\n            status: 'ACTIVE',\n            client: {\n              id: 'client-456',\n              name: 'Test Client'\n            }\n          },\n          cursor: 'cursor1'\n        },\n        {\n          node: {\n            id: 'asset-124',\n            name: 'Test Server 2',\n            type: 'SERVER',\n            status: 'ACTIVE',\n            client: {\n              id: 'client-456',\n              name: 'Test Client'\n            }\n          },\n          cursor: 'cursor2'\n        }\n      ],\n      pageInfo: {\n        hasNextPage: true,\n        endCursor: 'cursor2'\n      },\n      totalCount: 4\n    },\n    listPage2: {\n      edges: [\n        {\n          node: {\n            id: 'asset-125',\n            name: 'Test Server 3',\n            type: 'SERVER',\n            status: 'ACTIVE',\n            client: {\n              id: 'client-456',\n              name: 'Test Client'\n            }\n          },\n          cursor: 'cursor3'\n        },\n        {\n          node: {\n            id: 'asset-126',\n            name: 'Test Server 4',\n            type: 'SERVER',\n            status: 'INACTIVE',\n            client: {\n              id: 'client-456',\n              name: 'Test Client'\n            }\n          },\n          cursor: 'cursor4'\n        }\n      ],\n      pageInfo: {\n        hasNextPage: false,\n        endCursor: 'cursor4'\n      },\n      totalCount: 4\n    },\n    created: {\n      id: 'asset-new',\n      name: 'New Asset',\n      type: 'WORKSTATION',\n      status: 'ACTIVE'\n    },\n    updated: {\n      id: 'asset-123',\n      name: 'Updated Asset',\n      type: 'SERVER',\n      status: 'ACTIVE'\n    }\n  }\n};\n```\n\n5. Create `vitest.config.ts`:\n```typescript\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    setupFiles: ['./tests/setup.ts'],\n    coverage: {\n      reporter: ['text', 'json', 'html'],\n      exclude: ['node_modules/', 'tests/'],\n    },\n  },\n});\n```\n\n6. Create a sample test in `tests/integration/assets.test.ts`:\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { SuperOpsClient } from '../../src';\nimport { fixtures } from '../fixtures';\n\ndescribe('Asset Resource', () => {\n  const client = new SuperOpsClient({\n    apiToken: 'test-token',\n    customerSubDomain: 'test-company',\n    region: 'us',\n    vertical: 'msp'\n  });\n\n  it('should get an asset by ID', async () => {\n    const asset = await client.assets.get('asset-123');\n    expect(asset).toEqual(fixtures.assets.single);\n  });\n\n  it('should throw NotFoundError for non-existent asset', async () => {\n    await expect(client.assets.get('not-found')).rejects.toThrow('Asset not found');\n  });\n\n  it('should list assets with pagination', async () => {\n    const result = await client.assets.list({ first: 2 });\n    expect(result.edges.length).toBe(2);\n    expect(result.pageInfo.hasNextPage).toBe(true);\n  });\n\n  it('should create an asset', async () => {\n    const newAsset = await client.assets.create({\n      name: 'New Asset',\n      type: 'WORKSTATION',\n      clientId: 'client-456'\n    });\n    expect(newAsset).toEqual(fixtures.assets.created);\n  });\n\n  it('should update an asset', async () => {\n    const updated = await client.assets.update('asset-123', {\n      name: 'Updated Asset'\n    });\n    expect(updated).toEqual(fixtures.assets.updated);\n  });\n\n  it('should delete an asset', async () => {\n    const result = await client.assets.delete('asset-123');\n    expect(result).toBe(true);\n  });\n\n  it('should paginate through all assets', async () => {\n    const allAssets = await client.assets.listAll().toArray();\n    expect(allAssets.length).toBe(4);\n    expect(allAssets[0].id).toBe('asset-123');\n    expect(allAssets[3].id).toBe('asset-126');\n  });\n});\n```",
        "testStrategy": "Verify that:\n1. MSW server starts and stops correctly\n2. GraphQL handlers correctly mock API responses\n3. Test fixtures are properly loaded\n4. Integration tests pass with mocked responses\n5. Error scenarios are correctly tested",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Ticket resource operations",
        "description": "Create the Ticket resource class with CRUD operations, status changes, notes, and time entries.",
        "details": "1. Create `src/types/tickets.ts` with ticket-specific types:\n```typescript\nimport { PaginationParams } from '../pagination';\n\nexport type TicketStatus = 'OPEN' | 'IN_PROGRESS' | 'WAITING' | 'RESOLVED' | 'CLOSED';\nexport type TicketPriority = 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n\nexport interface TicketFilter {\n  status?: TicketStatus[];\n  priority?: TicketPriority[];\n  clientId?: string;\n  technicianId?: string;\n  createdAfter?: string | Date;\n  createdBefore?: string | Date;\n  dueAfter?: string | Date;\n  dueBefore?: string | Date;\n}\n\nexport interface TicketOrderBy {\n  field: 'CREATED_AT' | 'UPDATED_AT' | 'DUE_DATE' | 'PRIORITY';\n  direction: 'ASC' | 'DESC';\n}\n\nexport interface TicketListParams extends PaginationParams {\n  filter?: TicketFilter;\n  orderBy?: TicketOrderBy;\n}\n\nexport interface TicketInput {\n  subject: string;\n  description: string;\n  clientId: string;\n  assetId?: string;\n  priority?: TicketPriority;\n  dueDate?: string | Date;\n  technicianId?: string;\n}\n\nexport interface TimeEntryInput {\n  description: string;\n  minutes: number;\n  billable: boolean;\n  date: string | Date;\n  technicianId?: string;\n}\n```\n\n2. Create `src/operations/tickets.graphql` with ticket operations:\n```graphql\nquery GetTicket($id: ID!) {\n  getTicket(id: $id) {\n    id\n    subject\n    description\n    status\n    priority\n    createdAt\n    updatedAt\n    dueDate\n    client {\n      id\n      name\n    }\n    asset {\n      id\n      name\n    }\n    technician {\n      id\n      name\n      email\n    }\n    notes {\n      id\n      content\n      createdAt\n      createdBy {\n        id\n        name\n      }\n    }\n    timeEntries {\n      id\n      description\n      minutes\n      billable\n      date\n      technician {\n        id\n        name\n      }\n    }\n  }\n}\n\nquery GetTicketList($first: Int, $after: String, $filter: TicketFilterInput, $orderBy: TicketOrderInput) {\n  getTicketList(first: $first, after: $after, filter: $filter, orderBy: $orderBy) {\n    edges {\n      node {\n        id\n        subject\n        status\n        priority\n        createdAt\n        dueDate\n        client {\n          id\n          name\n        }\n        technician {\n          id\n          name\n        }\n      }\n      cursor\n    }\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    totalCount\n  }\n}\n\nmutation CreateTicket($input: TicketInput!) {\n  createTicket(input: $input) {\n    id\n    subject\n    description\n    status\n    priority\n    createdAt\n    client {\n      id\n      name\n    }\n  }\n}\n\nmutation UpdateTicket($id: ID!, $input: TicketInput!) {\n  updateTicket(id: $id, input: $input) {\n    id\n    subject\n    description\n    status\n    priority\n    updatedAt\n  }\n}\n\nmutation AddTicketNote($ticketId: ID!, $note: String!) {\n  addTicketNote(ticketId: $ticketId, note: $note) {\n    id\n    content\n    createdAt\n    createdBy {\n      id\n      name\n    }\n  }\n}\n\nmutation AddTicketTimeEntry($ticketId: ID!, $input: TimeEntryInput!) {\n  addTicketTimeEntry(ticketId: $ticketId, input: $input) {\n    id\n    description\n    minutes\n    billable\n    date\n    technician {\n      id\n      name\n    }\n  }\n}\n\nmutation ChangeTicketStatus($id: ID!, $status: TicketStatus!) {\n  changeTicketStatus(id: $id, status: $status) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation AssignTicket($id: ID!, $technicianId: ID!) {\n  assignTicket(id: $id, technicianId: $technicianId) {\n    id\n    technician {\n      id\n      name\n    }\n    updatedAt\n  }\n}\n```\n\n3. Create `src/resources/tickets.ts` with the Ticket resource class:\n```typescript\nimport { SuperOpsClient } from '../client';\nimport { Connection, PaginatedResult } from '../pagination';\nimport { TicketFilter, TicketInput, TicketListParams, TicketOrderBy, TicketStatus, TimeEntryInput } from '../types/tickets';\nimport { formatDate } from '../utils/date';\n\n// Import generated types and operations\nimport { GetTicketQuery, GetTicketListQuery, CreateTicketMutation, UpdateTicketMutation, AddTicketNoteMutation, AddTicketTimeEntryMutation, ChangeTicketStatusMutation, AssignTicketMutation } from '../generated/operations';\nimport { getSdk } from '../generated/sdk';\n\nexport class TicketResource {\n  private client: SuperOpsClient;\n  private sdk: ReturnType<typeof getSdk>;\n\n  constructor(client: SuperOpsClient) {\n    this.client = client;\n    this.sdk = getSdk(client);\n  }\n\n  async get(id: string): Promise<GetTicketQuery['getTicket']> {\n    const { getTicket } = await this.sdk.GetTicket({ id });\n    return getTicket;\n  }\n\n  async list(params: TicketListParams = {}): Promise<Connection<GetTicketListQuery['getTicketList']['edges'][0]['node']>> {\n    // Format dates in filter if present\n    if (params.filter) {\n      const { createdAfter, createdBefore, dueAfter, dueBefore, ...rest } = params.filter;\n      params.filter = {\n        ...rest,\n        ...(createdAfter && { createdAfter: formatDate(createdAfter, this.client.config.dates) }),\n        ...(createdBefore && { createdBefore: formatDate(createdBefore, this.client.config.dates) }),\n        ...(dueAfter && { dueAfter: formatDate(dueAfter, this.client.config.dates) }),\n        ...(dueBefore && { dueBefore: formatDate(dueBefore, this.client.config.dates) })\n      };\n    }\n\n    const { getTicketList } = await this.sdk.GetTicketList({\n      first: params.first || 50,\n      after: params.after,\n      filter: params.filter,\n      orderBy: params.orderBy\n    });\n\n    return getTicketList;\n  }\n\n  listAll(params: Omit<TicketListParams, 'after'> = {}): PaginatedResult<GetTicketListQuery['getTicketList']['edges'][0]['node']> {\n    return this.client.paginate(\n      (paginationParams) => this.list({ ...params, ...paginationParams }),\n      { first: params.first }\n    );\n  }\n\n  async listByClient(clientId: string, params: Omit<TicketListParams, 'filter'> = {}): Promise<Connection<GetTicketListQuery['getTicketList']['edges'][0]['node']>> {\n    return this.list({\n      ...params,\n      filter: { ...params.filter, clientId }\n    });\n  }\n\n  listByClientAll(clientId: string, params: Omit<TicketListParams, 'filter' | 'after'> = {}): PaginatedResult<GetTicketListQuery['getTicketList']['edges'][0]['node']> {\n    return this.listAll({\n      ...params,\n      filter: { ...params.filter, clientId }\n    });\n  }\n\n  async listByStatus(status: TicketStatus | TicketStatus[], params: Omit<TicketListParams, 'filter'> = {}): Promise<Connection<GetTicketListQuery['getTicketList']['edges'][0]['node']>> {\n    const statusArray = Array.isArray(status) ? status : [status];\n    return this.list({\n      ...params,\n      filter: { ...params.filter, status: statusArray }\n    });\n  }\n\n  listByStatusAll(status: TicketStatus | TicketStatus[], params: Omit<TicketListParams, 'filter' | 'after'> = {}): PaginatedResult<GetTicketListQuery['getTicketList']['edges'][0]['node']> {\n    const statusArray = Array.isArray(status) ? status : [status];\n    return this.listAll({\n      ...params,\n      filter: { ...params.filter, status: statusArray }\n    });\n  }\n\n  async listByTechnician(technicianId: string, params: Omit<TicketListParams, 'filter'> = {}): Promise<Connection<GetTicketListQuery['getTicketList']['edges'][0]['node']>> {\n    return this.list({\n      ...params,\n      filter: { ...params.filter, technicianId }\n    });\n  }\n\n  listByTechnicianAll(technicianId: string, params: Omit<TicketListParams, 'filter' | 'after'> = {}): PaginatedResult<GetTicketListQuery['getTicketList']['edges'][0]['node']> {\n    return this.listAll({\n      ...params,\n      filter: { ...params.filter, technicianId }\n    });\n  }\n\n  async create(data: TicketInput): Promise<CreateTicketMutation['createTicket']> {\n    // Format date fields\n    if (data.dueDate) {\n      data = {\n        ...data,\n        dueDate: formatDate(data.dueDate, this.client.config.dates)\n      };\n    }\n\n    const { createTicket } = await this.sdk.CreateTicket({ input: data });\n    return createTicket;\n  }\n\n  async update(id: string, data: Partial<TicketInput>): Promise<UpdateTicketMutation['updateTicket']> {\n    // Format date fields\n    if (data.dueDate) {\n      data = {\n        ...data,\n        dueDate: formatDate(data.dueDate, this.client.config.dates)\n      };\n    }\n\n    const { updateTicket } = await this.sdk.UpdateTicket({ id, input: data as TicketInput });\n    return updateTicket;\n  }\n\n  async addNote(ticketId: string, note: string): Promise<AddTicketNoteMutation['addTicketNote']> {\n    const { addTicketNote } = await this.sdk.AddTicketNote({ ticketId, note });\n    return addTicketNote;\n  }\n\n  async addTimeEntry(ticketId: string, data: TimeEntryInput): Promise<AddTicketTimeEntryMutation['addTicketTimeEntry']> {\n    // Format date field\n    data = {\n      ...data,\n      date: formatDate(data.date, this.client.config.dates)\n    };\n\n    const { addTicketTimeEntry } = await this.sdk.AddTicketTimeEntry({ ticketId, input: data });\n    return addTicketTimeEntry;\n  }\n\n  async changeStatus(id: string, status: TicketStatus): Promise<ChangeTicketStatusMutation['changeTicketStatus']> {\n    const { changeTicketStatus } = await this.sdk.ChangeTicketStatus({ id, status });\n    return changeTicketStatus;\n  }\n\n  async assign(id: string, technicianId: string): Promise<AssignTicketMutation['assignTicket']> {\n    const { assignTicket } = await this.sdk.AssignTicket({ id, technicianId });\n    return assignTicket;\n  }\n}\n```\n\n4. Update `src/client.ts` to include the Ticket resource:\n```typescript\nimport { TicketResource } from './resources/tickets';\n\nexport class SuperOpsClient {\n  // ... existing code\n  \n  // Resources\n  public assets: AssetResource;\n  public tickets: TicketResource;\n  \n  constructor(options: SuperOpsClientOptions) {\n    // ... existing initialization code\n    \n    // Initialize resources\n    this.assets = new AssetResource(this);\n    this.tickets = new TicketResource(this);\n  }\n}\n```\n\n5. Create test fixtures for tickets in `tests/fixtures/index.ts`:\n```typescript\n// Add to existing fixtures object\ntickets: {\n  single: {\n    id: 'ticket-123',\n    subject: 'Server Down',\n    description: 'Production server is unresponsive',\n    status: 'OPEN',\n    priority: 'HIGH',\n    createdAt: '2026-01-01T00:00:00Z',\n    updatedAt: '2026-01-01T00:00:00Z',\n    dueDate: '2026-01-02T00:00:00Z',\n    client: {\n      id: 'client-456',\n      name: 'Test Client'\n    },\n    asset: {\n      id: 'asset-789',\n      name: 'Production Server'\n    },\n    technician: null,\n    notes: [],\n    timeEntries: []\n  },\n  listPage1: {\n    edges: [\n      {\n        node: {\n          id: 'ticket-123',\n          subject: 'Server Down',\n          status: 'OPEN',\n          priority: 'HIGH',\n          createdAt: '2026-01-01T00:00:00Z',\n          dueDate: '2026-01-02T00:00:00Z',\n          client: {\n            id: 'client-456',\n            name: 'Test Client'\n          },\n          technician: null\n        },\n        cursor: 'cursor1'\n      }\n    ],\n    pageInfo: {\n      hasNextPage: false,\n      endCursor: 'cursor1'\n    },\n    totalCount: 1\n  },\n  created: {\n    id: 'ticket-new',\n    subject: 'New Ticket',\n    description: 'This is a new ticket',\n    status: 'OPEN',\n    priority: 'MEDIUM',\n    createdAt: '2026-01-01T00:00:00Z',\n    client: {\n      id: 'client-456',\n      name: 'Test Client'\n    }\n  },\n  updated: {\n    id: 'ticket-123',\n    subject: 'Updated Ticket',\n    description: 'Production server is unresponsive',\n    status: 'OPEN',\n    priority: 'HIGH',\n    updatedAt: '2026-01-01T01:00:00Z'\n  },\n  note: {\n    id: 'note-123',\n    content: 'This is a test note',\n    createdAt: '2026-01-01T01:00:00Z',\n    createdBy: {\n      id: 'tech-123',\n      name: 'Test Technician'\n    }\n  },\n  timeEntry: {\n    id: 'time-123',\n    description: 'Troubleshooting',\n    minutes: 30,\n    billable: true,\n    date: '2026-01-01T00:00:00Z',\n    technician: {\n      id: 'tech-123',\n      name: 'Test Technician'\n    }\n  },\n  statusChanged: {\n    id: 'ticket-123',\n    status: 'IN_PROGRESS',\n    updatedAt: '2026-01-01T01:00:00Z'\n  },\n  assigned: {\n    id: 'ticket-123',\n    technician: {\n      id: 'tech-123',\n      name: 'Test Technician'\n    },\n    updatedAt: '2026-01-01T01:00:00Z'\n  }\n}\n```\n\n6. Add ticket handlers to `tests/mocks/handlers.ts`:\n```typescript\n// Add to existing handlers array\nsuperopsApi.query('GetTicket', ({ variables }) => {\n  const { id } = variables;\n  if (id === 'not-found') {\n    return HttpResponse.json({\n      errors: [{ message: 'Ticket not found', extensions: { code: 'NOT_FOUND' } }]\n    });\n  }\n  return HttpResponse.json({ data: { getTicket: fixtures.tickets.single } });\n}),\n\nsuperopsApi.query('GetTicketList', ({ variables }) => {\n  return HttpResponse.json({ data: { getTicketList: fixtures.tickets.listPage1 } });\n}),\n\nsuperopsApi.mutation('CreateTicket', ({ variables }) => {\n  return HttpResponse.json({ data: { createTicket: fixtures.tickets.created } });\n}),\n\nsuperopsApi.mutation('UpdateTicket', ({ variables }) => {\n  return HttpResponse.json({ data: { updateTicket: fixtures.tickets.updated } });\n}),\n\nsuperopsApi.mutation('AddTicketNote', ({ variables }) => {\n  return HttpResponse.json({ data: { addTicketNote: fixtures.tickets.note } });\n}),\n\nsuperopsApi.mutation('AddTicketTimeEntry', ({ variables }) => {\n  return HttpResponse.json({ data: { addTicketTimeEntry: fixtures.tickets.timeEntry } });\n}),\n\nsuperopsApi.mutation('ChangeTicketStatus', ({ variables }) => {\n  return HttpResponse.json({ data: { changeTicketStatus: fixtures.tickets.statusChanged } });\n}),\n\nsuperopsApi.mutation('AssignTicket', ({ variables }) => {\n  return HttpResponse.json({ data: { assignTicket: fixtures.tickets.assigned } });\n}),\n```\n\n7. Create `tests/integration/tickets.test.ts` for ticket tests:\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { SuperOpsClient } from '../../src';\nimport { fixtures } from '../fixtures';\n\ndescribe('Ticket Resource', () => {\n  const client = new SuperOpsClient({\n    apiToken: 'test-token',\n    customerSubDomain: 'test-company',\n    region: 'us',\n    vertical: 'msp'\n  });\n\n  it('should get a ticket by ID', async () => {\n    const ticket = await client.tickets.get('ticket-123');\n    expect(ticket).toEqual(fixtures.tickets.single);\n  });\n\n  it('should list tickets', async () => {\n    const result = await client.tickets.list();\n    expect(result.edges.length).toBe(1);\n    expect(result.edges[0].node.id).toBe('ticket-123');\n  });\n\n  it('should create a ticket', async () => {\n    const newTicket = await client.tickets.create({\n      subject: 'New Ticket',\n      description: 'This is a new ticket',\n      clientId: 'client-456',\n      priority: 'MEDIUM'\n    });\n    expect(newTicket).toEqual(fixtures.tickets.created);\n  });\n\n  it('should update a ticket', async () => {\n    const updated = await client.tickets.update('ticket-123', {\n      subject: 'Updated Ticket'\n    });\n    expect(updated).toEqual(fixtures.tickets.updated);\n  });\n\n  it('should add a note to a ticket', async () => {\n    const note = await client.tickets.addNote('ticket-123', 'This is a test note');\n    expect(note).toEqual(fixtures.tickets.note);\n  });\n\n  it('should add a time entry to a ticket', async () => {\n    const timeEntry = await client.tickets.addTimeEntry('ticket-123', {\n      description: 'Troubleshooting',\n      minutes: 30,\n      billable: true,\n      date: new Date('2026-01-01T00:00:00Z')\n    });\n    expect(timeEntry).toEqual(fixtures.tickets.timeEntry);\n  });\n\n  it('should change ticket status', async () => {\n    const result = await client.tickets.changeStatus('ticket-123', 'IN_PROGRESS');\n    expect(result).toEqual(fixtures.tickets.statusChanged);\n  });\n\n  it('should assign a ticket to a technician', async () => {\n    const result = await client.tickets.assign('ticket-123', 'tech-123');\n    expect(result).toEqual(fixtures.tickets.assigned);\n  });\n});\n```",
        "testStrategy": "Write integration tests to verify:\n1. Ticket CRUD operations work correctly with mocked responses\n2. Adding notes and time entries works\n3. Status changes and assignment operations work\n4. Filtering by client, status, and technician works\n5. Date formatting for due dates and time entries works correctly",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Client and Site resources",
        "description": "Create the Client and Site resource classes with their respective operations.",
        "details": "1. Create `src/types/clients.ts` with client-specific types:\n```typescript\nimport { PaginationParams } from '../pagination';\n\nexport interface ClientFilter {\n  status?: 'ACTIVE' | 'ARCHIVED';\n  createdAfter?: string | Date;\n  createdBefore?: string | Date;\n}\n\nexport interface ClientOrderBy {\n  field: 'NAME' | 'CREATED_AT' | 'UPDATED_AT';\n  direction: 'ASC' | 'DESC';\n}\n\nexport interface ClientListParams extends PaginationParams {\n  filter?: ClientFilter;\n  orderBy?: ClientOrderBy;\n}\n\nexport interface ClientInput {\n  name: string;\n  email?: string;\n  phone?: string;\n  address?: {\n    street?: string;\n    city?: string;\n    state?: string;\n    postalCode?: string;\n    country?: string;\n  };\n  [key: string]: any; // For additional fields\n}\n\nexport interface ClientSearchParams extends PaginationParams {\n  query: string;\n}\n```\n\n2. Create `src/types/sites.ts` with site-specific types:\n```typescript\nimport { PaginationParams } from '../pagination';\n\nexport interface SiteFilter {\n  clientId?: string;\n}\n\nexport interface SiteOrderBy {\n  field: 'NAME' | 'CREATED_AT';\n  direction: 'ASC' | 'DESC';\n}\n\nexport interface SiteListParams extends PaginationParams {\n  filter?: SiteFilter;\n  orderBy?: SiteOrderBy;\n}\n\nexport interface SiteInput {\n  name: string;\n  address?: {\n    street?: string;\n    city?: string;\n    state?: string;\n    postalCode?: string;\n    country?: string;\n  };\n  primaryContact?: {\n    name?: string;\n    email?: string;\n    phone?: string;\n  };\n  [key: string]: any; // For additional fields\n}\n```\n\n3. Create `src/operations/clients.graphql` with client operations:\n```graphql\nquery GetClient($id: ID!) {\n  getClient(id: $id) {\n    id\n    name\n    email\n    phone\n    address {\n      street\n      city\n      state\n      postalCode\n      country\n    }\n    createdAt\n    updatedAt\n    status\n  }\n}\n\nquery GetClientList($first: Int, $after: String, $filter: ClientFilterInput, $orderBy: ClientOrderInput) {\n  getClientList(first: $first, after: $after, filter: $filter, orderBy: $orderBy) {\n    edges {\n      node {\n        id\n        name\n        email\n        phone\n        status\n        createdAt\n      }\n      cursor\n    }\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    totalCount\n  }\n}\n\nquery SearchClients($query: String!, $first: Int, $after: String) {\n  searchClients(query: $query, first: $first, after: $after) {\n    edges {\n      node {\n        id\n        name\n        email\n        phone\n        status\n      }\n      cursor\n    }\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    totalCount\n  }\n}\n\nmutation CreateClient($input: ClientInput!) {\n  createClient(input: $input) {\n    id\n    name\n    email\n    phone\n    address {\n      street\n      city\n      state\n      postalCode\n      country\n    }\n    createdAt\n    status\n  }\n}\n\nmutation UpdateClient($id: ID!, $input: ClientInput!) {\n  updateClient(id: $id, input: $input) {\n    id\n    name\n    email\n    phone\n    address {\n      street\n      city\n      state\n      postalCode\n      country\n    }\n    updatedAt\n  }\n}\n\nmutation ArchiveClient($id: ID!) {\n  archiveClient(id: $id) {\n    id\n    status\n    updatedAt\n  }\n}\n```\n\n4. Create `src/operations/sites.graphql` with site operations:\n```graphql\nquery GetSite($id: ID!) {\n  getSite(id: $id) {\n    id\n    name\n    address {\n      street\n      city\n      state\n      postalCode\n      country\n    }\n    primaryContact {\n      name\n      email\n      phone\n    }\n    client {\n      id\n      name\n    }\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetSitesByClient($clientId: ID!, $first: Int, $after: String, $orderBy: SiteOrderInput) {\n  getSitesByClient(clientId: $clientId, first: $first, after: $after, orderBy: $orderBy) {\n    edges {\n      node {\n        id\n        name\n        address {\n          city\n          state\n          country\n        }\n        createdAt\n      }\n      cursor\n    }\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n    totalCount\n  }\n}\n\nmutation CreateClientSite($clientId: ID!, $input: SiteInput!) {\n  createClientSite(clientId: $clientId, input: $input) {\n    id\n    name\n    address {\n      street\n      city\n      state\n      postalCode\n      country\n    }\n    primaryContact {\n      name\n      email\n      phone\n    }\n    client {\n      id\n      name\n    }\n    createdAt\n  }\n}\n\nmutation UpdateSite($id: ID!, $input: SiteInput!) {\n  updateSite(id: $id, input: $input) {\n    id\n    name\n    address {\n      street\n      city\n      state\n      postalCode\n      country\n    }\n    primaryContact {\n      name\n      email\n      phone\n    }\n    updatedAt\n  }\n}\n\nmutation DeleteSite($id: ID!) {\n  deleteSite(id: $id) {\n    success\n  }\n}\n```\n\n5. Create `src/resources/clients.ts` with the Client resource class:\n```typescript\nimport { SuperOpsClient } from '../client';\nimport { Connection, PaginatedResult } from '../pagination';\nimport { ClientFilter, ClientInput, ClientListParams, ClientOrderBy, ClientSearchParams } from '../types/clients';\nimport { formatDate } from '../utils/date';\n\n// Import generated types and operations\nimport { GetClientQuery, GetClientListQuery, SearchClientsQuery, CreateClientMutation, UpdateClientMutation, ArchiveClientMutation } from '../generated/operations';\nimport { getSdk } from '../generated/sdk';\n\nexport class ClientResource {\n  private client: SuperOpsClient;\n  private sdk: ReturnType<typeof getSdk>;\n\n  constructor(client: SuperOpsClient) {\n    this.client = client;\n    this.sdk = getSdk(client);\n  }\n\n  async get(id: string): Promise<GetClientQuery['getClient']> {\n    const { getClient } = await this.sdk.GetClient({ id });\n    return getClient;\n  }\n\n  async list(params: ClientListParams = {}): Promise<Connection<GetClientListQuery['getClientList']['edges'][0]['node']>> {\n    // Format dates in filter if present\n    if (params.filter) {\n      const { createdAfter, createdBefore, ...rest } = params.filter;\n      params.filter = {\n        ...rest,\n        ...(createdAfter && { createdAfter: formatDate(createdAfter, this.client.config.dates) }),\n        ...(createdBefore && { createdBefore: formatDate(createdBefore, this.client.config.dates) })\n      };\n    }\n\n    const { getClientList } = await this.sdk.GetClientList({\n      first: params.first || 50,\n      after: params.after,\n      filter: params.filter,\n      orderBy: params.orderBy\n    });\n\n    return getClientList;\n  }\n\n  listAll(params: Omit<ClientListParams, 'after'> = {}): PaginatedResult<GetClientListQuery['getClientList']['edges'][0]['node']> {\n    return this.client.paginate(\n      (paginationParams) => this.list({ ...params, ...paginationParams }),\n      { first: params.first }\n    );\n  }\n\n  async search(query: string, params: Omit<ClientSearchParams, 'query'> = {}): Promise<Connection<SearchClientsQuery['searchClients']['edges'][0]['node']>> {\n    const { searchClients } = await this.sdk.SearchClients({\n      query,\n      first: params.first || 50,\n      after: params.after\n    });\n\n    return searchClients;\n  }\n\n  searchAll(query: string, params: Omit<ClientSearchParams, 'query' | 'after'> = {}): PaginatedResult<SearchClientsQuery['searchClients']['edges'][0]['node']> {\n    return this.client.paginate(\n      (paginationParams) => this.search(query, { ...params, ...paginationParams }),\n      { first: params.first }\n    );\n  }\n\n  async create(data: ClientInput): Promise<CreateClientMutation['createClient']> {\n    const { createClient } = await this.sdk.CreateClient({ input: data });\n    return createClient;\n  }\n\n  async update(id: string, data: Partial<ClientInput>): Promise<UpdateClientMutation['updateClient']> {\n    const { updateClient } = await this.sdk.UpdateClient({ id, input: data as ClientInput });\n    return updateClient;\n  }\n\n  async archive(id: string): Promise<ArchiveClientMutation['archiveClient']> {\n    const { archiveClient } = await this.sdk.ArchiveClient({ id });\n    return archiveClient;\n  }\n}\n```\n\n6. Create `src/resources/sites.ts` with the Site resource class:\n```typescript\nimport { SuperOpsClient } from '../client';\nimport { Connection, PaginatedResult } from '../pagination';\nimport { SiteInput, SiteListParams, SiteOrderBy } from '../types/sites';\n\n// Import generated types and operations\nimport { GetSiteQuery, GetSitesByClientQuery, CreateClientSiteMutation, UpdateSiteMutation, DeleteSiteMutation } from '../generated/operations';\nimport { getSdk } from '../generated/sdk';\n\nexport class SiteResource {\n  private client: SuperOpsClient;\n  private sdk: ReturnType<typeof getSdk>;\n\n  constructor(client: SuperOpsClient) {\n    this.client = client;\n    this.sdk = getSdk(client);\n  }\n\n  async get(id: string): Promise<GetSiteQuery['getSite']> {\n    const { getSite } = await this.sdk.GetSite({ id });\n    return getSite;\n  }\n\n  async listByClient(clientId: string, params: Omit<SiteListParams, 'filter'> = {}): Promise<Connection<GetSitesByClientQuery['getSitesByClient']['edges'][0]['node']>> {\n    const { getSitesByClient } = await this.sdk.GetSitesByClient({\n      clientId,\n      first: params.first || 50,\n      after: params.after,\n      orderBy: params.orderBy\n    });\n\n    return getSitesByClient;\n  }\n\n  listByClientAll(clientId: string, params: Omit<SiteListParams, 'filter' | 'after'> = {}): PaginatedResult<GetSitesByClientQuery['getSitesByClient']['edges'][0]['node']> {\n    return this.client.paginate(\n      (paginationParams) => this.listByClient(clientId, { ...params, ...paginationParams }),\n      { first: params.first }\n    );\n  }\n\n  async create(clientId: string, data: SiteInput): Promise<CreateClientSiteMutation['createClientSite']> {\n    const { createClientSite } = await this.sdk.CreateClientSite({ clientId, input: data });\n    return createClientSite;\n  }\n\n  async update(id: string, data: Partial<SiteInput>): Promise<UpdateSiteMutation['updateSite']> {\n    const { updateSite } = await this.sdk.UpdateSite({ id, input: data as SiteInput });\n    return updateSite;\n  }\n\n  async delete(id: string): Promise<boolean> {\n    const { deleteSite } = await this.sdk.DeleteSite({ id });\n    return deleteSite.success;\n  }\n}\n```\n\n7. Update `src/client.ts` to include the Client and Site resources:\n```typescript\nimport { ClientResource } from './resources/clients';\nimport { SiteResource } from './resources/sites';\n\nexport class SuperOpsClient {\n  // ... existing code\n  \n  // Resources\n  public assets: AssetResource;\n  public tickets: TicketResource;\n  public clients: ClientResource;\n  public sites: SiteResource;\n  \n  constructor(options: SuperOpsClientOptions) {\n    // ... existing initialization code\n    \n    // Initialize resources\n    this.assets = new AssetResource(this);\n    this.tickets = new TicketResource(this);\n    this.clients = new ClientResource(this);\n    this.sites = new SiteResource(this);\n  }\n}\n```\n\n8. Add test fixtures and handlers for clients and sites, and create integration tests for these resources similar to the assets and tickets resources.",
        "testStrategy": "Write integration tests to verify:\n1. Client CRUD operations work correctly with mocked responses\n2. Client search functionality works\n3. Client archiving works\n4. Site operations (create, update, delete) work correctly\n5. Listing sites by client works with pagination",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-02-05T01:52:45.317Z",
      "updated": "2026-02-05T01:52:45.317Z",
      "description": "Tasks for node-superops context"
    }
  },
  "syncro-plugin": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Plugin Directory Structure",
        "description": "Set up the initial directory structure for the Syncro Claude Code Plugin according to the specified layout in the PRD.",
        "details": "Create the following directory structure:\n```\nsyncro/syncro/\n .claude-plugin/\n    plugin.json\n .mcp.json\n README.md\n skills/\n    ticketing/\n       SKILL.md\n    customers/\n       SKILL.md\n    assets/\n       SKILL.md\n    invoicing/\n       SKILL.md\n    rmm/\n       SKILL.md\n    api-patterns/\n        SKILL.md\n commands/\n     lookup-customer.md\n     create-ticket.md\n     search-assets.md\n     get-invoice.md\n```\nEnsure all directories and placeholder files are created with proper permissions. This forms the foundation for all subsequent tasks.",
        "testStrategy": "Verify the directory structure matches the PRD specification by running a recursive directory listing command and comparing the output with the expected structure. Check that all directories and files are created with appropriate permissions.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create Plugin Manifest (plugin.json)",
        "description": "Create the plugin.json manifest file that defines the plugin's metadata, skills, and commands.",
        "details": "Create the .claude-plugin/plugin.json file with the following content:\n```json\n{\n  \"name\": \"syncro\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Claude plugins for Syncro PSA/RMM - ticketing, customers, assets, invoicing, remote monitoring\",\n  \"author\": \"MSP Claude Plugins Community\",\n  \"vendor\": \"syncro\",\n  \"product\": \"syncro\",\n  \"api_version\": \"v1\",\n  \"requires_api_key\": true,\n  \"documentation_url\": \"https://api-docs.syncromsp.com/\",\n  \"skills\": [\n    \"ticketing\",\n    \"customers\",\n    \"assets\",\n    \"invoicing\",\n    \"rmm\",\n    \"api-patterns\"\n  ],\n  \"commands\": [\n    \"lookup-customer\",\n    \"create-ticket\",\n    \"search-assets\",\n    \"get-invoice\"\n  ]\n}\n```\nEnsure the JSON is valid and properly formatted. This file defines the plugin's identity and capabilities within the Claude ecosystem.",
        "testStrategy": "Validate the JSON syntax using a JSON linter. Verify that all required fields are present and correctly formatted. Check that the skills and commands arrays match the skills and commands directories created in Task 1.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create MCP Configuration (.mcp.json)",
        "description": "Create the .mcp.json configuration file that defines the MCP server settings for Syncro API integration.",
        "details": "Create the .mcp.json file in the root directory with the following content:\n```json\n{\n  \"mcpServers\": {\n    \"syncro\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"syncro-mcp\"],\n      \"env\": {\n        \"SYNCRO_API_KEY\": \"${SYNCRO_API_KEY}\",\n        \"SYNCRO_SUBDOMAIN\": \"${SYNCRO_SUBDOMAIN}\"\n      }\n    }\n  }\n}\n```\nThis configuration sets up the MCP server to use the syncro-mcp package via npx, passing the necessary environment variables for API authentication. The environment variables use the ${VAR} syntax to reference values that will be provided at runtime.",
        "testStrategy": "Validate the JSON syntax using a JSON linter. Verify that the configuration matches the requirements in the PRD. Test that environment variable placeholders are correctly formatted and that no hardcoded credentials are present.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement API Patterns Skill",
        "description": "Create the API Patterns skill that provides foundational knowledge about interacting with the Syncro API.",
        "details": "Create the skills/api-patterns/SKILL.md file with comprehensive documentation on Syncro API patterns including:\n\n1. **Frontmatter** with description and triggers (syncro api, syncro query, syncro authentication, api integration)\n2. **Overview** of the Syncro API architecture\n3. **Key Concepts** section covering authentication, base URL structure, and RESTful conventions\n4. **Field Reference** for common API response structures\n5. **API Patterns** section detailing pagination, filtering, sorting, and rate limiting\n6. **Workflows** for common API operations\n7. **Error Handling** for HTTP status codes (400, 401, 403, 404, 422)\n8. **Best Practices** for API usage\n9. **Related Skills** section linking to other Syncro skills\n\nInclude specific examples of API requests and responses based on the Syncro API documentation at api-docs.syncromsp.com. Ensure all examples use placeholder values for authentication and sensitive data.",
        "testStrategy": "Review the SKILL.md file to ensure it contains all required sections. Validate that API examples match the Syncro API documentation. Check for proper markdown formatting and that no hardcoded credentials are present. Verify that all specified triggers are included in the frontmatter.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Customers Skill",
        "description": "Create the Customers skill that provides knowledge about managing customers and contacts in Syncro.",
        "details": "Create the skills/customers/SKILL.md file with comprehensive documentation on Syncro customer management including:\n\n1. **Frontmatter** with description and triggers (syncro customer, syncro client, customer lookup, contact management, client search)\n2. **Overview** of customer management in Syncro\n3. **Key Concepts** covering customer structure, types, and classifications\n4. **Field Reference** for customer and contact fields\n5. **API Patterns** specific to customer operations\n6. **Workflows** for common customer management tasks\n7. **Error Handling** for customer-related operations\n8. **Best Practices** for customer data management\n9. **Related Skills** section linking to other Syncro skills\n\nInclude detailed information about customer structure (id, name, business_name, email), contact management, addresses, custom fields, notes, and associated assets and tickets. Provide examples of API calls for customer CRUD operations based on the Syncro API documentation.",
        "testStrategy": "Review the SKILL.md file to ensure it contains all required sections. Validate that customer field descriptions match the Syncro documentation. Check for proper markdown formatting and that examples are clear and accurate. Verify that all specified triggers are included in the frontmatter.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Ticketing Skill",
        "description": "Create the Ticketing skill that provides knowledge about managing support tickets in Syncro.",
        "details": "Create the skills/ticketing/SKILL.md file with comprehensive documentation on Syncro ticketing including:\n\n1. **Frontmatter** with description and triggers (syncro ticket, syncro support, create ticket, ticket status, ticket lookup)\n2. **Overview** of the ticketing system in Syncro\n3. **Key Concepts** covering ticket structure, statuses, priorities, and types\n4. **Field Reference** for ticket fields and properties\n5. **API Patterns** specific to ticket operations\n6. **Workflows** for common ticket management tasks\n7. **Error Handling** for ticket-related operations\n8. **Best Practices** for ticket management\n9. **Related Skills** section linking to other Syncro skills\n\nInclude detailed information about ticket structure (id, number, subject, status, priority), ticket statuses (New, In Progress, Waiting, Resolved, Closed), priorities (Low, Medium, High, Urgent), problem types, time entries, comments, assignments, related assets, SLA tracking, and automation rules. Provide examples of API calls for ticket CRUD operations based on the Syncro API documentation.",
        "testStrategy": "Review the SKILL.md file to ensure it contains all required sections. Validate that ticket field descriptions and statuses match the Syncro documentation. Check for proper markdown formatting and that examples are clear and accurate. Verify that all specified triggers are included in the frontmatter.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Assets Skill",
        "description": "Create the Assets skill that provides knowledge about managing assets and devices in Syncro.",
        "details": "Create the skills/assets/SKILL.md file with comprehensive documentation on Syncro asset management including:\n\n1. **Frontmatter** with description and triggers (syncro asset, syncro device, asset lookup, device search, inventory management)\n2. **Overview** of asset management in Syncro\n3. **Key Concepts** covering asset structure, types, and fields\n4. **Field Reference** for asset properties and attributes\n5. **API Patterns** specific to asset operations\n6. **Workflows** for common asset management tasks\n7. **Error Handling** for asset-related operations\n8. **Best Practices** for asset management\n9. **Related Skills** section linking to other Syncro skills\n\nInclude detailed information about asset structure (id, name, asset_type, serial), asset types (Computer, Mobile, Network, Printer, Other), fields (serial_number, model, manufacturer), RMM agent association, custom fields, warranty tracking, notes, customer assignment, software inventory, hardware specifications, and lifecycle management. Provide examples of API calls for asset CRUD operations based on the Syncro API documentation.",
        "testStrategy": "Review the SKILL.md file to ensure it contains all required sections. Validate that asset field descriptions and types match the Syncro documentation. Check for proper markdown formatting and that examples are clear and accurate. Verify that all specified triggers are included in the frontmatter.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Invoicing Skill",
        "description": "Create the Invoicing skill that provides knowledge about managing invoices and billing in Syncro.",
        "details": "Create the skills/invoicing/SKILL.md file with comprehensive documentation on Syncro invoicing including:\n\n1. **Frontmatter** with description and triggers (syncro invoice, syncro billing, create invoice, invoice status, payment tracking)\n2. **Overview** of invoicing in Syncro\n3. **Key Concepts** covering invoice structure, statuses, and line items\n4. **Field Reference** for invoice fields and properties\n5. **API Patterns** specific to invoice operations\n6. **Workflows** for common invoicing tasks\n7. **Error Handling** for invoice-related operations\n8. **Best Practices** for invoice management\n9. **Related Skills** section linking to other Syncro skills\n\nInclude detailed information about invoice structure (id, number, status, total), statuses (Draft, Sent, Viewed, Paid, Void), line items (products, services, time entries), products and pricing, recurring invoices, payment methods, tax settings, templates, reminders, reports, and payment processor integration. Provide examples of API calls for invoice CRUD operations based on the Syncro API documentation.",
        "testStrategy": "Review the SKILL.md file to ensure it contains all required sections. Validate that invoice field descriptions and statuses match the Syncro documentation. Check for proper markdown formatting and that examples are clear and accurate. Verify that all specified triggers are included in the frontmatter.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement RMM Skill",
        "description": "Create the RMM skill that provides knowledge about remote monitoring and management features in Syncro.",
        "details": "Create the skills/rmm/SKILL.md file with comprehensive documentation on Syncro RMM including:\n\n1. **Frontmatter** with description and triggers (syncro rmm, syncro agent, remote monitoring, script execution, rmm alerts)\n2. **Overview** of RMM capabilities in Syncro\n3. **Key Concepts** covering RMM agent structure, statuses, and deployment\n4. **Field Reference** for RMM-related fields and properties\n5. **API Patterns** specific to RMM operations\n6. **Workflows** for common RMM tasks\n7. **Error Handling** for RMM-related operations\n8. **Best Practices** for remote monitoring and management\n9. **Related Skills** section linking to other Syncro skills\n\nInclude detailed information about RMM agent structure and deployment, agent statuses (Online, Offline, Needs Attention), remote access integrations, script execution and management, policy management, patch management, monitoring and alerts, alert types and thresholds, background tools, command execution, and system information retrieval. Provide examples of API calls for RMM operations based on the Syncro API documentation.",
        "testStrategy": "Review the SKILL.md file to ensure it contains all required sections. Validate that RMM field descriptions and statuses match the Syncro documentation. Check for proper markdown formatting and that examples are clear and accurate. Verify that all specified triggers are included in the frontmatter.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Commands",
        "description": "Create the four command files for the Syncro plugin: lookup-customer, create-ticket, search-assets, and get-invoice.",
        "details": "Create the following command files in the commands directory:\n\n1. **lookup-customer.md**:\n   - Include frontmatter with name, description, and arguments (query, include-contacts)\n   - Document prerequisites, steps, parameters, examples, output, and error handling\n   - Provide example usage: `/lookup-customer \"Acme Corp\"` and `/lookup-customer \"john@acme.com\" --include-contacts`\n\n2. **create-ticket.md**:\n   - Include frontmatter with name, description, and arguments (subject, customer, description, priority, problem-type)\n   - Document prerequisites, steps, parameters, examples, output, and error handling\n   - Provide example usage: `/create-ticket \"Email not syncing\" --customer \"Acme Corp\" --priority high`\n\n3. **search-assets.md**:\n   - Include frontmatter with name, description, and arguments (query, customer, type, status)\n   - Document prerequisites, steps, parameters, examples, output, and error handling\n   - Provide example usage: `/search-assets \"ACME-WS01\"` and `/search-assets --customer \"Acme Corp\" --type computer --status online`\n\n4. **get-invoice.md**:\n   - Include frontmatter with name, description, and arguments (invoice, customer, status)\n   - Document prerequisites, steps, parameters, examples, output, and error handling\n   - Provide example usage: `/get-invoice \"INV-1234\"` and `/get-invoice --customer \"Acme Corp\" --status sent`\n\nEnsure each command file includes detailed information about how the command interacts with the Syncro API, what data is returned, and how to interpret the results.",
        "testStrategy": "Review each command file to ensure it contains all required sections. Validate that argument descriptions match the PRD specifications. Check for proper markdown formatting and that examples are clear and accurate. Verify that the commands align with the API patterns described in the skills.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Create README.md and Documentation",
        "description": "Create a comprehensive README.md file for the plugin with installation instructions, usage examples, and documentation links.",
        "details": "Create a README.md file in the root directory that includes:\n\n1. **Project Title and Description** - Brief overview of the Syncro Claude Code Plugin\n2. **Installation Instructions** - How to install and configure the plugin\n3. **Prerequisites** - Required API keys and permissions\n4. **Configuration** - How to set up the SYNCRO_API_KEY and SYNCRO_SUBDOMAIN environment variables\n5. **Skills Overview** - Brief description of each skill with links to detailed documentation\n6. **Commands Reference** - List of available commands with examples\n7. **Common Workflows** - Examples of how to use the plugin for common MSP tasks\n8. **Troubleshooting** - Common issues and solutions\n9. **Contributing** - Guidelines for contributing to the plugin\n10. **License** - License information\n\nEnsure the README is well-formatted with proper headings, code blocks, and examples. Include information about the unified nature of Syncro's PSA and RMM platform and how the plugin leverages this integration.",
        "testStrategy": "Review the README.md file to ensure it contains all required sections. Check for proper markdown formatting and that installation instructions are clear and accurate. Verify that the documentation aligns with the plugin structure and functionality described in the PRD.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Update Marketplace.json",
        "description": "Update the marketplace.json file to include the Syncro plugin in the MSP Claude Plugin Marketplace.",
        "details": "Update the marketplace.json file in the parent project directory to include an entry for the Syncro plugin:\n\n```json\n{\n  \"plugins\": [\n    // ... existing plugins ...\n    {\n      \"name\": \"syncro\",\n      \"displayName\": \"Syncro PSA/RMM\",\n      \"description\": \"Claude plugins for Syncro PSA/RMM - ticketing, customers, assets, invoicing, remote monitoring\",\n      \"vendor\": \"syncro\",\n      \"product\": \"syncro\",\n      \"version\": \"1.0.0\",\n      \"repository\": \"syncro/syncro\",\n      \"icon\": \"https://path-to-syncro-icon.png\",\n      \"tags\": [\"msp\", \"psa\", \"rmm\", \"ticketing\", \"invoicing\"],\n      \"requires_api_key\": true\n    }\n  ]\n}\n```\n\nEnsure the entry is properly formatted and includes all required fields. The icon URL should point to a valid Syncro logo image. The tags should accurately reflect the plugin's capabilities.",
        "testStrategy": "Validate the JSON syntax after updating the marketplace.json file. Verify that all required fields for the Syncro plugin entry are present and correctly formatted. Check that the repository path matches the actual repository location.",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3,
          11
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-02-05T02:04:40.544Z",
      "updated": "2026-02-05T02:04:40.544Z",
      "description": "Tasks for syncro-plugin context"
    }
  },
  "superops-plugin": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Plugin Directory Structure",
        "description": "Set up the initial directory structure for the SuperOps Claude Code Plugin according to the specifications in the PRD.",
        "details": "Create the following directory structure:\n```\nsuperops/superops/\n .claude-plugin/\n    plugin.json\n .mcp.json\n README.md\n skills/\n    assets/\n       SKILL.md\n    tickets/\n       SKILL.md\n    clients/\n       SKILL.md\n    alerts/\n       SKILL.md\n    knowledge-base/\n       SKILL.md\n    api-patterns/\n        SKILL.md\n commands/\n     lookup-asset.md\n     create-ticket.md\n     search-clients.md\n     run-runbook.md\n```\nEnsure all directories and placeholder files are created with proper permissions. This structure follows the standard Claude plugin architecture pattern.",
        "testStrategy": "Verify that all directories and files exist in the correct locations. Run a script to check the directory structure against the expected structure defined in the PRD.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create Plugin Manifest (plugin.json)",
        "description": "Create the plugin.json manifest file with all required configuration for the SuperOps Claude Code Plugin.",
        "details": "Create the plugin.json file in the .claude-plugin directory with the following content:\n```json\n{\n  \"name\": \"superops\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Claude plugins for SuperOps PSA-RMM - assets, tickets, clients, alerts, knowledge base, GraphQL API\",\n  \"author\": \"MSP Claude Plugins Community\",\n  \"vendor\": \"superops\",\n  \"product\": \"superops\",\n  \"api_version\": \"graphql\",\n  \"requires_api_key\": true,\n  \"documentation_url\": \"https://developer.superops.ai/\",\n  \"skills\": [\n    \"assets\",\n    \"tickets\",\n    \"clients\",\n    \"alerts\",\n    \"knowledge-base\",\n    \"api-patterns\"\n  ],\n  \"commands\": [\n    \"lookup-asset\",\n    \"create-ticket\",\n    \"search-clients\",\n    \"run-runbook\"\n  ]\n}\n```\nEnsure the JSON is valid and properly formatted. This manifest defines the plugin's metadata, required API configuration, and lists all skills and commands.",
        "testStrategy": "Validate the JSON structure using a JSON validator. Verify that all required fields are present and correctly formatted. Check that the skills and commands arrays match the expected content from the PRD.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create MCP Configuration (.mcp.json)",
        "description": "Create the .mcp.json configuration file for the SuperOps Claude Code Plugin with proper environment variable references.",
        "details": "Create the .mcp.json file in the root directory with the following content:\n```json\n{\n  \"mcpServers\": {\n    \"superops\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"superops-mcp\"],\n      \"env\": {\n        \"SUPEROPS_API_KEY\": \"${SUPEROPS_API_KEY}\",\n        \"SUPEROPS_TENANT_ID\": \"${SUPEROPS_TENANT_ID}\"\n      }\n    }\n  }\n}\n```\nThis configuration defines how the MCP (Model Control Protocol) server should be started for the SuperOps plugin. It specifies the command to run, arguments to pass, and environment variables needed for authentication. The environment variables are referenced using the ${VAR_NAME} syntax, which will be replaced with actual values at runtime.",
        "testStrategy": "Validate the JSON structure using a JSON validator. Verify that the environment variables are properly referenced using the ${VAR_NAME} syntax. Test the configuration by running the MCP server with mock environment variables.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement API Patterns Skill",
        "description": "Create the API Patterns skill documentation focusing on SuperOps GraphQL API patterns, authentication, and common operations.",
        "details": "Create the api-patterns/SKILL.md file with comprehensive documentation on SuperOps GraphQL API patterns. Include the following sections:\n\n1. **Overview**: Explain that SuperOps uses GraphQL API instead of REST\n2. **Key Concepts**: GraphQL queries, mutations, subscriptions\n3. **Authentication**: API key in Authorization header\n4. **GraphQL Endpoint**: https://api.superops.ai/graphql\n5. **Query Structure**: Include example queries like:\n```graphql\nquery GetAsset($id: ID!) {\n  asset(id: $id) {\n    id\n    name\n    type\n    status\n    client { id name }\n  }\n}\n```\n6. **Mutation Structure**: Include example mutations like:\n```graphql\nmutation CreateTicket($input: CreateTicketInput!) {\n  createTicket(input: $input) {\n    id\n    number\n    subject\n  }\n}\n```\n7. **Pagination**: Document cursor-based pagination (first, after, last, before)\n8. **Filtering**: GraphQL arguments and variables\n9. **Error Handling**: GraphQL error responses\n10. **Rate Limiting**: Query complexity limits\n11. **Introspection**: Schema discovery\n12. **Common Queries Reference**\n\nInclude proper frontmatter with description and triggers (superops api, superops graphql, superops query, graphql mutation).",
        "testStrategy": "Review the SKILL.md file to ensure all required sections are present. Validate the GraphQL queries and mutations against the SuperOps API documentation. Check that the frontmatter includes all required triggers.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Assets Skill",
        "description": "Create the Assets skill documentation covering asset structure, types, statuses, fields, and GraphQL operations for asset management in SuperOps.",
        "details": "Create the assets/SKILL.md file with comprehensive documentation on SuperOps asset management. Include the following sections:\n\n1. **Overview**: Purpose of asset management in SuperOps\n2. **Key Concepts**: Asset lifecycle, monitoring, inventory\n3. **Field Reference**:\n   - Asset structure (id, name, type, status)\n   - Asset types (Workstation, Server, Network Device, Mobile)\n   - Asset statuses (Active, Inactive, Maintenance)\n   - Asset fields (serialNumber, manufacturer, model, os)\n   - RMM agent integration\n   - Asset health scores and indicators\n   - Hardware inventory (CPU, RAM, storage)\n   - Software inventory\n   - Asset tags and grouping\n   - Client assignment\n   - Warranty tracking\n   - Custom fields\n4. **GraphQL Patterns**: Include queries and mutations for asset operations\n5. **Workflows**: Common asset management workflows\n6. **Error Handling**: Common issues and resolutions\n7. **Best Practices**: Recommendations for asset management\n8. **Related Skills**: Links to tickets, clients, alerts skills\n\nInclude proper frontmatter with description and triggers (superops asset, superops device, asset lookup, device search, asset inventory).",
        "testStrategy": "Review the SKILL.md file to ensure all required sections are present. Validate the GraphQL queries and mutations against the SuperOps API documentation. Check that the frontmatter includes all required triggers.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Tickets Skill",
        "description": "Create the Tickets skill documentation covering ticket structure, statuses, priorities, types, and GraphQL operations for ticket management in SuperOps.",
        "details": "Create the tickets/SKILL.md file with comprehensive documentation on SuperOps ticket management. Include the following sections:\n\n1. **Overview**: Purpose of ticket management in SuperOps\n2. **Key Concepts**: Ticket lifecycle, SLAs, time tracking\n3. **Field Reference**:\n   - Ticket structure (id, number, subject, status)\n   - Ticket statuses (New, Open, Pending, Resolved, Closed)\n   - Ticket priorities (Low, Medium, High, Critical)\n   - Ticket types and categories\n   - Smart ticket routing (AI-powered)\n   - Time tracking and billing\n   - Ticket comments and notes\n   - Technician assignments\n   - Related assets and clients\n   - SLA management\n   - Ticket automation workflows\n   - AI-suggested responses\n4. **GraphQL Patterns**: Include queries and mutations for ticket operations\n5. **Workflows**: Common ticket management workflows\n6. **Error Handling**: Common issues and resolutions\n7. **Best Practices**: Recommendations for ticket management\n8. **Related Skills**: Links to assets, clients, alerts skills\n\nInclude proper frontmatter with description and triggers (superops ticket, superops support, create ticket, ticket status, helpdesk ticket).",
        "testStrategy": "Review the SKILL.md file to ensure all required sections are present. Validate the GraphQL queries and mutations against the SuperOps API documentation. Check that the frontmatter includes all required triggers.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Clients Skill",
        "description": "Create the Clients skill documentation covering client structure, types, contact management, and GraphQL operations for client management in SuperOps.",
        "details": "Create the clients/SKILL.md file with comprehensive documentation on SuperOps client management. Include the following sections:\n\n1. **Overview**: Purpose of client management in SuperOps\n2. **Key Concepts**: Client lifecycle, contacts, contracts\n3. **Field Reference**:\n   - Client structure (id, name, type)\n   - Client types and tiers\n   - Contact management\n   - Contact fields (name, email, phone, role)\n   - Client addresses and locations\n   - Associated assets\n   - Associated tickets\n   - Client portal access\n   - Contract management\n   - Billing information\n   - Custom fields\n   - Client health scores\n4. **GraphQL Patterns**: Include queries and mutations for client operations\n5. **Workflows**: Common client management workflows\n6. **Error Handling**: Common issues and resolutions\n7. **Best Practices**: Recommendations for client management\n8. **Related Skills**: Links to assets, tickets, alerts skills\n\nInclude proper frontmatter with description and triggers (superops client, superops customer, client lookup, client search, contact management).",
        "testStrategy": "Review the SKILL.md file to ensure all required sections are present. Validate the GraphQL queries and mutations against the SuperOps API documentation. Check that the frontmatter includes all required triggers.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Alerts Skill",
        "description": "Create the Alerts skill documentation covering alert structure, severities, types, and GraphQL operations for alert management in SuperOps.",
        "details": "Create the alerts/SKILL.md file with comprehensive documentation on SuperOps alert management. Include the following sections:\n\n1. **Overview**: Purpose of alert management in SuperOps\n2. **Key Concepts**: Alert lifecycle, monitoring, escalation\n3. **Field Reference**:\n   - Alert structure (id, type, severity, message)\n   - Alert severities (Low, Medium, High, Critical)\n   - Alert types:\n     - Performance alerts (CPU, memory, disk)\n     - Availability alerts (offline, service down)\n     - Security alerts (threats, vulnerabilities)\n     - Patch alerts (missing updates)\n     - Hardware alerts (disk health, temperature)\n   - Alert thresholds and policies\n   - Alert acknowledgment\n   - Alert resolution\n   - Alert-to-ticket escalation\n   - Alert snoozing\n   - AI-powered alert correlation\n4. **GraphQL Patterns**: Include queries and mutations for alert operations\n5. **Workflows**: Common alert management workflows\n6. **Error Handling**: Common issues and resolutions\n7. **Best Practices**: Recommendations for alert management\n8. **Related Skills**: Links to assets, tickets, clients skills\n\nInclude proper frontmatter with description and triggers (superops alert, superops monitoring, alert status, resolve alert, monitoring alert).",
        "testStrategy": "Review the SKILL.md file to ensure all required sections are present. Validate the GraphQL queries and mutations against the SuperOps API documentation. Check that the frontmatter includes all required triggers.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Knowledge Base Skill",
        "description": "Create the Knowledge Base skill documentation covering article structure, categories, runbooks, and GraphQL operations for knowledge base management in SuperOps.",
        "details": "Create the knowledge-base/SKILL.md file with comprehensive documentation on SuperOps knowledge base management. Include the following sections:\n\n1. **Overview**: Purpose of knowledge base management in SuperOps\n2. **Key Concepts**: Articles, runbooks, automation\n3. **Field Reference**:\n   - Article structure (id, title, content, category)\n   - Article categories and organization\n   - Article search and discovery\n   - Article permissions and visibility\n   - Runbook structure and execution\n   - Runbook parameters and variables\n   - Runbook scheduling\n   - Runbook execution history\n   - AI-assisted article creation\n   - Article linking to tickets\n   - Templates and snippets\n4. **GraphQL Patterns**: Include queries and mutations for KB operations\n5. **Workflows**: Common knowledge base management workflows\n6. **Error Handling**: Common issues and resolutions\n7. **Best Practices**: Recommendations for knowledge base management\n8. **Related Skills**: Links to assets, tickets, clients skills\n\nInclude proper frontmatter with description and triggers (superops knowledge base, superops kb, superops runbook, documentation search, automation runbook).",
        "testStrategy": "Review the SKILL.md file to ensure all required sections are present. Validate the GraphQL queries and mutations against the SuperOps API documentation. Check that the frontmatter includes all required triggers.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Commands",
        "description": "Create the four command files (lookup-asset, create-ticket, search-clients, run-runbook) with proper documentation and argument specifications.",
        "details": "Create the following command files in the commands directory:\n\n1. **lookup-asset.md**:\n   - Purpose: Find an asset by name, serial number, or client\n   - Arguments:\n     - query (Required): Asset name, serial number, or hostname\n     - client (Optional): Filter by client name\n     - type (Optional): Filter by asset type\n   - Include sections: Prerequisites, Steps, Parameters, Examples, Output, Error Handling\n   - Example: `/lookup-asset \"ACME-DC01\"` or `/lookup-asset \"SN12345678\" --client \"Acme Corp\"`\n\n2. **create-ticket.md**:\n   - Purpose: Create a new support ticket\n   - Arguments:\n     - subject (Required): Ticket subject\n     - client (Required): Client name or ID\n     - description (Optional): Ticket description\n     - priority (Optional): Priority (low, medium, high, critical)\n     - asset (Optional): Related asset name or ID\n   - Include sections: Prerequisites, Steps, Parameters, Examples, Output, Error Handling\n   - Example: `/create-ticket \"Server not responding\" --client \"Acme Corp\" --priority critical`\n\n3. **search-clients.md**:\n   - Purpose: Search for clients by name or attributes\n   - Arguments:\n     - query (Required): Client name or partial match\n     - type (Optional): Filter by client type\n     - include-stats (Optional): Include asset and ticket counts\n   - Include sections: Prerequisites, Steps, Parameters, Examples, Output, Error Handling\n   - Example: `/search-clients \"Acme\"` or `/search-clients \"Corp\" --type enterprise --include-stats`\n\n4. **run-runbook.md**:\n   - Purpose: Execute an automation runbook\n   - Arguments:\n     - runbook (Required): Runbook name or ID\n     - target (Required): Target asset(s) or client\n     - parameters (Optional): Runbook parameters as key=value\n   - Include sections: Prerequisites, Steps, Parameters, Examples, Output, Error Handling\n   - Example: `/run-runbook \"Clear Temp Files\" --target \"ACME-WS01\"` or `/run-runbook \"Windows Update Check\" --target \"Acme Corp\" --parameters \"reboot=false\"`\n\nEnsure each command file includes proper frontmatter with name, description, and arguments.",
        "testStrategy": "Review each command file to ensure all required sections are present. Validate the argument specifications against the PRD requirements. Check that the examples match the expected format.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Create README.md and Update Marketplace.json",
        "description": "Create a comprehensive README.md file for the plugin and update the marketplace.json file to include the SuperOps plugin.",
        "details": "1. Create a README.md file in the root directory with the following sections:\n   - Project Overview\n   - Installation\n   - Configuration\n   - Available Skills\n   - Available Commands\n   - GraphQL API Integration\n   - SuperOps-Specific Considerations\n   - Troubleshooting\n   - Contributing\n   - License\n\n2. Update the marketplace.json file to include the SuperOps plugin entry with:\n   - name: \"superops\"\n   - displayName: \"SuperOps\"\n   - description: \"Claude plugins for SuperOps PSA-RMM - assets, tickets, clients, alerts, knowledge base, GraphQL API\"\n   - version: \"1.0.0\"\n   - author: \"MSP Claude Plugins Community\"\n   - repository: \"superops/superops\"\n   - tags: [\"msp\", \"psa\", \"rmm\", \"superops\", \"graphql\"]\n\nEnsure the README.md provides clear instructions for installation, configuration, and usage of the plugin. Include examples of common workflows and use cases.",
        "testStrategy": "Review the README.md file to ensure all required sections are present and the content is comprehensive. Validate the marketplace.json entry against the required format.",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Test and Validate Plugin",
        "description": "Test the SuperOps Claude Code Plugin against the acceptance criteria defined in the PRD.",
        "details": "Perform the following validation steps:\n\n1. Verify all 6 skills exist with proper frontmatter (description, triggers)\n2. Verify all 4 commands exist with proper frontmatter (name, description, arguments)\n3. Check each skill contains: Overview, Key Concepts, Field Reference, GraphQL Patterns, Workflows, Error Handling, Best Practices, Related Skills\n4. Check each command contains: Prerequisites, Steps, Parameters, Examples, Output, Error Handling\n5. Validate API patterns skill thoroughly documents GraphQL query/mutation patterns\n6. Verify plugin.json correctly references all skills and commands\n7. Verify .mcp.json is configured for superops-mcp server with tenant support\n8. Check for no hardcoded credentials in any file\n9. Validate GraphQL examples against SuperOps documentation\n10. Verify marketplace.json is updated with superops plugin entry\n\nDocument any issues found and create tasks to address them.",
        "testStrategy": "Create a checklist based on the acceptance criteria and mark each item as passed or failed. Document any failures with specific details on what needs to be fixed.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-02-05T02:04:46.618Z",
      "updated": "2026-02-05T02:04:46.618Z",
      "description": "Tasks for superops-plugin context"
    }
  },
  "atera-plugin": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Plugin Directory Structure",
        "description": "Set up the initial directory structure for the Atera Claude Code Plugin according to the specifications in the PRD.",
        "details": "Create the following directory structure:\n```\natera/atera/\n .claude-plugin/\n    plugin.json\n .mcp.json\n README.md\n skills/\n    agents/\n       SKILL.md\n    tickets/\n       SKILL.md\n    devices/\n       SKILL.md\n    customers/\n       SKILL.md\n    alerts/\n       SKILL.md\n    api-patterns/\n        SKILL.md\n commands/\n     lookup-agent.md\n     create-ticket.md\n     search-devices.md\n     resolve-alert.md\n```\nEnsure all directories and placeholder files are created with the correct naming conventions. This structure follows the established plugin architecture pattern from the Autotask plugin.",
        "testStrategy": "Verify that all directories and files exist in the correct locations. Check that the structure matches the PRD specification exactly. Use a directory listing tool to validate the complete structure.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create Plugin Manifest (plugin.json)",
        "description": "Create the plugin.json manifest file with all required configuration for the Atera Claude Code Plugin.",
        "details": "Create the plugin.json file in the .claude-plugin directory with the following content:\n```json\n{\n  \"name\": \"atera\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Claude plugins for Atera RMM/PSA - agents, tickets, devices, customers, alerts\",\n  \"author\": \"MSP Claude Plugins Community\",\n  \"vendor\": \"atera\",\n  \"product\": \"atera\",\n  \"api_version\": \"v3\",\n  \"requires_api_key\": true,\n  \"documentation_url\": \"https://app.atera.com/apidocs\",\n  \"skills\": [\n    \"agents\",\n    \"tickets\",\n    \"devices\",\n    \"customers\",\n    \"alerts\",\n    \"api-patterns\"\n  ],\n  \"commands\": [\n    \"lookup-agent\",\n    \"create-ticket\",\n    \"search-devices\",\n    \"resolve-alert\"\n  ]\n}\n```\nEnsure the manifest includes all required fields: name, version, description, author, vendor, product, api_version, requires_api_key, documentation_url, skills, and commands. The skills and commands arrays should match the directory structure created in Task 1.",
        "testStrategy": "Validate the JSON syntax using a JSON validator. Verify that all required fields are present and correctly formatted. Check that the skills and commands arrays match the directory structure from Task 1. Ensure the api_version matches Atera's current API version (v3).",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create MCP Configuration (.mcp.json)",
        "description": "Create the .mcp.json configuration file for MCP server integration with Atera API.",
        "details": "Create the .mcp.json file in the root directory with the following content:\n```json\n{\n  \"mcpServers\": {\n    \"atera\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"atera-mcp\"],\n      \"env\": {\n        \"ATERA_API_KEY\": \"${ATERA_API_KEY}\"\n      }\n    }\n  }\n}\n```\nThis configuration sets up the MCP server to use the atera-mcp package via npx, passing the ATERA_API_KEY environment variable for authentication. The configuration follows the established pattern for MCP integration and ensures no hardcoded credentials are included.",
        "testStrategy": "Validate the JSON syntax using a JSON validator. Verify that the configuration uses environment variables for sensitive data (API key) rather than hardcoded values. Check that the command and args are correctly specified for the atera-mcp package.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement API Patterns Skill",
        "description": "Create the API Patterns skill documentation to provide foundation knowledge for Atera API interactions.",
        "details": "Create the SKILL.md file in the skills/api-patterns directory with comprehensive documentation on Atera API patterns. Include the following sections:\n\n1. **Overview**: Explain the purpose of the API Patterns skill as a foundation for all Atera API interactions.\n2. **Key Concepts**: Document authentication with X-API-KEY header, base URL (https://app.atera.com/api/v3), RESTful conventions.\n3. **Field Reference**: Document common fields and data structures returned by the API.\n4. **API Patterns**: Detail pagination (Page, ItemsInPage, nextLink), filtering with query parameters, OData-style filtering support, response structure (items, totalCount).\n5. **Workflows**: Common API interaction patterns and best practices.\n6. **Error Handling**: Document error codes (400, 401, 403, 404) and appropriate responses.\n7. **Best Practices**: Rate limiting considerations and efficient API usage.\n8. **Related Skills**: Link to other Atera skills that build on these patterns.\n\nInclude appropriate frontmatter with description and triggers as specified in the PRD (atera api, atera query, atera authentication, api integration).",
        "testStrategy": "Review the SKILL.md file to ensure all required sections are present. Verify that the content accurately reflects the Atera API documentation. Check that all triggers from the PRD are included in the frontmatter. Validate that the authentication method, base URL, and API patterns are correctly documented.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Agents Skill",
        "description": "Create the Agents skill documentation for managing Atera agents deployed on endpoints.",
        "details": "Create the SKILL.md file in the skills/agents directory with comprehensive documentation on Atera agents. Include the following sections:\n\n1. **Overview**: Explain the purpose of the Agents skill for managing Atera agents on endpoints.\n2. **Key Concepts**: Document agent structure (AgentID, MachineName, CustomerName), statuses (Online, Offline, Archived), and types (Windows, Mac, Linux).\n3. **Field Reference**: Document agent fields (OS, Version, LastSeen, IPAddress) and their meanings.\n4. **API Patterns**: Detail API endpoints for agent management, including listing, filtering, and agent-specific operations.\n5. **Workflows**: Document agent installation, deployment, grouping, organization, and commands (restart, reinstall).\n6. **Error Handling**: Common errors when working with agents and how to resolve them.\n7. **Best Practices**: Recommendations for agent management and monitoring.\n8. **Related Skills**: Link to other relevant Atera skills (devices, alerts).\n\nInclude information on Splashtop remote access integration, agent thresholds, and monitoring settings. Add appropriate frontmatter with description and triggers as specified in the PRD (atera agent, atera endpoint, agent status, agent lookup, managed agent).",
        "testStrategy": "Review the SKILL.md file to ensure all required sections are present. Verify that the content accurately reflects Atera agent functionality. Check that all triggers from the PRD are included in the frontmatter. Validate that agent structure, statuses, types, and fields are correctly documented.",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Customers Skill",
        "description": "Create the Customers skill documentation for managing customers and contacts in Atera.",
        "details": "Create the SKILL.md file in the skills/customers directory with comprehensive documentation on Atera customers. Include the following sections:\n\n1. **Overview**: Explain the purpose of the Customers skill for managing customer information in Atera.\n2. **Key Concepts**: Document customer structure (CustomerID, CustomerName) and contact management.\n3. **Field Reference**: Document customer fields (address, phone, website) and contact fields (Name, Email, Phone, JobTitle).\n4. **API Patterns**: Detail API endpoints for customer management, including listing, filtering, and customer-specific operations.\n5. **Workflows**: Document customer folders, organization, associated agents/devices/tickets, and customer portal access.\n6. **Error Handling**: Common errors when working with customers and how to resolve them.\n7. **Best Practices**: Recommendations for customer management and organization.\n8. **Related Skills**: Link to other relevant Atera skills (agents, devices, tickets).\n\nInclude information on billing and contract information, custom fields, and API patterns for customer management. Add appropriate frontmatter with description and triggers as specified in the PRD (atera customer, atera client, customer lookup, customer search, contact management).",
        "testStrategy": "Review the SKILL.md file to ensure all required sections are present. Verify that the content accurately reflects Atera customer functionality. Check that all triggers from the PRD are included in the frontmatter. Validate that customer structure, fields, and management workflows are correctly documented.",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Devices Skill",
        "description": "Create the Devices skill documentation for managing devices and hardware inventory in Atera.",
        "details": "Create the SKILL.md file in the skills/devices directory with comprehensive documentation on Atera devices. Include the following sections:\n\n1. **Overview**: Explain the purpose of the Devices skill for managing device information in Atera.\n2. **Key Concepts**: Document device information from agents, hardware specifications, and device types.\n3. **Field Reference**: Document device fields including hardware specifications (CPU, RAM, Storage), software inventory, and network information (IP, MAC, adapters).\n4. **API Patterns**: Detail API endpoints for device queries, including listing, filtering, and device-specific operations.\n5. **Workflows**: Document device management, including disk health monitoring, warranty information, and device notes/custom fields.\n6. **Error Handling**: Common errors when working with devices and how to resolve them.\n7. **Best Practices**: Recommendations for device management and inventory tracking.\n8. **Related Skills**: Link to other relevant Atera skills (agents, customers, alerts).\n\nInclude information on SNMP devices (network equipment), generic devices (non-agent), and device-customer relationships. Add appropriate frontmatter with description and triggers as specified in the PRD (atera device, atera hardware, device inventory, device search, hardware audit).",
        "testStrategy": "Review the SKILL.md file to ensure all required sections are present. Verify that the content accurately reflects Atera device functionality. Check that all triggers from the PRD are included in the frontmatter. Validate that device types, fields, and management workflows are correctly documented.",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Tickets Skill",
        "description": "Create the Tickets skill documentation for managing support tickets in Atera.",
        "details": "Create the SKILL.md file in the skills/tickets directory with comprehensive documentation on Atera tickets. Include the following sections:\n\n1. **Overview**: Explain the purpose of the Tickets skill for managing support tickets in Atera.\n2. **Key Concepts**: Document ticket structure (TicketID, TicketNumber, Title, Status), statuses (Open, Pending, Resolved, Closed), and priorities (Low, Medium, High, Critical).\n3. **Field Reference**: Document ticket fields, types, and categories.\n4. **API Patterns**: Detail API endpoints for ticket operations, including creation, updating, and filtering.\n5. **Workflows**: Document SLA management, ticket comments/notes, time entries/billing, and ticket assignments.\n6. **Error Handling**: Common errors when working with tickets and how to resolve them.\n7. **Best Practices**: Recommendations for ticket management and workflow optimization.\n8. **Related Skills**: Link to other relevant Atera skills (customers, devices, alerts).\n\nInclude information on related devices and contacts, ticket automation and rules, and customer portal tickets. Add appropriate frontmatter with description and triggers as specified in the PRD (atera ticket, atera support, create ticket, ticket status, helpdesk ticket).",
        "testStrategy": "Review the SKILL.md file to ensure all required sections are present. Verify that the content accurately reflects Atera ticket functionality. Check that all triggers from the PRD are included in the frontmatter. Validate that ticket structure, statuses, priorities, and management workflows are correctly documented.",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Alerts Skill",
        "description": "Create the Alerts skill documentation for managing and responding to Atera alerts.",
        "details": "Create the SKILL.md file in the skills/alerts directory with comprehensive documentation on Atera alerts. Include the following sections:\n\n1. **Overview**: Explain the purpose of the Alerts skill for managing alerts in Atera.\n2. **Key Concepts**: Document alert structure (AlertID, Title, Severity, Created) and severities (Information, Warning, Critical).\n3. **Field Reference**: Document alert fields and categories, including:\n   - Hardware alerts (disk, memory, CPU)\n   - Software alerts (services, processes)\n   - Availability alerts (offline, ping)\n   - Threshold alerts (performance counters)\n   - Security alerts (antivirus, firewall)\n   - Patch alerts (missing updates)\n4. **API Patterns**: Detail API endpoints for alert management, including listing, filtering, and alert-specific operations.\n5. **Workflows**: Document alert thresholds, configuration, alert-to-ticket automation, and alert resolution workflows.\n6. **Error Handling**: Common errors when working with alerts and how to resolve them.\n7. **Best Practices**: Recommendations for alert management, snoozing, dismissal, and analysis of history/trends.\n8. **Related Skills**: Link to other relevant Atera skills (agents, devices, tickets).\n\nAdd appropriate frontmatter with description and triggers as specified in the PRD (atera alert, atera monitoring, alert status, resolve alert, monitoring alert).",
        "testStrategy": "Review the SKILL.md file to ensure all required sections are present. Verify that the content accurately reflects Atera alert functionality. Check that all triggers from the PRD are included in the frontmatter. Validate that all alert categories and severities are correctly documented according to the PRD specifications.",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Commands",
        "description": "Create the four command files for the Atera Claude Code Plugin: lookup-agent, create-ticket, search-devices, and resolve-alert.",
        "details": "Create the following command files in the commands directory:\n\n1. **lookup-agent.md**:\n   - Purpose: Find an agent by hostname, IP, or customer\n   - Arguments: identifier (required), customer (optional), status (optional)\n   - Include sections: Prerequisites, Steps, Parameters, Examples, Output, Error Handling\n   - Examples should match PRD format: `/lookup-agent \"ACME-WS01\"`, etc.\n\n2. **create-ticket.md**:\n   - Purpose: Create a new support ticket\n   - Arguments: title (required), customer (required), description (optional), priority (optional), type (optional)\n   - Include sections: Prerequisites, Steps, Parameters, Examples, Output, Error Handling\n   - Examples should match PRD format: `/create-ticket \"Server offline\" --customer \"Acme Corp\" --priority critical`, etc.\n\n3. **search-devices.md**:\n   - Purpose: Search for devices across customers\n   - Arguments: query (required), customer (optional), type (optional)\n   - Include sections: Prerequisites, Steps, Parameters, Examples, Output, Error Handling\n   - Examples should match PRD format: `/search-devices \"DC01\"`, etc.\n\n4. **resolve-alert.md**:\n   - Purpose: Resolve or dismiss an active alert\n   - Arguments: alert-id (required), action (optional), note (optional)\n   - Include sections: Prerequisites, Steps, Parameters, Examples, Output, Error Handling\n   - Examples should match PRD format: `/resolve-alert \"12345\" --action resolve --note \"Disk space cleared\"`, etc.\n\nEnsure each command file has proper frontmatter (name, description, arguments) and includes all required sections. The commands should align with the API patterns documented in the skills.",
        "testStrategy": "Review each command file to ensure all required sections are present. Verify that the arguments match the PRD specifications. Check that the examples follow the format provided in the PRD. Validate that the command functionality aligns with the corresponding skill documentation.",
        "priority": "medium",
        "dependencies": [
          1,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Create README.md and Update Marketplace.json",
        "description": "Create a comprehensive README.md file for the plugin and update the marketplace.json with the new plugin entry.",
        "details": "Create a README.md file in the root directory with the following sections:\n\n1. **Overview**: Brief description of the Atera Claude Code Plugin and its purpose.\n2. **Installation**: Instructions for installing and configuring the plugin, including API key setup.\n3. **Skills**: Summary of the 6 skills (agents, tickets, devices, customers, alerts, api-patterns) with brief descriptions.\n4. **Commands**: Summary of the 4 commands (lookup-agent, create-ticket, search-devices, resolve-alert) with brief descriptions and example usage.\n5. **Configuration**: Details on the .mcp.json configuration and environment variables.\n6. **Development**: Guidelines for contributing to the plugin development.\n7. **Testing**: Instructions for testing the plugin functionality.\n8. **Resources**: Links to Atera API documentation and related resources.\n\nUpdate the marketplace.json file to include the new Atera plugin entry with appropriate metadata (name, description, version, etc.).",
        "testStrategy": "Review the README.md file to ensure all required sections are present and the content is comprehensive. Verify that the installation instructions are clear and include API key setup. Check that the skills and commands summaries accurately reflect the implemented functionality. Validate that the marketplace.json entry contains all required fields and matches the plugin.json metadata.",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Test and Validate Plugin",
        "description": "Perform comprehensive testing and validation of the Atera Claude Code Plugin against the acceptance criteria.",
        "details": "Test the plugin against the acceptance criteria specified in the PRD:\n\n1. Verify all 6 skills exist with proper frontmatter (description, triggers).\n2. Verify all 4 commands exist with proper frontmatter (name, description, arguments).\n3. Check that each skill contains: Overview, Key Concepts, Field Reference, API Patterns, Workflows, Error Handling, Best Practices, Related Skills.\n4. Check that each command contains: Prerequisites, Steps, Parameters, Examples, Output, Error Handling.\n5. Verify the Alerts skill documents all alert categories and severities.\n6. Validate that plugin.json correctly references all skills and commands.\n7. Validate that .mcp.json is configured for atera-mcp server.\n8. Check that no hardcoded credentials exist in any file.\n9. Validate API examples against Atera documentation.\n10. Verify that marketplace.json is updated with the atera plugin entry.\n\nDocument any issues found and make necessary corrections. Create a test report documenting the validation results for each acceptance criterion.",
        "testStrategy": "Use a checklist approach to systematically verify each acceptance criterion. For API validation, compare examples against the official Atera API documentation. Check for hardcoded credentials using a code scanning tool. Verify directory structure and file contents against the PRD specifications. Document all test results in a structured test report.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-02-05T02:04:47.615Z",
      "updated": "2026-02-05T02:04:47.615Z",
      "description": "Tasks for atera-plugin context"
    }
  },
  "halopsa-plugin": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Plugin Directory Structure and Base Files",
        "description": "Set up the initial directory structure and base files for the HaloPSA Claude Code Plugin according to the specified structure in the PRD.",
        "details": "Create the following directory structure and files:\n\n```\nhalopsa/halopsa/\n .claude-plugin/\n    plugin.json\n .mcp.json\n README.md\n skills/\n    tickets/\n       SKILL.md\n    clients/\n       SKILL.md\n    sites/\n       SKILL.md\n    assets/\n       SKILL.md\n    contracts/\n       SKILL.md\n    api-patterns/\n        SKILL.md\n commands/\n     lookup-client.md\n     create-ticket.md\n     search-assets.md\n     get-contract.md\n```\n\nCreate a basic README.md with project overview, installation instructions, and usage examples. The README should include:\n- Project title and description\n- Installation steps\n- Configuration requirements\n- Basic usage examples\n- Link to HaloPSA API documentation",
        "testStrategy": "Verify that all directories and files are created with the correct structure. Ensure README.md contains all required sections and provides clear instructions for installation and usage.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement plugin.json Manifest",
        "description": "Create the plugin.json manifest file with all required configuration for the HaloPSA Claude Code Plugin.",
        "details": "Create the plugin.json file in the .claude-plugin directory with the following content:\n\n```json\n{\n  \"name\": \"halopsa\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Claude plugins for HaloPSA - tickets, clients, sites, assets, contracts, OAuth 2.0 API\",\n  \"author\": \"MSP Claude Plugins Community\",\n  \"vendor\": \"halopsa\",\n  \"product\": \"halopsa\",\n  \"api_version\": \"v1\",\n  \"requires_api_key\": true,\n  \"authentication\": \"oauth2\",\n  \"documentation_url\": \"https://halopsa.com/apidoc/\",\n  \"skills\": [\n    \"tickets\",\n    \"clients\",\n    \"sites\",\n    \"assets\",\n    \"contracts\",\n    \"api-patterns\"\n  ],\n  \"commands\": [\n    \"lookup-client\",\n    \"create-ticket\",\n    \"search-assets\",\n    \"get-contract\"\n  ]\n}\n```\n\nEnsure that all fields are properly configured according to the PRD specifications.",
        "testStrategy": "Validate the JSON structure for syntax errors. Verify that all required fields are present and correctly configured. Check that the skills and commands arrays match the planned implementation.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement .mcp.json Configuration",
        "description": "Create the .mcp.json configuration file with OAuth 2.0 environment variables for HaloPSA API integration.",
        "details": "Create the .mcp.json file in the root directory with the following content:\n\n```json\n{\n  \"mcpServers\": {\n    \"halopsa\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"halopsa-mcp\"],\n      \"env\": {\n        \"HALOPSA_CLIENT_ID\": \"${HALOPSA_CLIENT_ID}\",\n        \"HALOPSA_CLIENT_SECRET\": \"${HALOPSA_CLIENT_SECRET}\",\n        \"HALOPSA_TENANT\": \"${HALOPSA_TENANT}\",\n        \"HALOPSA_RESOURCE_SERVER\": \"${HALOPSA_RESOURCE_SERVER:-https://api.halopsa.com}\"\n      }\n    }\n  }\n}\n```\n\nEnsure that the configuration properly handles environment variables for OAuth 2.0 authentication without hardcoding any credentials.",
        "testStrategy": "Validate the JSON structure for syntax errors. Verify that all required environment variables are properly referenced. Test with sample environment variables to ensure proper substitution.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Develop API Patterns Skill",
        "description": "Create the API Patterns skill with comprehensive documentation on HaloPSA OAuth 2.0 authentication flow and API interaction patterns.",
        "details": "Create the api-patterns/SKILL.md file with the following sections:\n\n1. **Overview**: Introduction to HaloPSA API and OAuth 2.0 authentication\n2. **Key Concepts**: OAuth 2.0 flow, token management, API structure\n3. **OAuth 2.0 Authentication**:\n   - Token request process\n   - Example request/response\n   - Token usage with Bearer authentication\n   - Token refresh strategies\n4. **API Patterns**:\n   - Base URL structure (https://{tenant}.halopsa.com/api)\n   - RESTful conventions\n   - Pagination (paginate, page_no, page_size)\n   - Filtering options\n   - Sorting (order, orderdesc)\n   - Include related data (include_details)\n5. **Response Structure**: JSON format, nested objects\n6. **Error Handling**: HTTP status codes, error responses\n7. **Rate Limiting**: Best practices\n8. **Common Endpoints Reference**\n9. **Related Skills**\n\nInclude detailed code examples for OAuth token requests, token usage, and API calls with proper formatting.",
        "testStrategy": "Review the skill document for completeness and accuracy. Verify that all sections are present and contain detailed information. Validate OAuth 2.0 flow examples against HaloPSA documentation. Check that all API patterns are correctly documented.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Develop Tickets Skill",
        "description": "Create the Tickets skill with comprehensive documentation on managing tickets in HaloPSA.",
        "details": "Create the tickets/SKILL.md file with the following sections:\n\n1. **Overview**: Introduction to HaloPSA ticket management\n2. **Key Concepts**: Ticket structure, types, statuses, priorities\n3. **Field Reference**:\n   - Ticket structure (id, summary, details, status)\n   - Ticket statuses (configurable workflow states)\n   - Ticket types (Incident, Service Request, Problem, Change)\n   - Ticket priorities and impact/urgency matrix\n   - Ticket categories and sub-categories\n   - SLA tracking and targets\n   - Time tracking (billable vs non-billable)\n   - Assignments, queues, and teams\n   - Related items (assets, users, contracts)\n   - Custom fields\n4. **API Patterns**:\n   - Ticket creation\n   - Ticket retrieval\n   - Ticket updates\n   - Ticket search/filtering\n   - Time entry\n   - Status changes\n5. **Workflows**: Common ticket management scenarios\n6. **Error Handling**: Common errors and solutions\n7. **Best Practices**: Recommendations for ticket management\n8. **Related Skills**: Links to related skills\n\nInclude appropriate triggers: 'halopsa ticket', 'halo ticket', 'create ticket', 'ticket status', 'service desk ticket'",
        "testStrategy": "Review the skill document for completeness and accuracy. Verify that all sections are present and contain detailed information. Check that all ticket fields, types, and statuses are correctly documented. Validate API examples against HaloPSA documentation.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Develop Clients Skill",
        "description": "Create the Clients skill with comprehensive documentation on managing clients in HaloPSA.",
        "details": "Create the clients/SKILL.md file with the following sections:\n\n1. **Overview**: Introduction to HaloPSA client management\n2. **Key Concepts**: Client structure, types, relationships\n3. **Field Reference**:\n   - Client structure (id, name, type)\n   - Client types and classifications\n   - Client fields (name, website, phone, email)\n   - Client addresses\n   - Primary contact and main site\n   - Client users and contacts\n   - Client custom fields\n   - Client notes and activity\n   - Associated entities (sites, assets, tickets)\n   - Client portal access\n   - Billing and invoice settings\n4. **API Patterns**:\n   - Client creation\n   - Client retrieval\n   - Client updates\n   - Client search/filtering\n   - Related entity retrieval\n5. **Workflows**: Common client management scenarios\n6. **Error Handling**: Common errors and solutions\n7. **Best Practices**: Recommendations for client management\n8. **Related Skills**: Links to related skills\n\nInclude appropriate triggers: 'halopsa client', 'halo client', 'client lookup', 'customer search', 'client management'",
        "testStrategy": "Review the skill document for completeness and accuracy. Verify that all sections are present and contain detailed information. Check that all client fields, types, and relationships are correctly documented. Validate API examples against HaloPSA documentation.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Develop Sites Skill",
        "description": "Create the Sites skill with comprehensive documentation on managing sites in HaloPSA.",
        "details": "Create the sites/SKILL.md file with the following sections:\n\n1. **Overview**: Introduction to HaloPSA site management\n2. **Key Concepts**: Site structure, types, relationships\n3. **Field Reference**:\n   - Site structure (id, name, client_id)\n   - Site fields (address, phone, notes)\n   - Site types (Main, Branch, Remote)\n   - Site contacts\n   - Site operating hours\n   - Site-level custom fields\n   - Associated entities (assets, tickets)\n   - Site-level SLAs\n   - Geographic information\n   - Time zone settings\n4. **API Patterns**:\n   - Site creation\n   - Site retrieval\n   - Site updates\n   - Site search/filtering\n   - Related entity retrieval\n5. **Workflows**: Common site management scenarios\n6. **Error Handling**: Common errors and solutions\n7. **Best Practices**: Recommendations for site management\n8. **Related Skills**: Links to related skills\n\nInclude appropriate triggers: 'halopsa site', 'halo site', 'client site', 'location lookup', 'site management'",
        "testStrategy": "Review the skill document for completeness and accuracy. Verify that all sections are present and contain detailed information. Check that all site fields, types, and relationships are correctly documented. Validate API examples against HaloPSA documentation.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Develop Assets Skill",
        "description": "Create the Assets skill with comprehensive documentation on managing assets in HaloPSA.",
        "details": "Create the assets/SKILL.md file with the following sections:\n\n1. **Overview**: Introduction to HaloPSA asset management\n2. **Key Concepts**: Asset structure, types, relationships\n3. **Field Reference**:\n   - Asset structure (id, name, type, status)\n   - Asset types (configurable)\n   - Asset statuses (Active, Inactive, Retired, etc.)\n   - Asset fields (serial_number, model, manufacturer)\n   - Asset-client relationships\n   - Asset-site relationships\n   - Asset warranty tracking\n   - Software assets\n   - Asset custom fields\n   - Asset notes and activity\n   - Related tickets\n   - Asset auditing and history\n   - Contract coverage\n4. **API Patterns**:\n   - Asset creation\n   - Asset retrieval\n   - Asset updates\n   - Asset search/filtering\n   - Related entity retrieval\n5. **Workflows**: Common asset management scenarios\n6. **Error Handling**: Common errors and solutions\n7. **Best Practices**: Recommendations for asset management\n8. **Related Skills**: Links to related skills\n\nInclude appropriate triggers: 'halopsa asset', 'halo asset', 'asset lookup', 'device search', 'asset inventory'",
        "testStrategy": "Review the skill document for completeness and accuracy. Verify that all sections are present and contain detailed information. Check that all asset fields, types, and relationships are correctly documented. Validate API examples against HaloPSA documentation.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Develop Contracts Skill",
        "description": "Create the Contracts skill with comprehensive documentation on managing contracts and billing in HaloPSA.",
        "details": "Create the contracts/SKILL.md file with the following sections:\n\n1. **Overview**: Introduction to HaloPSA contract management\n2. **Key Concepts**: Contract structure, types, relationships\n3. **Field Reference**:\n   - Contract structure (id, name, type, status)\n   - Contract types (Recurring, Prepaid, Block Hours, etc.)\n   - Contract statuses (Active, Expired, Cancelled)\n   - Contract billing (monthly, quarterly, annual)\n   - Contract coverage (clients, sites, assets)\n   - Contract items and line items\n   - Prepaid hours tracking\n   - Contract renewal\n   - SLA associations\n   - Invoice generation\n   - Payment terms\n   - Contract custom fields\n4. **API Patterns**:\n   - Contract creation\n   - Contract retrieval\n   - Contract updates\n   - Contract search/filtering\n   - Related entity retrieval\n5. **Workflows**: Common contract management scenarios\n6. **Error Handling**: Common errors and solutions\n7. **Best Practices**: Recommendations for contract management\n8. **Related Skills**: Links to related skills\n\nInclude appropriate triggers: 'halopsa contract', 'halo contract', 'contract lookup', 'billing contract', 'service agreement'",
        "testStrategy": "Review the skill document for completeness and accuracy. Verify that all sections are present and contain detailed information. Check that all contract fields, types, and relationships are correctly documented. Validate API examples against HaloPSA documentation.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Develop Commands",
        "description": "Create the four command files for the HaloPSA Claude Code Plugin: lookup-client, create-ticket, search-assets, and get-contract.",
        "details": "Create the following command files in the commands directory:\n\n1. **lookup-client.md**:\n   - Prerequisites: API access, client permissions\n   - Steps: Authentication, search query, response parsing\n   - Parameters: query (required), include-sites (optional), include-contacts (optional)\n   - Examples: `/lookup-client \"Acme Corp\"`, `/lookup-client \"Acme\" --include-sites --include-contacts`\n   - Output: Client details including name, primary contact, main site, open tickets count, active contracts\n   - Error Handling: Client not found, authentication errors\n\n2. **create-ticket.md**:\n   - Prerequisites: API access, ticket creation permissions\n   - Steps: Authentication, client validation, ticket creation\n   - Parameters: summary (required), client (required), details (optional), type (optional), priority (optional), site (optional)\n   - Examples: `/create-ticket \"Email server down\" --client \"Acme Corp\" --type incident --priority critical`\n   - Output: Created ticket number, ID, and direct link\n   - Error Handling: Client not found, validation errors\n\n3. **search-assets.md**:\n   - Prerequisites: API access, asset permissions\n   - Steps: Authentication, search query, response parsing\n   - Parameters: query (required), client (optional), type (optional), status (optional)\n   - Examples: `/search-assets \"DC01\"`, `/search-assets --client \"Acme Corp\" --type server`\n   - Output: Asset list with name, type, client, site, status, warranty info\n   - Error Handling: Assets not found, search errors\n\n4. **get-contract.md**:\n   - Prerequisites: API access, contract permissions\n   - Steps: Authentication, contract search, response parsing\n   - Parameters: contract (required), client (optional), status (optional)\n   - Examples: `/get-contract \"Managed Services - Acme\"`, `/get-contract --client \"Acme Corp\" --status active`\n   - Output: Contract details including type, billing, coverage, remaining hours (if prepaid), renewal date\n   - Error Handling: Contract not found, search errors\n\nEnsure each command file includes proper frontmatter with name, description, and argument definitions.",
        "testStrategy": "Review each command file for completeness and accuracy. Verify that all sections are present and contain detailed information. Check that all parameters are correctly defined with proper required/optional status. Validate examples for correctness and clarity.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Update Marketplace.json and Final Testing",
        "description": "Update the marketplace.json file with the HaloPSA plugin entry and perform final testing of the plugin.",
        "details": "1. Update the marketplace.json file with the HaloPSA plugin entry:\n```json\n{\n  \"plugins\": [\n    // ... existing plugins ...\n    {\n      \"name\": \"halopsa\",\n      \"displayName\": \"HaloPSA\",\n      \"description\": \"Claude plugins for HaloPSA - tickets, clients, sites, assets, contracts, OAuth 2.0 API\",\n      \"vendor\": \"halopsa\",\n      \"product\": \"halopsa\",\n      \"version\": \"1.0.0\",\n      \"repository\": \"halopsa/halopsa\",\n      \"icon\": \"https://halopsa.com/wp-content/uploads/2021/03/halo-logo.svg\",\n      \"tags\": [\"msp\", \"psa\", \"ticketing\", \"service-desk\", \"oauth2\"]\n    }\n  ]\n}\n```\n\n2. Perform final testing:\n   - Validate all skills have required sections\n   - Validate all commands have required arguments\n   - Test MCP integration with OAuth flow\n   - Verify directory structure matches PRD\n   - Check for any hardcoded credentials\n   - Validate API examples against HaloPSA documentation\n   - Ensure README.md is comprehensive and accurate\n\n3. Create a final checklist to verify all acceptance criteria are met:\n   - All 6 skills exist with proper frontmatter\n   - All 4 commands exist with proper frontmatter\n   - Each skill contains all required sections\n   - Each command contains all required sections\n   - API patterns skill thoroughly documents OAuth 2.0 authentication flow\n   - plugin.json correctly references all skills and commands\n   - .mcp.json is configured for halopsa-mcp server with OAuth credentials\n   - No hardcoded credentials in any file\n   - API examples validated against HaloPSA documentation\n   - Marketplace.json updated with halopsa plugin entry",
        "testStrategy": "Perform a comprehensive review of all files and components. Use a checklist to verify that all acceptance criteria are met. Test the plugin with sample OAuth credentials to ensure proper authentication flow. Validate the marketplace.json entry for correctness.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-02-05T02:04:48.098Z",
      "updated": "2026-02-05T02:04:48.098Z",
      "description": "Tasks for halopsa-plugin context"
    }
  }
}